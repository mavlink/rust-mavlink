---
source: mavlink-bindgen/tests/e2e_snapshots.rs
assertion_line: 26
expression: contents
---
#![doc = "MAVLink deprecated dialect."]
#![doc = ""]
#![doc = "This file was automatically generated, do not edit."]
#![allow(deprecated)]
#[cfg(feature = "arbitrary")]
use arbitrary::Arbitrary;
#[allow(unused_imports)]
use bitflags::bitflags;
use mavlink_core::{bytes::Bytes, bytes_mut::BytesMut, MavlinkVersion, Message, MessageData};
#[allow(unused_imports)]
use num_derive::FromPrimitive;
#[allow(unused_imports)]
use num_derive::ToPrimitive;
#[allow(unused_imports)]
use num_traits::FromPrimitive;
#[allow(unused_imports)]
use num_traits::ToPrimitive;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[cfg(feature = "ts")]
use ts_rs::TS;
#[cfg_attr(feature = "ts", derive(TS))]
#[cfg_attr(feature = "ts", ts(export))]
#[derive(Debug, Copy, Clone, PartialEq, FromPrimitive, ToPrimitive)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type"))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[repr(u32)]
pub enum MavFrame {
    #[deprecated = "Use MAV_FRAME_GLOBAL in COMMAND_INT (and elsewhere) as a synonymous replacement. See `MAV_FRAME_GLOBAL` (Deprecated since 2024-03)"]
    #[doc = "Global (WGS84) coordinate frame (scaled) + altitude relative to mean sea level (MSL)."]
    MAV_FRAME_GLOBAL_INT = 5,
}
impl MavFrame {
    pub const DEFAULT: Self = Self::MAV_FRAME_GLOBAL_INT;
}
impl Default for MavFrame {
    fn default() -> Self {
        Self::DEFAULT
    }
}
#[cfg_attr(feature = "ts", derive(TS))]
#[cfg_attr(feature = "ts", ts(export))]
#[derive(Debug, Copy, Clone, PartialEq, FromPrimitive, ToPrimitive)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type"))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[repr(u32)]
#[deprecated = " See `GIMBAL_MANAGER_FLAGS` (Deprecated since 2020-01)"]
#[doc = "Enumeration of possible mount operation modes. This message is used by obsolete/deprecated gimbal messages."]
pub enum MavMountMode {
    #[doc = "Load and keep safe position (Roll,Pitch,Yaw) from permanent memory and stop stabilization"]
    MAV_MOUNT_MODE_RETRACT = 0,
}
impl MavMountMode {
    pub const DEFAULT: Self = Self::MAV_MOUNT_MODE_RETRACT;
}
impl Default for MavMountMode {
    fn default() -> Self {
        Self::DEFAULT
    }
}
#[deprecated = "To be removed / merged with TIMESYNC. See `TIMESYNC` (Deprecated since 2011-08)"]
#[doc = "A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at <https://mavlink.io/en/services/ping.html>."]
#[doc = ""]
#[doc = "ID: 4"]
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(feature = "ts", derive(TS))]
#[cfg_attr(feature = "ts", ts(export))]
pub struct PING_DATA {
    #[doc = "Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number."]
    pub time_usec: u64,
    #[doc = "PING sequence"]
    pub seq: u32,
    #[doc = "0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system"]
    pub target_system: u8,
    #[doc = "0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component."]
    pub target_component: u8,
}
impl PING_DATA {
    pub const ENCODED_LEN: usize = 14usize;
    pub const DEFAULT: Self = Self {
        time_usec: 0_u64,
        seq: 0_u32,
        target_system: 0_u8,
        target_component: 0_u8,
    };
    #[cfg(feature = "arbitrary")]
    pub fn random<R: rand::RngCore>(rng: &mut R) -> Self {
        use arbitrary::{Arbitrary, Unstructured};
        let mut buf = [0u8; 1024];
        rng.fill_bytes(&mut buf);
        let mut unstructured = Unstructured::new(&buf);
        Self::arbitrary(&mut unstructured).unwrap_or_default()
    }
}
impl Default for PING_DATA {
    fn default() -> Self {
        Self::DEFAULT.clone()
    }
}
impl MessageData for PING_DATA {
    type Message = MavMessage;
    const ID: u32 = 4u32;
    const NAME: &'static str = "PING";
    const EXTRA_CRC: u8 = 237u8;
    const ENCODED_LEN: usize = 14usize;
    fn deser(
        _version: MavlinkVersion,
        __input: &[u8],
    ) -> Result<Self, ::mavlink_core::error::ParserError> {
        let avail_len = __input.len();
        let mut payload_buf = [0; Self::ENCODED_LEN];
        let mut buf = if avail_len < Self::ENCODED_LEN {
            payload_buf[0..avail_len].copy_from_slice(__input);
            Bytes::new(&payload_buf)
        } else {
            Bytes::new(__input)
        };
        let mut __struct = Self::default();
        __struct.time_usec = buf.get_u64_le();
        __struct.seq = buf.get_u32_le();
        __struct.target_system = buf.get_u8();
        __struct.target_component = buf.get_u8();
        Ok(__struct)
    }
    fn ser(&self, version: MavlinkVersion, bytes: &mut [u8]) -> usize {
        let mut __tmp = BytesMut::new(bytes);
        #[allow(clippy::absurd_extreme_comparisons)]
        #[allow(unused_comparisons)]
        if __tmp.remaining() < Self::ENCODED_LEN {
            panic!(
                "buffer is too small (need {} bytes, but got {})",
                Self::ENCODED_LEN,
                __tmp.remaining(),
            )
        }
        __tmp.put_u64_le(self.time_usec);
        __tmp.put_u32_le(self.seq);
        __tmp.put_u8(self.target_system);
        __tmp.put_u8(self.target_component);
        if matches!(version, MavlinkVersion::V2) {
            let len = __tmp.len();
            ::mavlink_core::utils::remove_trailing_zeroes(&bytes[..len])
        } else {
            __tmp.len()
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type"))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(feature = "ts", derive(TS))]
#[cfg_attr(feature = "ts", ts(export))]
#[repr(u32)]
pub enum MavMessage {
    #[doc = "A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at <https://mavlink.io/en/services/ping.html>."]
    #[doc = ""]
    #[doc = "ID: 4"]
    #[deprecated = "To be removed / merged with TIMESYNC. See `TIMESYNC` (Deprecated since 2011-08)"]
    PING(PING_DATA),
}
impl MavMessage {
    pub const fn all_ids() -> &'static [u32] {
        &[4u32]
    }
}
impl Message for MavMessage {
    fn parse(
        version: MavlinkVersion,
        id: u32,
        payload: &[u8],
    ) -> Result<Self, ::mavlink_core::error::ParserError> {
        match id {
            PING_DATA::ID => PING_DATA::deser(version, payload).map(Self::PING),
            _ => Err(::mavlink_core::error::ParserError::UnknownMessage { id }),
        }
    }
    fn message_name(&self) -> &'static str {
        match self {
            Self::PING(..) => PING_DATA::NAME,
        }
    }
    fn message_id(&self) -> u32 {
        match self {
            Self::PING(..) => PING_DATA::ID,
        }
    }
    fn message_id_from_name(name: &str) -> Option<u32> {
        match name {
            PING_DATA::NAME => Some(PING_DATA::ID),
            _ => None,
        }
    }
    fn default_message_from_id(id: u32) -> Option<Self> {
        match id {
            PING_DATA::ID => Some(Self::PING(PING_DATA::default())),
            _ => None,
        }
    }
    #[cfg(feature = "arbitrary")]
    fn random_message_from_id<R: rand::RngCore>(id: u32, rng: &mut R) -> Option<Self> {
        match id {
            PING_DATA::ID => Some(Self::PING(PING_DATA::random(rng))),
            _ => None,
        }
    }
    fn ser(&self, version: MavlinkVersion, bytes: &mut [u8]) -> usize {
        match self {
            Self::PING(body) => body.ser(version, bytes),
        }
    }
    fn extra_crc(id: u32) -> u8 {
        match id {
            PING_DATA::ID => PING_DATA::EXTRA_CRC,
            _ => 0,
        }
    }
    fn target_system_id(&self) -> Option<u8> {
        match self {
            Self::PING(inner) => Some(inner.target_system),
            _ => None,
        }
    }
    fn target_component_id(&self) -> Option<u8> {
        match self {
            Self::PING(inner) => Some(inner.target_component),
            _ => None,
        }
    }
}
