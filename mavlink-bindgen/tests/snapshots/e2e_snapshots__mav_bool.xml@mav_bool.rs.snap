---
source: mavlink-bindgen/tests/e2e_snapshots.rs
assertion_line: 26
expression: contents
---
#![doc = "MAVLink mav_bool dialect."]
#![doc = ""]
#![doc = "This file was automatically generated, do not edit."]
#![allow(deprecated)]
#[cfg(feature = "arbitrary")]
use arbitrary::Arbitrary;
#[allow(unused_imports)]
use bitflags::{bitflags, Flags};
use mavlink_core::{
    bytes::Bytes, bytes_mut::BytesMut, types::CharArray, MavlinkVersion, Message, MessageData,
};
#[allow(unused_imports)]
use num_derive::FromPrimitive;
#[allow(unused_imports)]
use num_derive::ToPrimitive;
#[allow(unused_imports)]
use num_traits::FromPrimitive;
#[allow(unused_imports)]
use num_traits::ToPrimitive;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[cfg(feature = "ts")]
use ts_rs::TS;
bitflags! { # [cfg_attr (feature = "ts" , derive (TS))] # [cfg_attr (feature = "ts" , ts (export , type = "number"))] # [cfg_attr (feature = "serde" , derive (Serialize , Deserialize))] # [cfg_attr (feature = "arbitrary" , derive (Arbitrary))] # [derive (Debug , Copy , Clone , PartialEq)] # [doc = "Enum used to indicate true or false (also: success or failure, enabled or disabled, active or inactive)."] pub struct MavBool : i8 { # [doc = "False."] const MAV_BOOL_FALSE = 0 ; # [doc = "True."] const MAV_BOOL_TRUE = 1 ; } }
impl MavBool {
    pub const DEFAULT: Self = Self::MAV_BOOL_FALSE;
    pub fn as_bool(&self) -> bool {
        self.contains(Self::MAV_BOOL_TRUE)
    }
}
impl Default for MavBool {
    fn default() -> Self {
        Self::DEFAULT
    }
}
#[doc = "A message with MAV_BOOL."]
#[doc = ""]
#[doc = "ID: 149"]
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(feature = "ts", derive(TS))]
#[cfg_attr(feature = "ts", ts(export))]
pub struct BOOL_TEST_MESSAGE_DATA {
    #[doc = "unsigned"]
    pub bool_uint8: MavBool,
    #[doc = "signed"]
    pub bool_int8: MavBool,
}
impl BOOL_TEST_MESSAGE_DATA {
    pub const ENCODED_LEN: usize = 2usize;
    pub const DEFAULT: Self = Self {
        bool_uint8: MavBool::DEFAULT,
        bool_int8: MavBool::DEFAULT,
    };
    #[cfg(feature = "arbitrary")]
    pub fn random<R: rand::RngCore>(rng: &mut R) -> Self {
        use arbitrary::{Arbitrary, Unstructured};
        let mut buf = [0u8; 1024];
        rng.fill_bytes(&mut buf);
        let mut unstructured = Unstructured::new(&buf);
        Self::arbitrary(&mut unstructured).unwrap_or_default()
    }
}
impl Default for BOOL_TEST_MESSAGE_DATA {
    fn default() -> Self {
        Self::DEFAULT.clone()
    }
}
impl MessageData for BOOL_TEST_MESSAGE_DATA {
    type Message = MavMessage;
    const ID: u32 = 149u32;
    const NAME: &'static str = "BOOL_TEST_MESSAGE";
    const EXTRA_CRC: u8 = 13u8;
    const ENCODED_LEN: usize = 2usize;
    fn deser(
        _version: MavlinkVersion,
        __input: &[u8],
    ) -> Result<Self, ::mavlink_core::error::ParserError> {
        let avail_len = __input.len();
        let mut payload_buf = [0; Self::ENCODED_LEN];
        let mut buf = if avail_len < Self::ENCODED_LEN {
            payload_buf[0..avail_len].copy_from_slice(__input);
            Bytes::new(&payload_buf)
        } else {
            Bytes::new(__input)
        };
        let mut __struct = Self::default();
        let tmp = buf.get_u8();
        __struct.bool_uint8 = MavBool::from_bits(tmp as <MavBool as Flags>::Bits).ok_or(
            ::mavlink_core::error::ParserError::InvalidFlag {
                flag_type: "MavBool",
                value: tmp as u64,
            },
        )?;
        let tmp = buf.get_i8();
        __struct.bool_int8 = MavBool::from_bits(tmp as <MavBool as Flags>::Bits).ok_or(
            ::mavlink_core::error::ParserError::InvalidFlag {
                flag_type: "MavBool",
                value: tmp as u64,
            },
        )?;
        Ok(__struct)
    }
    fn ser(&self, version: MavlinkVersion, bytes: &mut [u8]) -> usize {
        let mut __tmp = BytesMut::new(bytes);
        #[allow(clippy::absurd_extreme_comparisons)]
        #[allow(unused_comparisons)]
        if __tmp.remaining() < Self::ENCODED_LEN {
            panic!(
                "buffer is too small (need {} bytes, but got {})",
                Self::ENCODED_LEN,
                __tmp.remaining(),
            )
        }
        __tmp.put_u8(self.bool_uint8.bits() as u8);
        __tmp.put_i8(self.bool_int8.bits() as i8);
        if matches!(version, MavlinkVersion::V2) {
            let len = __tmp.len();
            ::mavlink_core::utils::remove_trailing_zeroes(&bytes[..len])
        } else {
            __tmp.len()
        }
    }
}
#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type"))]
#[cfg_attr(feature = "arbitrary", derive(Arbitrary))]
#[cfg_attr(feature = "ts", derive(TS))]
#[cfg_attr(feature = "ts", ts(export))]
#[repr(u32)]
pub enum MavMessage {
    #[doc = "A message with MAV_BOOL."]
    #[doc = ""]
    #[doc = "ID: 149"]
    BOOL_TEST_MESSAGE(BOOL_TEST_MESSAGE_DATA),
}
impl MavMessage {
    pub const fn all_ids() -> &'static [u32] {
        &[149u32]
    }
}
impl Message for MavMessage {
    fn parse(
        version: MavlinkVersion,
        id: u32,
        payload: &[u8],
    ) -> Result<Self, ::mavlink_core::error::ParserError> {
        match id {
            BOOL_TEST_MESSAGE_DATA::ID => {
                BOOL_TEST_MESSAGE_DATA::deser(version, payload).map(Self::BOOL_TEST_MESSAGE)
            }
            _ => Err(::mavlink_core::error::ParserError::UnknownMessage { id }),
        }
    }
    fn message_name(&self) -> &'static str {
        match self {
            Self::BOOL_TEST_MESSAGE(..) => BOOL_TEST_MESSAGE_DATA::NAME,
        }
    }
    fn message_id(&self) -> u32 {
        match self {
            Self::BOOL_TEST_MESSAGE(..) => BOOL_TEST_MESSAGE_DATA::ID,
        }
    }
    fn message_id_from_name(name: &str) -> Option<u32> {
        match name {
            BOOL_TEST_MESSAGE_DATA::NAME => Some(BOOL_TEST_MESSAGE_DATA::ID),
            _ => None,
        }
    }
    fn default_message_from_id(id: u32) -> Option<Self> {
        match id {
            BOOL_TEST_MESSAGE_DATA::ID => {
                Some(Self::BOOL_TEST_MESSAGE(BOOL_TEST_MESSAGE_DATA::default()))
            }
            _ => None,
        }
    }
    #[cfg(feature = "arbitrary")]
    fn random_message_from_id<R: rand::RngCore>(id: u32, rng: &mut R) -> Option<Self> {
        match id {
            BOOL_TEST_MESSAGE_DATA::ID => {
                Some(Self::BOOL_TEST_MESSAGE(BOOL_TEST_MESSAGE_DATA::random(rng)))
            }
            _ => None,
        }
    }
    fn ser(&self, version: MavlinkVersion, bytes: &mut [u8]) -> usize {
        match self {
            Self::BOOL_TEST_MESSAGE(body) => body.ser(version, bytes),
        }
    }
    fn extra_crc(id: u32) -> u8 {
        match id {
            BOOL_TEST_MESSAGE_DATA::ID => BOOL_TEST_MESSAGE_DATA::EXTRA_CRC,
            _ => 0,
        }
    }
    fn target_system_id(&self) -> Option<u8> {
        match self {
            _ => None,
        }
    }
    fn target_component_id(&self) -> Option<u8> {
        match self {
            _ => None,
        }
    }
}
