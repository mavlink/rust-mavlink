<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/rust-mavlink/rust-mavlink/target/debug/build/mavlink-4b80b4b516a05a53/out/uavionix.rs`."><title>uavionix.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../../../../../../../../../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../../../../../../../../../../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../../../../../../../../../../../static.files/ayu-be46fdc453a55015.css"><script src="../../../../../../../../../../../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../../../../../../../../../../../../static.files/source-script-1b95b7cca98b26e5.js"></script><script defer src="../../../../../../../../../../../../source-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../../../../../../../../../../../mavlink/index.html"><img class="rust-logo" src="../../../../../../../../../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../../../../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre><pre class="rust"><code># ! [doc = <span class="string">&quot;This file was automatically generated, do not edit&quot;</span>] <span class="kw">use crate </span>:: MavlinkVersion ; # [allow (unused_imports)] <span class="kw">use </span>num_derive :: FromPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>num_traits :: FromPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>num_derive :: ToPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>num_traits :: ToPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>bitflags :: bitflags ; # [allow (unused_imports)] <span class="kw">use </span>heapless :: Vec ; <span class="kw">use crate </span>:: { Message , error :: * , bytes :: Bytes , bytes_mut :: BytesMut } ; # [cfg (feature = <span class="string">&quot;serde&quot;</span>)] <span class="kw">use </span>serde :: { Serialize , Deserialize } ; # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutCfgAircraftSize { UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M = <span class="number">5 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M = <span class="number">6 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M = <span class="number">7 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M = <span class="number">8 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M = <span class="number">9 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M = <span class="number">10 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M = <span class="number">11 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M = <span class="number">12 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M = <span class="number">13 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M = <span class="number">14 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M = <span class="number">15 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutCfgAircraftSize { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>StorageStatus { STORAGE_STATUS_EMPTY = <span class="number">0 </span>, STORAGE_STATUS_UNFORMATTED = <span class="number">1 </span>, STORAGE_STATUS_READY = <span class="number">2 </span>, STORAGE_STATUS_NOT_SUPPORTED = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>StorageStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: STORAGE_STATUS_EMPTY } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HilSensorUpdatedFlags : u32 { <span class="kw">const </span>HIL_SENSOR_UPDATED_NONE = <span class="number">0 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_XACC = <span class="number">1 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_YACC = <span class="number">2 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ZACC = <span class="number">4 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_XGYRO = <span class="number">8 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_YGYRO = <span class="number">16 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ZGYRO = <span class="number">32 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_XMAG = <span class="number">64 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_YMAG = <span class="number">128 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ZMAG = <span class="number">256 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ABS_PRESSURE = <span class="number">512 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_DIFF_PRESSURE = <span class="number">1024 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_PRESSURE_ALT = <span class="number">2048 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_TEMPERATURE = <span class="number">4096 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_RESET = <span class="number">2147483648 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>HilSensorUpdatedFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: HIL_SENSOR_UPDATED_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AdsbAltitudeType { ADSB_ALTITUDE_TYPE_PRESSURE_QNH = <span class="number">0 </span>, ADSB_ALTITUDE_TYPE_GEOMETRIC = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>AdsbAltitudeType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ADSB_ALTITUDE_TYPE_PRESSURE_QNH } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavEstimatorType { MAV_ESTIMATOR_TYPE_UNKNOWN = <span class="number">0 </span>, MAV_ESTIMATOR_TYPE_NAIVE = <span class="number">1 </span>, MAV_ESTIMATOR_TYPE_VISION = <span class="number">2 </span>, MAV_ESTIMATOR_TYPE_VIO = <span class="number">3 </span>, MAV_ESTIMATOR_TYPE_GPS = <span class="number">4 </span>, MAV_ESTIMATOR_TYPE_GPS_INS = <span class="number">5 </span>, MAV_ESTIMATOR_TYPE_MOCAP = <span class="number">6 </span>, MAV_ESTIMATOR_TYPE_LIDAR = <span class="number">7 </span>, MAV_ESTIMATOR_TYPE_AUTOPILOT = <span class="number">8 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavEstimatorType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ESTIMATOR_TYPE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavFtpOpcode { MAV_FTP_OPCODE_NONE = <span class="number">0 </span>, MAV_FTP_OPCODE_TERMINATESESSION = <span class="number">1 </span>, MAV_FTP_OPCODE_RESETSESSION = <span class="number">2 </span>, MAV_FTP_OPCODE_LISTDIRECTORY = <span class="number">3 </span>, MAV_FTP_OPCODE_OPENFILERO = <span class="number">4 </span>, MAV_FTP_OPCODE_READFILE = <span class="number">5 </span>, MAV_FTP_OPCODE_CREATEFILE = <span class="number">6 </span>, MAV_FTP_OPCODE_WRITEFILE = <span class="number">7 </span>, MAV_FTP_OPCODE_REMOVEFILE = <span class="number">8 </span>, MAV_FTP_OPCODE_CREATEDIRECTORY = <span class="number">9 </span>, MAV_FTP_OPCODE_REMOVEDIRECTORY = <span class="number">10 </span>, MAV_FTP_OPCODE_OPENFILEWO = <span class="number">11 </span>, MAV_FTP_OPCODE_TRUNCATEFILE = <span class="number">12 </span>, MAV_FTP_OPCODE_RENAME = <span class="number">13 </span>, MAV_FTP_OPCODE_CALCFILECRC = <span class="number">14 </span>, MAV_FTP_OPCODE_BURSTREADFILE = <span class="number">15 </span>, MAV_FTP_OPCODE_ACK = <span class="number">128 </span>, MAV_FTP_OPCODE_NAK = <span class="number">129 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavFtpOpcode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_FTP_OPCODE_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavcanNodeHealth { UAVCAN_NODE_HEALTH_OK = <span class="number">0 </span>, UAVCAN_NODE_HEALTH_WARNING = <span class="number">1 </span>, UAVCAN_NODE_HEALTH_ERROR = <span class="number">2 </span>, UAVCAN_NODE_HEALTH_CRITICAL = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavcanNodeHealth { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVCAN_NODE_HEALTH_OK } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavGoto { MAV_GOTO_DO_HOLD = <span class="number">0 </span>, MAV_GOTO_DO_CONTINUE = <span class="number">1 </span>, MAV_GOTO_HOLD_AT_CURRENT_POSITION = <span class="number">2 </span>, MAV_GOTO_HOLD_AT_SPECIFIED_POSITION = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavGoto { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_GOTO_DO_HOLD } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PositionTargetTypemask : u16 { <span class="kw">const </span>POSITION_TARGET_TYPEMASK_X_IGNORE = <span class="number">1 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_Y_IGNORE = <span class="number">2 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_Z_IGNORE = <span class="number">4 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_VX_IGNORE = <span class="number">8 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_VY_IGNORE = <span class="number">16 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_VZ_IGNORE = <span class="number">32 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_AX_IGNORE = <span class="number">64 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_AY_IGNORE = <span class="number">128 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_AZ_IGNORE = <span class="number">256 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_FORCE_SET = <span class="number">512 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_YAW_IGNORE = <span class="number">1024 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE = <span class="number">2048 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>PositionTargetTypemask { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: POSITION_TARGET_TYPEMASK_X_IGNORE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavParamExtType { MAV_PARAM_EXT_TYPE_UINT8 = <span class="number">1 </span>, MAV_PARAM_EXT_TYPE_INT8 = <span class="number">2 </span>, MAV_PARAM_EXT_TYPE_UINT16 = <span class="number">3 </span>, MAV_PARAM_EXT_TYPE_INT16 = <span class="number">4 </span>, MAV_PARAM_EXT_TYPE_UINT32 = <span class="number">5 </span>, MAV_PARAM_EXT_TYPE_INT32 = <span class="number">6 </span>, MAV_PARAM_EXT_TYPE_UINT64 = <span class="number">7 </span>, MAV_PARAM_EXT_TYPE_INT64 = <span class="number">8 </span>, MAV_PARAM_EXT_TYPE_REAL32 = <span class="number">9 </span>, MAV_PARAM_EXT_TYPE_REAL64 = <span class="number">10 </span>, MAV_PARAM_EXT_TYPE_CUSTOM = <span class="number">11 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavParamExtType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_PARAM_EXT_TYPE_UINT8 } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PrecisionLandMode { PRECISION_LAND_MODE_DISABLED = <span class="number">0 </span>, PRECISION_LAND_MODE_OPPORTUNISTIC = <span class="number">1 </span>, PRECISION_LAND_MODE_REQUIRED = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>PrecisionLandMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: PRECISION_LAND_MODE_DISABLED } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalManagerCapFlags : u32 { <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_NEUTRAL = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_AXIS = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_FOLLOW = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_LOCK = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_AXIS = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_FOLLOW = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_LOCK = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_AXIS = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_FOLLOW = <span class="number">512 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_LOCK = <span class="number">1024 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_INFINITE_YAW = <span class="number">2048 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME = <span class="number">4096 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_RC_INPUTS = <span class="number">8192 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_LOCAL = <span class="number">65536 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_GLOBAL = <span class="number">131072 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalManagerCapFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavRoi { MAV_ROI_NONE = <span class="number">0 </span>, MAV_ROI_WPNEXT = <span class="number">1 </span>, MAV_ROI_WPINDEX = <span class="number">2 </span>, MAV_ROI_LOCATION = <span class="number">3 </span>, MAV_ROI_TARGET = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavRoi { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ROI_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FenceMitigate { FENCE_MITIGATE_UNKNOWN = <span class="number">0 </span>, FENCE_MITIGATE_NONE = <span class="number">1 </span>, FENCE_MITIGATE_VEL_LIMIT = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>FenceMitigate { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FENCE_MITIGATE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavDoRepositionFlags { MAV_DO_REPOSITION_FLAGS_CHANGE_MODE = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavDoRepositionFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_DO_REPOSITION_FLAGS_CHANGE_MODE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>NavVtolLandOptions { NAV_VTOL_LAND_OPTIONS_DEFAULT = <span class="number">0 </span>, NAV_VTOL_LAND_OPTIONS_FW_DESCENT = <span class="number">1 </span>, NAV_VTOL_LAND_OPTIONS_HOVER_DESCENT = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>NavVtolLandOptions { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: NAV_VTOL_LAND_OPTIONS_DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AisNavStatus { UNDER_WAY = <span class="number">0 </span>, AIS_NAV_ANCHORED = <span class="number">1 </span>, AIS_NAV_UN_COMMANDED = <span class="number">2 </span>, AIS_NAV_RESTRICTED_MANOEUVERABILITY = <span class="number">3 </span>, AIS_NAV_DRAUGHT_CONSTRAINED = <span class="number">4 </span>, AIS_NAV_MOORED = <span class="number">5 </span>, AIS_NAV_AGROUND = <span class="number">6 </span>, AIS_NAV_FISHING = <span class="number">7 </span>, AIS_NAV_SAILING = <span class="number">8 </span>, AIS_NAV_RESERVED_HSC = <span class="number">9 </span>, AIS_NAV_RESERVED_WIG = <span class="number">10 </span>, AIS_NAV_RESERVED_1 = <span class="number">11 </span>, AIS_NAV_RESERVED_2 = <span class="number">12 </span>, AIS_NAV_RESERVED_3 = <span class="number">13 </span>, AIS_NAV_AIS_SART = <span class="number">14 </span>, AIS_NAV_UNKNOWN = <span class="number">15 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>AisNavStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UNDER_WAY } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidSpeedAcc { MAV_ODID_SPEED_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_SPEED_ACC_10_METERS_PER_SECOND = <span class="number">1 </span>, MAV_ODID_SPEED_ACC_3_METERS_PER_SECOND = <span class="number">2 </span>, MAV_ODID_SPEED_ACC_1_METERS_PER_SECOND = <span class="number">3 </span>, MAV_ODID_SPEED_ACC_0_3_METERS_PER_SECOND = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidSpeedAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_SPEED_ACC_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>StorageType { STORAGE_TYPE_UNKNOWN = <span class="number">0 </span>, STORAGE_TYPE_USB_STICK = <span class="number">1 </span>, STORAGE_TYPE_SD = <span class="number">2 </span>, STORAGE_TYPE_MICROSD = <span class="number">3 </span>, STORAGE_TYPE_CF = <span class="number">4 </span>, STORAGE_TYPE_CFE = <span class="number">5 </span>, STORAGE_TYPE_XQD = <span class="number">6 </span>, STORAGE_TYPE_HD = <span class="number">7 </span>, STORAGE_TYPE_OTHER = <span class="number">254 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>StorageType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: STORAGE_TYPE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MissionState { MISSION_STATE_UNKNOWN = <span class="number">0 </span>, MISSION_STATE_NO_MISSION = <span class="number">1 </span>, MISSION_STATE_NOT_STARTED = <span class="number">2 </span>, MISSION_STATE_ACTIVE = <span class="number">3 </span>, MISSION_STATE_PAUSED = <span class="number">4 </span>, MISSION_STATE_COMPLETE = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MissionState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MISSION_STATE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMissionResult { MAV_MISSION_ACCEPTED = <span class="number">0 </span>, MAV_MISSION_ERROR = <span class="number">1 </span>, MAV_MISSION_UNSUPPORTED_FRAME = <span class="number">2 </span>, MAV_MISSION_UNSUPPORTED = <span class="number">3 </span>, MAV_MISSION_NO_SPACE = <span class="number">4 </span>, MAV_MISSION_INVALID = <span class="number">5 </span>, MAV_MISSION_INVALID_PARAM1 = <span class="number">6 </span>, MAV_MISSION_INVALID_PARAM2 = <span class="number">7 </span>, MAV_MISSION_INVALID_PARAM3 = <span class="number">8 </span>, MAV_MISSION_INVALID_PARAM4 = <span class="number">9 </span>, MAV_MISSION_INVALID_PARAM5_X = <span class="number">10 </span>, MAV_MISSION_INVALID_PARAM6_Y = <span class="number">11 </span>, MAV_MISSION_INVALID_PARAM7 = <span class="number">12 </span>, MAV_MISSION_INVALID_SEQUENCE = <span class="number">13 </span>, MAV_MISSION_DENIED = <span class="number">14 </span>, MAV_MISSION_OPERATION_CANCELLED = <span class="number">15 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavMissionResult { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_MISSION_ACCEPTED } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavProtocolCapability : u64 { <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT = <span class="number">1 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT = <span class="number">2 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_INT = <span class="number">4 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_COMMAND_INT = <span class="number">8 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_BYTEWISE = <span class="number">16 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_FTP = <span class="number">32 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET = <span class="number">64 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED = <span class="number">128 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = <span class="number">256 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_TERRAIN = <span class="number">512 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET = <span class="number">1024 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION = <span class="number">2048 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION = <span class="number">4096 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MAVLINK2 = <span class="number">8192 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_FENCE = <span class="number">16384 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_RALLY = <span class="number">32768 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_RESERVED2 = <span class="number">65536 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_C_CAST = <span class="number">131072 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavProtocolCapability { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>WifiConfigApMode { WIFI_CONFIG_AP_MODE_UNDEFINED = <span class="number">0 </span>, WIFI_CONFIG_AP_MODE_AP = <span class="number">1 </span>, WIFI_CONFIG_AP_MODE_STATION = <span class="number">2 </span>, WIFI_CONFIG_AP_MODE_DISABLED = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>WifiConfigApMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: WIFI_CONFIG_AP_MODE_UNDEFINED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>EscConnectionType { ESC_CONNECTION_TYPE_PPM = <span class="number">0 </span>, ESC_CONNECTION_TYPE_SERIAL = <span class="number">1 </span>, ESC_CONNECTION_TYPE_ONESHOT = <span class="number">2 </span>, ESC_CONNECTION_TYPE_I2C = <span class="number">3 </span>, ESC_CONNECTION_TYPE_CAN = <span class="number">4 </span>, ESC_CONNECTION_TYPE_DSHOT = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>EscConnectionType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ESC_CONNECTION_TYPE_PPM } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidVerAcc { MAV_ODID_VER_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_VER_ACC_150_METER = <span class="number">1 </span>, MAV_ODID_VER_ACC_45_METER = <span class="number">2 </span>, MAV_ODID_VER_ACC_25_METER = <span class="number">3 </span>, MAV_ODID_VER_ACC_10_METER = <span class="number">4 </span>, MAV_ODID_VER_ACC_3_METER = <span class="number">5 </span>, MAV_ODID_VER_ACC_1_METER = <span class="number">6 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidVerAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_VER_ACC_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavAutopilot { MAV_AUTOPILOT_GENERIC = <span class="number">0 </span>, MAV_AUTOPILOT_RESERVED = <span class="number">1 </span>, MAV_AUTOPILOT_SLUGS = <span class="number">2 </span>, MAV_AUTOPILOT_ARDUPILOTMEGA = <span class="number">3 </span>, MAV_AUTOPILOT_OPENPILOT = <span class="number">4 </span>, MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY = <span class="number">5 </span>, MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = <span class="number">6 </span>, MAV_AUTOPILOT_GENERIC_MISSION_FULL = <span class="number">7 </span>, MAV_AUTOPILOT_INVALID = <span class="number">8 </span>, MAV_AUTOPILOT_PPZ = <span class="number">9 </span>, MAV_AUTOPILOT_UDB = <span class="number">10 </span>, MAV_AUTOPILOT_FP = <span class="number">11 </span>, MAV_AUTOPILOT_PX4 = <span class="number">12 </span>, MAV_AUTOPILOT_SMACCMPILOT = <span class="number">13 </span>, MAV_AUTOPILOT_AUTOQUAD = <span class="number">14 </span>, MAV_AUTOPILOT_ARMAZILA = <span class="number">15 </span>, MAV_AUTOPILOT_AEROB = <span class="number">16 </span>, MAV_AUTOPILOT_ASLUAV = <span class="number">17 </span>, MAV_AUTOPILOT_SMARTAP = <span class="number">18 </span>, MAV_AUTOPILOT_AIRRAILS = <span class="number">19 </span>, MAV_AUTOPILOT_REFLEX = <span class="number">20 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavAutopilot { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_AUTOPILOT_GENERIC } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMountMode { MAV_MOUNT_MODE_RETRACT = <span class="number">0 </span>, MAV_MOUNT_MODE_NEUTRAL = <span class="number">1 </span>, MAV_MOUNT_MODE_MAVLINK_TARGETING = <span class="number">2 </span>, MAV_MOUNT_MODE_RC_TARGETING = <span class="number">3 </span>, MAV_MOUNT_MODE_GPS_POINT = <span class="number">4 </span>, MAV_MOUNT_MODE_SYSID_TARGET = <span class="number">5 </span>, MAV_MOUNT_MODE_HOME_LOCATION = <span class="number">6 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavMountMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_MOUNT_MODE_RETRACT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavTunnelPayloadType { MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN = <span class="number">0 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED0 = <span class="number">200 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED1 = <span class="number">201 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED2 = <span class="number">202 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED3 = <span class="number">203 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED4 = <span class="number">204 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED5 = <span class="number">205 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED6 = <span class="number">206 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED7 = <span class="number">207 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED8 = <span class="number">208 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED9 = <span class="number">209 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavTunnelPayloadType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidOperatorLocationType { MAV_ODID_OPERATOR_LOCATION_TYPE_TAKEOFF = <span class="number">0 </span>, MAV_ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS = <span class="number">1 </span>, MAV_ODID_OPERATOR_LOCATION_TYPE_FIXED = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidOperatorLocationType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_OPERATOR_LOCATION_TYPE_TAKEOFF } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AisType { AIS_TYPE_UNKNOWN = <span class="number">0 </span>, AIS_TYPE_RESERVED_1 = <span class="number">1 </span>, AIS_TYPE_RESERVED_2 = <span class="number">2 </span>, AIS_TYPE_RESERVED_3 = <span class="number">3 </span>, AIS_TYPE_RESERVED_4 = <span class="number">4 </span>, AIS_TYPE_RESERVED_5 = <span class="number">5 </span>, AIS_TYPE_RESERVED_6 = <span class="number">6 </span>, AIS_TYPE_RESERVED_7 = <span class="number">7 </span>, AIS_TYPE_RESERVED_8 = <span class="number">8 </span>, AIS_TYPE_RESERVED_9 = <span class="number">9 </span>, AIS_TYPE_RESERVED_10 = <span class="number">10 </span>, AIS_TYPE_RESERVED_11 = <span class="number">11 </span>, AIS_TYPE_RESERVED_12 = <span class="number">12 </span>, AIS_TYPE_RESERVED_13 = <span class="number">13 </span>, AIS_TYPE_RESERVED_14 = <span class="number">14 </span>, AIS_TYPE_RESERVED_15 = <span class="number">15 </span>, AIS_TYPE_RESERVED_16 = <span class="number">16 </span>, AIS_TYPE_RESERVED_17 = <span class="number">17 </span>, AIS_TYPE_RESERVED_18 = <span class="number">18 </span>, AIS_TYPE_RESERVED_19 = <span class="number">19 </span>, AIS_TYPE_WIG = <span class="number">20 </span>, AIS_TYPE_WIG_HAZARDOUS_A = <span class="number">21 </span>, AIS_TYPE_WIG_HAZARDOUS_B = <span class="number">22 </span>, AIS_TYPE_WIG_HAZARDOUS_C = <span class="number">23 </span>, AIS_TYPE_WIG_HAZARDOUS_D = <span class="number">24 </span>, AIS_TYPE_WIG_RESERVED_1 = <span class="number">25 </span>, AIS_TYPE_WIG_RESERVED_2 = <span class="number">26 </span>, AIS_TYPE_WIG_RESERVED_3 = <span class="number">27 </span>, AIS_TYPE_WIG_RESERVED_4 = <span class="number">28 </span>, AIS_TYPE_WIG_RESERVED_5 = <span class="number">29 </span>, AIS_TYPE_FISHING = <span class="number">30 </span>, AIS_TYPE_TOWING = <span class="number">31 </span>, AIS_TYPE_TOWING_LARGE = <span class="number">32 </span>, AIS_TYPE_DREDGING = <span class="number">33 </span>, AIS_TYPE_DIVING = <span class="number">34 </span>, AIS_TYPE_MILITARY = <span class="number">35 </span>, AIS_TYPE_SAILING = <span class="number">36 </span>, AIS_TYPE_PLEASURE = <span class="number">37 </span>, AIS_TYPE_RESERVED_20 = <span class="number">38 </span>, AIS_TYPE_RESERVED_21 = <span class="number">39 </span>, AIS_TYPE_HSC = <span class="number">40 </span>, AIS_TYPE_HSC_HAZARDOUS_A = <span class="number">41 </span>, AIS_TYPE_HSC_HAZARDOUS_B = <span class="number">42 </span>, AIS_TYPE_HSC_HAZARDOUS_C = <span class="number">43 </span>, AIS_TYPE_HSC_HAZARDOUS_D = <span class="number">44 </span>, AIS_TYPE_HSC_RESERVED_1 = <span class="number">45 </span>, AIS_TYPE_HSC_RESERVED_2 = <span class="number">46 </span>, AIS_TYPE_HSC_RESERVED_3 = <span class="number">47 </span>, AIS_TYPE_HSC_RESERVED_4 = <span class="number">48 </span>, AIS_TYPE_HSC_UNKNOWN = <span class="number">49 </span>, AIS_TYPE_PILOT = <span class="number">50 </span>, AIS_TYPE_SAR = <span class="number">51 </span>, AIS_TYPE_TUG = <span class="number">52 </span>, AIS_TYPE_PORT_TENDER = <span class="number">53 </span>, AIS_TYPE_ANTI_POLLUTION = <span class="number">54 </span>, AIS_TYPE_LAW_ENFORCEMENT = <span class="number">55 </span>, AIS_TYPE_SPARE_LOCAL_1 = <span class="number">56 </span>, AIS_TYPE_SPARE_LOCAL_2 = <span class="number">57 </span>, AIS_TYPE_MEDICAL_TRANSPORT = <span class="number">58 </span>, AIS_TYPE_NONECOMBATANT = <span class="number">59 </span>, AIS_TYPE_PASSENGER = <span class="number">60 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_A = <span class="number">61 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_B = <span class="number">62 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_C = <span class="number">63 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_D = <span class="number">64 </span>, AIS_TYPE_PASSENGER_RESERVED_1 = <span class="number">65 </span>, AIS_TYPE_PASSENGER_RESERVED_2 = <span class="number">66 </span>, AIS_TYPE_PASSENGER_RESERVED_3 = <span class="number">67 </span>, AIS_TYPE_PASSENGER_RESERVED_4 = <span class="number">68 </span>, AIS_TYPE_PASSENGER_UNKNOWN = <span class="number">69 </span>, AIS_TYPE_CARGO = <span class="number">70 </span>, AIS_TYPE_CARGO_HAZARDOUS_A = <span class="number">71 </span>, AIS_TYPE_CARGO_HAZARDOUS_B = <span class="number">72 </span>, AIS_TYPE_CARGO_HAZARDOUS_C = <span class="number">73 </span>, AIS_TYPE_CARGO_HAZARDOUS_D = <span class="number">74 </span>, AIS_TYPE_CARGO_RESERVED_1 = <span class="number">75 </span>, AIS_TYPE_CARGO_RESERVED_2 = <span class="number">76 </span>, AIS_TYPE_CARGO_RESERVED_3 = <span class="number">77 </span>, AIS_TYPE_CARGO_RESERVED_4 = <span class="number">78 </span>, AIS_TYPE_CARGO_UNKNOWN = <span class="number">79 </span>, AIS_TYPE_TANKER = <span class="number">80 </span>, AIS_TYPE_TANKER_HAZARDOUS_A = <span class="number">81 </span>, AIS_TYPE_TANKER_HAZARDOUS_B = <span class="number">82 </span>, AIS_TYPE_TANKER_HAZARDOUS_C = <span class="number">83 </span>, AIS_TYPE_TANKER_HAZARDOUS_D = <span class="number">84 </span>, AIS_TYPE_TANKER_RESERVED_1 = <span class="number">85 </span>, AIS_TYPE_TANKER_RESERVED_2 = <span class="number">86 </span>, AIS_TYPE_TANKER_RESERVED_3 = <span class="number">87 </span>, AIS_TYPE_TANKER_RESERVED_4 = <span class="number">88 </span>, AIS_TYPE_TANKER_UNKNOWN = <span class="number">89 </span>, AIS_TYPE_OTHER = <span class="number">90 </span>, AIS_TYPE_OTHER_HAZARDOUS_A = <span class="number">91 </span>, AIS_TYPE_OTHER_HAZARDOUS_B = <span class="number">92 </span>, AIS_TYPE_OTHER_HAZARDOUS_C = <span class="number">93 </span>, AIS_TYPE_OTHER_HAZARDOUS_D = <span class="number">94 </span>, AIS_TYPE_OTHER_RESERVED_1 = <span class="number">95 </span>, AIS_TYPE_OTHER_RESERVED_2 = <span class="number">96 </span>, AIS_TYPE_OTHER_RESERVED_3 = <span class="number">97 </span>, AIS_TYPE_OTHER_RESERVED_4 = <span class="number">98 </span>, AIS_TYPE_OTHER_UNKNOWN = <span class="number">99 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>AisType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: AIS_TYPE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FirmwareVersionType { FIRMWARE_VERSION_TYPE_DEV = <span class="number">0 </span>, FIRMWARE_VERSION_TYPE_ALPHA = <span class="number">64 </span>, FIRMWARE_VERSION_TYPE_BETA = <span class="number">128 </span>, FIRMWARE_VERSION_TYPE_RC = <span class="number">192 </span>, FIRMWARE_VERSION_TYPE_OFFICIAL = <span class="number">255 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>FirmwareVersionType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FIRMWARE_VERSION_TYPE_DEV } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AutotuneAxis { AUTOTUNE_AXIS_DEFAULT = <span class="number">0 </span>, AUTOTUNE_AXIS_ROLL = <span class="number">1 </span>, AUTOTUNE_AXIS_PITCH = <span class="number">2 </span>, AUTOTUNE_AXIS_YAW = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>AutotuneAxis { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: AUTOTUNE_AXIS_DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidTimeAcc { MAV_ODID_TIME_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_TIME_ACC_0_1_SECOND = <span class="number">1 </span>, MAV_ODID_TIME_ACC_0_2_SECOND = <span class="number">2 </span>, MAV_ODID_TIME_ACC_0_3_SECOND = <span class="number">3 </span>, MAV_ODID_TIME_ACC_0_4_SECOND = <span class="number">4 </span>, MAV_ODID_TIME_ACC_0_5_SECOND = <span class="number">5 </span>, MAV_ODID_TIME_ACC_0_6_SECOND = <span class="number">6 </span>, MAV_ODID_TIME_ACC_0_7_SECOND = <span class="number">7 </span>, MAV_ODID_TIME_ACC_0_8_SECOND = <span class="number">8 </span>, MAV_ODID_TIME_ACC_0_9_SECOND = <span class="number">9 </span>, MAV_ODID_TIME_ACC_1_0_SECOND = <span class="number">10 </span>, MAV_ODID_TIME_ACC_1_1_SECOND = <span class="number">11 </span>, MAV_ODID_TIME_ACC_1_2_SECOND = <span class="number">12 </span>, MAV_ODID_TIME_ACC_1_3_SECOND = <span class="number">13 </span>, MAV_ODID_TIME_ACC_1_4_SECOND = <span class="number">14 </span>, MAV_ODID_TIME_ACC_1_5_SECOND = <span class="number">15 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidTimeAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_TIME_ACC_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavArmAuthDeniedReason { MAV_ARM_AUTH_DENIED_REASON_GENERIC = <span class="number">0 </span>, MAV_ARM_AUTH_DENIED_REASON_NONE = <span class="number">1 </span>, MAV_ARM_AUTH_DENIED_REASON_INVALID_WAYPOINT = <span class="number">2 </span>, MAV_ARM_AUTH_DENIED_REASON_TIMEOUT = <span class="number">3 </span>, MAV_ARM_AUTH_DENIED_REASON_AIRSPACE_IN_USE = <span class="number">4 </span>, MAV_ARM_AUTH_DENIED_REASON_BAD_WEATHER = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavArmAuthDeniedReason { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ARM_AUTH_DENIED_REASON_GENERIC } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FenceAction { FENCE_ACTION_NONE = <span class="number">0 </span>, FENCE_ACTION_GUIDED = <span class="number">1 </span>, FENCE_ACTION_REPORT = <span class="number">2 </span>, FENCE_ACTION_GUIDED_THR_PASS = <span class="number">3 </span>, FENCE_ACTION_RTL = <span class="number">4 </span>, FENCE_ACTION_HOLD = <span class="number">5 </span>, FENCE_ACTION_TERMINATE = <span class="number">6 </span>, FENCE_ACTION_LAND = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>FenceAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FENCE_ACTION_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMode { MAV_MODE_PREFLIGHT = <span class="number">0 </span>, MAV_MODE_STABILIZE_DISARMED = <span class="number">80 </span>, MAV_MODE_STABILIZE_ARMED = <span class="number">208 </span>, MAV_MODE_MANUAL_DISARMED = <span class="number">64 </span>, MAV_MODE_MANUAL_ARMED = <span class="number">192 </span>, MAV_MODE_GUIDED_DISARMED = <span class="number">88 </span>, MAV_MODE_GUIDED_ARMED = <span class="number">216 </span>, MAV_MODE_AUTO_DISARMED = <span class="number">92 </span>, MAV_MODE_AUTO_ARMED = <span class="number">220 </span>, MAV_MODE_TEST_DISARMED = <span class="number">66 </span>, MAV_MODE_TEST_ARMED = <span class="number">194 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_MODE_PREFLIGHT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavFrame { MAV_FRAME_GLOBAL = <span class="number">0 </span>, MAV_FRAME_LOCAL_NED = <span class="number">1 </span>, MAV_FRAME_MISSION = <span class="number">2 </span>, MAV_FRAME_GLOBAL_RELATIVE_ALT = <span class="number">3 </span>, MAV_FRAME_LOCAL_ENU = <span class="number">4 </span>, MAV_FRAME_GLOBAL_INT = <span class="number">5 </span>, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = <span class="number">6 </span>, MAV_FRAME_LOCAL_OFFSET_NED = <span class="number">7 </span>, MAV_FRAME_BODY_NED = <span class="number">8 </span>, MAV_FRAME_BODY_OFFSET_NED = <span class="number">9 </span>, MAV_FRAME_GLOBAL_TERRAIN_ALT = <span class="number">10 </span>, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = <span class="number">11 </span>, MAV_FRAME_BODY_FRD = <span class="number">12 </span>, MAV_FRAME_RESERVED_13 = <span class="number">13 </span>, MAV_FRAME_RESERVED_14 = <span class="number">14 </span>, MAV_FRAME_RESERVED_15 = <span class="number">15 </span>, MAV_FRAME_RESERVED_16 = <span class="number">16 </span>, MAV_FRAME_RESERVED_17 = <span class="number">17 </span>, MAV_FRAME_RESERVED_18 = <span class="number">18 </span>, MAV_FRAME_RESERVED_19 = <span class="number">19 </span>, MAV_FRAME_LOCAL_FRD = <span class="number">20 </span>, MAV_FRAME_LOCAL_FLU = <span class="number">21 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavFrame { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_FRAME_GLOBAL } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FenceBreach { FENCE_BREACH_NONE = <span class="number">0 </span>, FENCE_BREACH_MINALT = <span class="number">1 </span>, FENCE_BREACH_MAXALT = <span class="number">2 </span>, FENCE_BREACH_BOUNDARY = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>FenceBreach { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FENCE_BREACH_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidStatus { MAV_ODID_STATUS_UNDECLARED = <span class="number">0 </span>, MAV_ODID_STATUS_GROUND = <span class="number">1 </span>, MAV_ODID_STATUS_AIRBORNE = <span class="number">2 </span>, MAV_ODID_STATUS_EMERGENCY = <span class="number">3 </span>, MAV_ODID_STATUS_REMOTE_ID_SYSTEM_FAILURE = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_STATUS_UNDECLARED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AdsbEmitterType { ADSB_EMITTER_TYPE_NO_INFO = <span class="number">0 </span>, ADSB_EMITTER_TYPE_LIGHT = <span class="number">1 </span>, ADSB_EMITTER_TYPE_SMALL = <span class="number">2 </span>, ADSB_EMITTER_TYPE_LARGE = <span class="number">3 </span>, ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = <span class="number">4 </span>, ADSB_EMITTER_TYPE_HEAVY = <span class="number">5 </span>, ADSB_EMITTER_TYPE_HIGHLY_MANUV = <span class="number">6 </span>, ADSB_EMITTER_TYPE_ROTOCRAFT = <span class="number">7 </span>, ADSB_EMITTER_TYPE_UNASSIGNED = <span class="number">8 </span>, ADSB_EMITTER_TYPE_GLIDER = <span class="number">9 </span>, ADSB_EMITTER_TYPE_LIGHTER_AIR = <span class="number">10 </span>, ADSB_EMITTER_TYPE_PARACHUTE = <span class="number">11 </span>, ADSB_EMITTER_TYPE_ULTRA_LIGHT = <span class="number">12 </span>, ADSB_EMITTER_TYPE_UNASSIGNED2 = <span class="number">13 </span>, ADSB_EMITTER_TYPE_UAV = <span class="number">14 </span>, ADSB_EMITTER_TYPE_SPACE = <span class="number">15 </span>, ADSB_EMITTER_TYPE_UNASSGINED3 = <span class="number">16 </span>, ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = <span class="number">17 </span>, ADSB_EMITTER_TYPE_SERVICE_SURFACE = <span class="number">18 </span>, ADSB_EMITTER_TYPE_POINT_OBSTACLE = <span class="number">19 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>AdsbEmitterType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ADSB_EMITTER_TYPE_NO_INFO } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>SetFocusType { FOCUS_TYPE_STEP = <span class="number">0 </span>, FOCUS_TYPE_CONTINUOUS = <span class="number">1 </span>, FOCUS_TYPE_RANGE = <span class="number">2 </span>, FOCUS_TYPE_METERS = <span class="number">3 </span>, FOCUS_TYPE_AUTO = <span class="number">4 </span>, FOCUS_TYPE_AUTO_SINGLE = <span class="number">5 </span>, FOCUS_TYPE_AUTO_CONTINUOUS = <span class="number">6 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>SetFocusType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FOCUS_TYPE_STEP } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidUaType { MAV_ODID_UA_TYPE_NONE = <span class="number">0 </span>, MAV_ODID_UA_TYPE_AEROPLANE = <span class="number">1 </span>, MAV_ODID_UA_TYPE_HELICOPTER_OR_MULTIROTOR = <span class="number">2 </span>, MAV_ODID_UA_TYPE_GYROPLANE = <span class="number">3 </span>, MAV_ODID_UA_TYPE_HYBRID_LIFT = <span class="number">4 </span>, MAV_ODID_UA_TYPE_ORNITHOPTER = <span class="number">5 </span>, MAV_ODID_UA_TYPE_GLIDER = <span class="number">6 </span>, MAV_ODID_UA_TYPE_KITE = <span class="number">7 </span>, MAV_ODID_UA_TYPE_FREE_BALLOON = <span class="number">8 </span>, MAV_ODID_UA_TYPE_CAPTIVE_BALLOON = <span class="number">9 </span>, MAV_ODID_UA_TYPE_AIRSHIP = <span class="number">10 </span>, MAV_ODID_UA_TYPE_FREE_FALL_PARACHUTE = <span class="number">11 </span>, MAV_ODID_UA_TYPE_ROCKET = <span class="number">12 </span>, MAV_ODID_UA_TYPE_TETHERED_POWERED_AIRCRAFT = <span class="number">13 </span>, MAV_ODID_UA_TYPE_GROUND_OBSTACLE = <span class="number">14 </span>, MAV_ODID_UA_TYPE_OTHER = <span class="number">15 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidUaType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_UA_TYPE_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavSensorOrientation { MAV_SENSOR_ROTATION_NONE = <span class="number">0 </span>, MAV_SENSOR_ROTATION_YAW_45 = <span class="number">1 </span>, MAV_SENSOR_ROTATION_YAW_90 = <span class="number">2 </span>, MAV_SENSOR_ROTATION_YAW_135 = <span class="number">3 </span>, MAV_SENSOR_ROTATION_YAW_180 = <span class="number">4 </span>, MAV_SENSOR_ROTATION_YAW_225 = <span class="number">5 </span>, MAV_SENSOR_ROTATION_YAW_270 = <span class="number">6 </span>, MAV_SENSOR_ROTATION_YAW_315 = <span class="number">7 </span>, MAV_SENSOR_ROTATION_ROLL_180 = <span class="number">8 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_45 = <span class="number">9 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_90 = <span class="number">10 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_135 = <span class="number">11 </span>, MAV_SENSOR_ROTATION_PITCH_180 = <span class="number">12 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_225 = <span class="number">13 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_270 = <span class="number">14 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_315 = <span class="number">15 </span>, MAV_SENSOR_ROTATION_ROLL_90 = <span class="number">16 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_45 = <span class="number">17 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_90 = <span class="number">18 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_135 = <span class="number">19 </span>, MAV_SENSOR_ROTATION_ROLL_270 = <span class="number">20 </span>, MAV_SENSOR_ROTATION_ROLL_270_YAW_45 = <span class="number">21 </span>, MAV_SENSOR_ROTATION_ROLL_270_YAW_90 = <span class="number">22 </span>, MAV_SENSOR_ROTATION_ROLL_270_YAW_135 = <span class="number">23 </span>, MAV_SENSOR_ROTATION_PITCH_90 = <span class="number">24 </span>, MAV_SENSOR_ROTATION_PITCH_270 = <span class="number">25 </span>, MAV_SENSOR_ROTATION_PITCH_180_YAW_90 = <span class="number">26 </span>, MAV_SENSOR_ROTATION_PITCH_180_YAW_270 = <span class="number">27 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_90 = <span class="number">28 </span>, MAV_SENSOR_ROTATION_ROLL_180_PITCH_90 = <span class="number">29 </span>, MAV_SENSOR_ROTATION_ROLL_270_PITCH_90 = <span class="number">30 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_180 = <span class="number">31 </span>, MAV_SENSOR_ROTATION_ROLL_270_PITCH_180 = <span class="number">32 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_270 = <span class="number">33 </span>, MAV_SENSOR_ROTATION_ROLL_180_PITCH_270 = <span class="number">34 </span>, MAV_SENSOR_ROTATION_ROLL_270_PITCH_270 = <span class="number">35 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_180_YAW_90 = <span class="number">36 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_270 = <span class="number">37 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_68_YAW_293 = <span class="number">38 </span>, MAV_SENSOR_ROTATION_PITCH_315 = <span class="number">39 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_315 = <span class="number">40 </span>, MAV_SENSOR_ROTATION_CUSTOM = <span class="number">100 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavSensorOrientation { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_SENSOR_ROTATION_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavDistanceSensor { MAV_DISTANCE_SENSOR_LASER = <span class="number">0 </span>, MAV_DISTANCE_SENSOR_ULTRASOUND = <span class="number">1 </span>, MAV_DISTANCE_SENSOR_INFRARED = <span class="number">2 </span>, MAV_DISTANCE_SENSOR_RADAR = <span class="number">3 </span>, MAV_DISTANCE_SENSOR_UNKNOWN = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavDistanceSensor { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_DISTANCE_SENSOR_LASER } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidDescType { MAV_ODID_DESC_TYPE_TEXT = <span class="number">0 </span>, MAV_ODID_DESC_TYPE_EMERGENCY = <span class="number">1 </span>, MAV_ODID_DESC_TYPE_EXTENDED_STATUS = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidDescType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_DESC_TYPE_TEXT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularNetworkFailedReason { CELLULAR_NETWORK_FAILED_REASON_NONE = <span class="number">0 </span>, CELLULAR_NETWORK_FAILED_REASON_UNKNOWN = <span class="number">1 </span>, CELLULAR_NETWORK_FAILED_REASON_SIM_MISSING = <span class="number">2 </span>, CELLULAR_NETWORK_FAILED_REASON_SIM_ERROR = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CellularNetworkFailedReason { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CELLULAR_NETWORK_FAILED_REASON_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavEventErrorReason { MAV_EVENT_ERROR_REASON_UNAVAILABLE = <span class="number">0 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavEventErrorReason { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_EVENT_ERROR_REASON_UNAVAILABLE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>StorageUsageFlag { STORAGE_USAGE_FLAG_SET = <span class="number">1 </span>, STORAGE_USAGE_FLAG_PHOTO = <span class="number">2 </span>, STORAGE_USAGE_FLAG_VIDEO = <span class="number">4 </span>, STORAGE_USAGE_FLAG_LOGS = <span class="number">8 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>StorageUsageFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: STORAGE_USAGE_FLAG_SET } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavGeneratorStatusFlag : u64 { <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OFF = <span class="number">1 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_READY = <span class="number">2 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_GENERATING = <span class="number">4 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_CHARGING = <span class="number">8 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_REDUCED_POWER = <span class="number">16 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_MAXPOWER = <span class="number">32 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERTEMP_WARNING = <span class="number">64 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERTEMP_FAULT = <span class="number">128 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_WARNING = <span class="number">256 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_FAULT = <span class="number">512 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_FAULT = <span class="number">1024 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_POWERSOURCE_FAULT = <span class="number">2048 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_COMMUNICATION_WARNING = <span class="number">4096 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_COOLING_WARNING = <span class="number">8192 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_POWER_RAIL_FAULT = <span class="number">16384 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERCURRENT_FAULT = <span class="number">32768 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_BATTERY_OVERCHARGE_CURRENT_FAULT = <span class="number">65536 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERVOLTAGE_FAULT = <span class="number">131072 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_BATTERY_UNDERVOLT_FAULT = <span class="number">262144 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_START_INHIBITED = <span class="number">524288 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_MAINTENANCE_REQUIRED = <span class="number">1048576 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_WARMING_UP = <span class="number">2097152 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_IDLE = <span class="number">4194304 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavGeneratorStatusFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_GENERATOR_STATUS_FLAG_OFF } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UtmFlightState { UTM_FLIGHT_STATE_UNKNOWN = <span class="number">1 </span>, UTM_FLIGHT_STATE_GROUND = <span class="number">2 </span>, UTM_FLIGHT_STATE_AIRBORNE = <span class="number">3 </span>, UTM_FLIGHT_STATE_EMERGENCY = <span class="number">16 </span>, UTM_FLIGHT_STATE_NOCTRL = <span class="number">32 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UtmFlightState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UTM_FLIGHT_STATE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCollisionSrc { MAV_COLLISION_SRC_ADSB = <span class="number">0 </span>, MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavCollisionSrc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_COLLISION_SRC_ADSB } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AisFlags : u16 { <span class="kw">const </span>AIS_FLAGS_POSITION_ACCURACY = <span class="number">1 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_COG = <span class="number">2 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_VELOCITY = <span class="number">4 </span>; <span class="kw">const </span>AIS_FLAGS_HIGH_VELOCITY = <span class="number">8 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_TURN_RATE = <span class="number">16 </span>; <span class="kw">const </span>AIS_FLAGS_TURN_RATE_SIGN_ONLY = <span class="number">32 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_DIMENSIONS = <span class="number">64 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_BOW_DIMENSION = <span class="number">128 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_STERN_DIMENSION = <span class="number">256 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_PORT_DIMENSION = <span class="number">512 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_STARBOARD_DIMENSION = <span class="number">1024 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_CALLSIGN = <span class="number">2048 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_NAME = <span class="number">4096 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>AisFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: AIS_FLAGS_POSITION_ACCURACY } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>WinchActions { WINCH_RELAXED = <span class="number">0 </span>, WINCH_RELATIVE_LENGTH_CONTROL = <span class="number">1 </span>, WINCH_RATE_CONTROL = <span class="number">2 </span>, WINCH_LOCK = <span class="number">3 </span>, WINCH_DELIVER = <span class="number">4 </span>, WINCH_HOLD = <span class="number">5 </span>, WINCH_RETRACT = <span class="number">6 </span>, WINCH_LOAD_LINE = <span class="number">7 </span>, WINCH_ABANDON_LINE = <span class="number">8 </span>, WINCH_LOAD_PAYLOAD = <span class="number">9 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>WinchActions { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: WINCH_RELAXED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>WifiConfigApResponse { WIFI_CONFIG_AP_RESPONSE_UNDEFINED = <span class="number">0 </span>, WIFI_CONFIG_AP_RESPONSE_ACCEPTED = <span class="number">1 </span>, WIFI_CONFIG_AP_RESPONSE_REJECTED = <span class="number">2 </span>, WIFI_CONFIG_AP_RESPONSE_MODE_ERROR = <span class="number">3 </span>, WIFI_CONFIG_AP_RESPONSE_SSID_ERROR = <span class="number">4 </span>, WIFI_CONFIG_AP_RESPONSE_PASSWORD_ERROR = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>WifiConfigApResponse { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: WIFI_CONFIG_AP_RESPONSE_UNDEFINED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutCfgGpsOffsetLon { UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutCfgGpsOffsetLon { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryMode { MAV_BATTERY_MODE_UNKNOWN = <span class="number">0 </span>, MAV_BATTERY_MODE_AUTO_DISCHARGING = <span class="number">1 </span>, MAV_BATTERY_MODE_HOT_SWAP = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_BATTERY_MODE_UNKNOWN } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavEventCurrentSequenceFlags : u8 { <span class="kw">const </span>MAV_EVENT_CURRENT_SEQUENCE_FLAGS_RESET = <span class="number">1 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavEventCurrentSequenceFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_EVENT_CURRENT_SEQUENCE_FLAGS_RESET } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HlFailureFlag : u16 { <span class="kw">const </span>HL_FAILURE_FLAG_GPS = <span class="number">1 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_DIFFERENTIAL_PRESSURE = <span class="number">2 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_ABSOLUTE_PRESSURE = <span class="number">4 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_3D_ACCEL = <span class="number">8 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_3D_GYRO = <span class="number">16 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_3D_MAG = <span class="number">32 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_TERRAIN = <span class="number">64 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_BATTERY = <span class="number">128 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_RC_RECEIVER = <span class="number">256 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_OFFBOARD_LINK = <span class="number">512 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_ENGINE = <span class="number">1024 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_GEOFENCE = <span class="number">2048 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_ESTIMATOR = <span class="number">4096 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_MISSION = <span class="number">8192 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>HlFailureFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: HL_FAILURE_FLAG_GPS } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCmdAck { MAV_CMD_ACK_OK = <span class="number">0 </span>, MAV_CMD_ACK_ERR_FAIL = <span class="number">1 </span>, MAV_CMD_ACK_ERR_ACCESS_DENIED = <span class="number">2 </span>, MAV_CMD_ACK_ERR_NOT_SUPPORTED = <span class="number">3 </span>, MAV_CMD_ACK_ERR_COORDINATE_FRAME_NOT_SUPPORTED = <span class="number">4 </span>, MAV_CMD_ACK_ERR_COORDINATES_OUT_OF_RANGE = <span class="number">5 </span>, MAV_CMD_ACK_ERR_X_LAT_OUT_OF_RANGE = <span class="number">6 </span>, MAV_CMD_ACK_ERR_Y_LON_OUT_OF_RANGE = <span class="number">7 </span>, MAV_CMD_ACK_ERR_Z_ALT_OUT_OF_RANGE = <span class="number">8 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavCmdAck { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_CMD_ACK_OK } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>RcType { RC_TYPE_SPEKTRUM_DSM2 = <span class="number">0 </span>, RC_TYPE_SPEKTRUM_DSMX = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>RcType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: RC_TYPE_SPEKTRUM_DSM2 } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidOperatorIdType { MAV_ODID_OPERATOR_ID_TYPE_CAA = <span class="number">0 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidOperatorIdType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_OPERATOR_ID_TYPE_CAA } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavParamType { MAV_PARAM_TYPE_UINT8 = <span class="number">1 </span>, MAV_PARAM_TYPE_INT8 = <span class="number">2 </span>, MAV_PARAM_TYPE_UINT16 = <span class="number">3 </span>, MAV_PARAM_TYPE_INT16 = <span class="number">4 </span>, MAV_PARAM_TYPE_UINT32 = <span class="number">5 </span>, MAV_PARAM_TYPE_INT32 = <span class="number">6 </span>, MAV_PARAM_TYPE_UINT64 = <span class="number">7 </span>, MAV_PARAM_TYPE_INT64 = <span class="number">8 </span>, MAV_PARAM_TYPE_REAL32 = <span class="number">9 </span>, MAV_PARAM_TYPE_REAL64 = <span class="number">10 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavParamType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_PARAM_TYPE_UINT8 } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutCfgGpsOffsetLat { UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_NO_DATA = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_2M = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_4M = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_6M = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_0M = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_2M = <span class="number">5 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_4M = <span class="number">6 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_6M = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutCfgGpsOffsetLat { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_NO_DATA } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>VideoStreamType { VIDEO_STREAM_TYPE_RTSP = <span class="number">0 </span>, VIDEO_STREAM_TYPE_RTPUDP = <span class="number">1 </span>, VIDEO_STREAM_TYPE_TCP_MPEG = <span class="number">2 </span>, VIDEO_STREAM_TYPE_MPEG_TS_H264 = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>VideoStreamType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: VIDEO_STREAM_TYPE_RTSP } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavPowerStatus : u16 { <span class="kw">const </span>MAV_POWER_STATUS_BRICK_VALID = <span class="number">1 </span>; <span class="kw">const </span>MAV_POWER_STATUS_SERVO_VALID = <span class="number">2 </span>; <span class="kw">const </span>MAV_POWER_STATUS_USB_CONNECTED = <span class="number">4 </span>; <span class="kw">const </span>MAV_POWER_STATUS_PERIPH_OVERCURRENT = <span class="number">8 </span>; <span class="kw">const </span>MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = <span class="number">16 </span>; <span class="kw">const </span>MAV_POWER_STATUS_CHANGED = <span class="number">32 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavPowerStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_POWER_STATUS_BRICK_VALID } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ActuatorConfiguration { ACTUATOR_CONFIGURATION_NONE = <span class="number">0 </span>, ACTUATOR_CONFIGURATION_BEEP = <span class="number">1 </span>, ACTUATOR_CONFIGURATION_3D_MODE_ON = <span class="number">2 </span>, ACTUATOR_CONFIGURATION_3D_MODE_OFF = <span class="number">3 </span>, ACTUATOR_CONFIGURATION_SPIN_DIRECTION1 = <span class="number">4 </span>, ACTUATOR_CONFIGURATION_SPIN_DIRECTION2 = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>ActuatorConfiguration { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ACTUATOR_CONFIGURATION_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavSysStatusSensorExtended { MAV_SYS_STATUS_RECOVERY_SYSTEM = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavSysStatusSensorExtended { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_SYS_STATUS_RECOVERY_SYSTEM } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavComponent { MAV_COMP_ID_ALL = <span class="number">0 </span>, MAV_COMP_ID_AUTOPILOT1 = <span class="number">1 </span>, MAV_COMP_ID_USER1 = <span class="number">25 </span>, MAV_COMP_ID_USER2 = <span class="number">26 </span>, MAV_COMP_ID_USER3 = <span class="number">27 </span>, MAV_COMP_ID_USER4 = <span class="number">28 </span>, MAV_COMP_ID_USER5 = <span class="number">29 </span>, MAV_COMP_ID_USER6 = <span class="number">30 </span>, MAV_COMP_ID_USER7 = <span class="number">31 </span>, MAV_COMP_ID_USER8 = <span class="number">32 </span>, MAV_COMP_ID_USER9 = <span class="number">33 </span>, MAV_COMP_ID_USER10 = <span class="number">34 </span>, MAV_COMP_ID_USER11 = <span class="number">35 </span>, MAV_COMP_ID_USER12 = <span class="number">36 </span>, MAV_COMP_ID_USER13 = <span class="number">37 </span>, MAV_COMP_ID_USER14 = <span class="number">38 </span>, MAV_COMP_ID_USER15 = <span class="number">39 </span>, MAV_COMP_ID_USER16 = <span class="number">40 </span>, MAV_COMP_ID_USER17 = <span class="number">41 </span>, MAV_COMP_ID_USER18 = <span class="number">42 </span>, MAV_COMP_ID_USER19 = <span class="number">43 </span>, MAV_COMP_ID_USER20 = <span class="number">44 </span>, MAV_COMP_ID_USER21 = <span class="number">45 </span>, MAV_COMP_ID_USER22 = <span class="number">46 </span>, MAV_COMP_ID_USER23 = <span class="number">47 </span>, MAV_COMP_ID_USER24 = <span class="number">48 </span>, MAV_COMP_ID_USER25 = <span class="number">49 </span>, MAV_COMP_ID_USER26 = <span class="number">50 </span>, MAV_COMP_ID_USER27 = <span class="number">51 </span>, MAV_COMP_ID_USER28 = <span class="number">52 </span>, MAV_COMP_ID_USER29 = <span class="number">53 </span>, MAV_COMP_ID_USER30 = <span class="number">54 </span>, MAV_COMP_ID_USER31 = <span class="number">55 </span>, MAV_COMP_ID_USER32 = <span class="number">56 </span>, MAV_COMP_ID_USER33 = <span class="number">57 </span>, MAV_COMP_ID_USER34 = <span class="number">58 </span>, MAV_COMP_ID_USER35 = <span class="number">59 </span>, MAV_COMP_ID_USER36 = <span class="number">60 </span>, MAV_COMP_ID_USER37 = <span class="number">61 </span>, MAV_COMP_ID_USER38 = <span class="number">62 </span>, MAV_COMP_ID_USER39 = <span class="number">63 </span>, MAV_COMP_ID_USER40 = <span class="number">64 </span>, MAV_COMP_ID_USER41 = <span class="number">65 </span>, MAV_COMP_ID_USER42 = <span class="number">66 </span>, MAV_COMP_ID_USER43 = <span class="number">67 </span>, MAV_COMP_ID_TELEMETRY_RADIO = <span class="number">68 </span>, MAV_COMP_ID_USER45 = <span class="number">69 </span>, MAV_COMP_ID_USER46 = <span class="number">70 </span>, MAV_COMP_ID_USER47 = <span class="number">71 </span>, MAV_COMP_ID_USER48 = <span class="number">72 </span>, MAV_COMP_ID_USER49 = <span class="number">73 </span>, MAV_COMP_ID_USER50 = <span class="number">74 </span>, MAV_COMP_ID_USER51 = <span class="number">75 </span>, MAV_COMP_ID_USER52 = <span class="number">76 </span>, MAV_COMP_ID_USER53 = <span class="number">77 </span>, MAV_COMP_ID_USER54 = <span class="number">78 </span>, MAV_COMP_ID_USER55 = <span class="number">79 </span>, MAV_COMP_ID_USER56 = <span class="number">80 </span>, MAV_COMP_ID_USER57 = <span class="number">81 </span>, MAV_COMP_ID_USER58 = <span class="number">82 </span>, MAV_COMP_ID_USER59 = <span class="number">83 </span>, MAV_COMP_ID_USER60 = <span class="number">84 </span>, MAV_COMP_ID_USER61 = <span class="number">85 </span>, MAV_COMP_ID_USER62 = <span class="number">86 </span>, MAV_COMP_ID_USER63 = <span class="number">87 </span>, MAV_COMP_ID_USER64 = <span class="number">88 </span>, MAV_COMP_ID_USER65 = <span class="number">89 </span>, MAV_COMP_ID_USER66 = <span class="number">90 </span>, MAV_COMP_ID_USER67 = <span class="number">91 </span>, MAV_COMP_ID_USER68 = <span class="number">92 </span>, MAV_COMP_ID_USER69 = <span class="number">93 </span>, MAV_COMP_ID_USER70 = <span class="number">94 </span>, MAV_COMP_ID_USER71 = <span class="number">95 </span>, MAV_COMP_ID_USER72 = <span class="number">96 </span>, MAV_COMP_ID_USER73 = <span class="number">97 </span>, MAV_COMP_ID_USER74 = <span class="number">98 </span>, MAV_COMP_ID_USER75 = <span class="number">99 </span>, MAV_COMP_ID_CAMERA = <span class="number">100 </span>, MAV_COMP_ID_CAMERA2 = <span class="number">101 </span>, MAV_COMP_ID_CAMERA3 = <span class="number">102 </span>, MAV_COMP_ID_CAMERA4 = <span class="number">103 </span>, MAV_COMP_ID_CAMERA5 = <span class="number">104 </span>, MAV_COMP_ID_CAMERA6 = <span class="number">105 </span>, MAV_COMP_ID_SERVO1 = <span class="number">140 </span>, MAV_COMP_ID_SERVO2 = <span class="number">141 </span>, MAV_COMP_ID_SERVO3 = <span class="number">142 </span>, MAV_COMP_ID_SERVO4 = <span class="number">143 </span>, MAV_COMP_ID_SERVO5 = <span class="number">144 </span>, MAV_COMP_ID_SERVO6 = <span class="number">145 </span>, MAV_COMP_ID_SERVO7 = <span class="number">146 </span>, MAV_COMP_ID_SERVO8 = <span class="number">147 </span>, MAV_COMP_ID_SERVO9 = <span class="number">148 </span>, MAV_COMP_ID_SERVO10 = <span class="number">149 </span>, MAV_COMP_ID_SERVO11 = <span class="number">150 </span>, MAV_COMP_ID_SERVO12 = <span class="number">151 </span>, MAV_COMP_ID_SERVO13 = <span class="number">152 </span>, MAV_COMP_ID_SERVO14 = <span class="number">153 </span>, MAV_COMP_ID_GIMBAL = <span class="number">154 </span>, MAV_COMP_ID_LOG = <span class="number">155 </span>, MAV_COMP_ID_ADSB = <span class="number">156 </span>, MAV_COMP_ID_OSD = <span class="number">157 </span>, MAV_COMP_ID_PERIPHERAL = <span class="number">158 </span>, MAV_COMP_ID_QX1_GIMBAL = <span class="number">159 </span>, MAV_COMP_ID_FLARM = <span class="number">160 </span>, MAV_COMP_ID_PARACHUTE = <span class="number">161 </span>, MAV_COMP_ID_WINCH = <span class="number">169 </span>, MAV_COMP_ID_GIMBAL2 = <span class="number">171 </span>, MAV_COMP_ID_GIMBAL3 = <span class="number">172 </span>, MAV_COMP_ID_GIMBAL4 = <span class="number">173 </span>, MAV_COMP_ID_GIMBAL5 = <span class="number">174 </span>, MAV_COMP_ID_GIMBAL6 = <span class="number">175 </span>, MAV_COMP_ID_BATTERY = <span class="number">180 </span>, MAV_COMP_ID_BATTERY2 = <span class="number">181 </span>, MAV_COMP_ID_MAVCAN = <span class="number">189 </span>, MAV_COMP_ID_MISSIONPLANNER = <span class="number">190 </span>, MAV_COMP_ID_ONBOARD_COMPUTER = <span class="number">191 </span>, MAV_COMP_ID_ONBOARD_COMPUTER2 = <span class="number">192 </span>, MAV_COMP_ID_ONBOARD_COMPUTER3 = <span class="number">193 </span>, MAV_COMP_ID_ONBOARD_COMPUTER4 = <span class="number">194 </span>, MAV_COMP_ID_PATHPLANNER = <span class="number">195 </span>, MAV_COMP_ID_OBSTACLE_AVOIDANCE = <span class="number">196 </span>, MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY = <span class="number">197 </span>, MAV_COMP_ID_PAIRING_MANAGER = <span class="number">198 </span>, MAV_COMP_ID_IMU = <span class="number">200 </span>, MAV_COMP_ID_IMU_2 = <span class="number">201 </span>, MAV_COMP_ID_IMU_3 = <span class="number">202 </span>, MAV_COMP_ID_GPS = <span class="number">220 </span>, MAV_COMP_ID_GPS2 = <span class="number">221 </span>, MAV_COMP_ID_ODID_TXRX_1 = <span class="number">236 </span>, MAV_COMP_ID_ODID_TXRX_2 = <span class="number">237 </span>, MAV_COMP_ID_ODID_TXRX_3 = <span class="number">238 </span>, MAV_COMP_ID_UDP_BRIDGE = <span class="number">240 </span>, MAV_COMP_ID_UART_BRIDGE = <span class="number">241 </span>, MAV_COMP_ID_TUNNEL_NODE = <span class="number">242 </span>, MAV_COMP_ID_SYSTEM_CONTROL = <span class="number">250 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavComponent { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_COMP_ID_ALL } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidAuthType { MAV_ODID_AUTH_TYPE_NONE = <span class="number">0 </span>, MAV_ODID_AUTH_TYPE_UAS_ID_SIGNATURE = <span class="number">1 </span>, MAV_ODID_AUTH_TYPE_OPERATOR_ID_SIGNATURE = <span class="number">2 </span>, MAV_ODID_AUTH_TYPE_MESSAGE_SET_SIGNATURE = <span class="number">3 </span>, MAV_ODID_AUTH_TYPE_NETWORK_REMOTE_ID = <span class="number">4 </span>, MAV_ODID_AUTH_TYPE_SPECIFIC_AUTHENTICATION = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidAuthType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_AUTH_TYPE_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavcanNodeMode { UAVCAN_NODE_MODE_OPERATIONAL = <span class="number">0 </span>, UAVCAN_NODE_MODE_INITIALIZATION = <span class="number">1 </span>, UAVCAN_NODE_MODE_MAINTENANCE = <span class="number">2 </span>, UAVCAN_NODE_MODE_SOFTWARE_UPDATE = <span class="number">3 </span>, UAVCAN_NODE_MODE_OFFLINE = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavcanNodeMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVCAN_NODE_MODE_OPERATIONAL } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PreflightStorageMissionAction { MISSION_READ_PERSISTENT = <span class="number">0 </span>, MISSION_WRITE_PERSISTENT = <span class="number">1 </span>, MISSION_RESET_DEFAULT = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>PreflightStorageMissionAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MISSION_READ_PERSISTENT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TuneFormat : u32 { <span class="kw">const </span>TUNE_FORMAT_QBASIC1_1 = <span class="number">1 </span>; <span class="kw">const </span>TUNE_FORMAT_MML_MODERN = <span class="number">2 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>TuneFormat { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: TUNE_FORMAT_QBASIC1_1 } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavDataStream { MAV_DATA_STREAM_ALL = <span class="number">0 </span>, MAV_DATA_STREAM_RAW_SENSORS = <span class="number">1 </span>, MAV_DATA_STREAM_EXTENDED_STATUS = <span class="number">2 </span>, MAV_DATA_STREAM_RC_CHANNELS = <span class="number">3 </span>, MAV_DATA_STREAM_RAW_CONTROLLER = <span class="number">4 </span>, MAV_DATA_STREAM_POSITION = <span class="number">6 </span>, MAV_DATA_STREAM_EXTRA1 = <span class="number">10 </span>, MAV_DATA_STREAM_EXTRA2 = <span class="number">11 </span>, MAV_DATA_STREAM_EXTRA3 = <span class="number">12 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavDataStream { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_DATA_STREAM_ALL } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FailureUnit { FAILURE_UNIT_SENSOR_GYRO = <span class="number">0 </span>, FAILURE_UNIT_SENSOR_ACCEL = <span class="number">1 </span>, FAILURE_UNIT_SENSOR_MAG = <span class="number">2 </span>, FAILURE_UNIT_SENSOR_BARO = <span class="number">3 </span>, FAILURE_UNIT_SENSOR_GPS = <span class="number">4 </span>, FAILURE_UNIT_SENSOR_OPTICAL_FLOW = <span class="number">5 </span>, FAILURE_UNIT_SENSOR_VIO = <span class="number">6 </span>, FAILURE_UNIT_SENSOR_DISTANCE_SENSOR = <span class="number">7 </span>, FAILURE_UNIT_SENSOR_AIRSPEED = <span class="number">8 </span>, FAILURE_UNIT_SYSTEM_BATTERY = <span class="number">100 </span>, FAILURE_UNIT_SYSTEM_MOTOR = <span class="number">101 </span>, FAILURE_UNIT_SYSTEM_SERVO = <span class="number">102 </span>, FAILURE_UNIT_SYSTEM_AVOIDANCE = <span class="number">103 </span>, FAILURE_UNIT_SYSTEM_RC_SIGNAL = <span class="number">104 </span>, FAILURE_UNIT_SYSTEM_MAVLINK_SIGNAL = <span class="number">105 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>FailureUnit { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FAILURE_UNIT_SENSOR_GYRO } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavModeFlag : u8 { <span class="kw">const </span>MAV_MODE_FLAG_SAFETY_ARMED = <span class="number">128 </span>; <span class="kw">const </span>MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = <span class="number">64 </span>; <span class="kw">const </span>MAV_MODE_FLAG_HIL_ENABLED = <span class="number">32 </span>; <span class="kw">const </span>MAV_MODE_FLAG_STABILIZE_ENABLED = <span class="number">16 </span>; <span class="kw">const </span>MAV_MODE_FLAG_GUIDED_ENABLED = <span class="number">8 </span>; <span class="kw">const </span>MAV_MODE_FLAG_AUTO_ENABLED = <span class="number">4 </span>; <span class="kw">const </span>MAV_MODE_FLAG_TEST_ENABLED = <span class="number">2 </span>; <span class="kw">const </span>MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = <span class="number">1 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavModeFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_MODE_FLAG_SAFETY_ARMED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCmd { MAV_CMD_NAV_WAYPOINT = <span class="number">16 </span>, MAV_CMD_NAV_LOITER_UNLIM = <span class="number">17 </span>, MAV_CMD_NAV_LOITER_TURNS = <span class="number">18 </span>, MAV_CMD_NAV_LOITER_TIME = <span class="number">19 </span>, MAV_CMD_NAV_RETURN_TO_LAUNCH = <span class="number">20 </span>, MAV_CMD_NAV_LAND = <span class="number">21 </span>, MAV_CMD_NAV_TAKEOFF = <span class="number">22 </span>, MAV_CMD_NAV_LAND_LOCAL = <span class="number">23 </span>, MAV_CMD_NAV_TAKEOFF_LOCAL = <span class="number">24 </span>, MAV_CMD_NAV_FOLLOW = <span class="number">25 </span>, MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT = <span class="number">30 </span>, MAV_CMD_NAV_LOITER_TO_ALT = <span class="number">31 </span>, MAV_CMD_DO_FOLLOW = <span class="number">32 </span>, MAV_CMD_DO_FOLLOW_REPOSITION = <span class="number">33 </span>, MAV_CMD_DO_ORBIT = <span class="number">34 </span>, MAV_CMD_NAV_ROI = <span class="number">80 </span>, MAV_CMD_NAV_PATHPLANNING = <span class="number">81 </span>, MAV_CMD_NAV_SPLINE_WAYPOINT = <span class="number">82 </span>, MAV_CMD_NAV_VTOL_TAKEOFF = <span class="number">84 </span>, MAV_CMD_NAV_VTOL_LAND = <span class="number">85 </span>, MAV_CMD_NAV_GUIDED_ENABLE = <span class="number">92 </span>, MAV_CMD_NAV_DELAY = <span class="number">93 </span>, MAV_CMD_NAV_PAYLOAD_PLACE = <span class="number">94 </span>, MAV_CMD_NAV_LAST = <span class="number">95 </span>, MAV_CMD_CONDITION_DELAY = <span class="number">112 </span>, MAV_CMD_CONDITION_CHANGE_ALT = <span class="number">113 </span>, MAV_CMD_CONDITION_DISTANCE = <span class="number">114 </span>, MAV_CMD_CONDITION_YAW = <span class="number">115 </span>, MAV_CMD_CONDITION_LAST = <span class="number">159 </span>, MAV_CMD_DO_SET_MODE = <span class="number">176 </span>, MAV_CMD_DO_JUMP = <span class="number">177 </span>, MAV_CMD_DO_CHANGE_SPEED = <span class="number">178 </span>, MAV_CMD_DO_SET_HOME = <span class="number">179 </span>, MAV_CMD_DO_SET_PARAMETER = <span class="number">180 </span>, MAV_CMD_DO_SET_RELAY = <span class="number">181 </span>, MAV_CMD_DO_REPEAT_RELAY = <span class="number">182 </span>, MAV_CMD_DO_SET_SERVO = <span class="number">183 </span>, MAV_CMD_DO_REPEAT_SERVO = <span class="number">184 </span>, MAV_CMD_DO_FLIGHTTERMINATION = <span class="number">185 </span>, MAV_CMD_DO_CHANGE_ALTITUDE = <span class="number">186 </span>, MAV_CMD_DO_SET_ACTUATOR = <span class="number">187 </span>, MAV_CMD_DO_LAND_START = <span class="number">189 </span>, MAV_CMD_DO_RALLY_LAND = <span class="number">190 </span>, MAV_CMD_DO_GO_AROUND = <span class="number">191 </span>, MAV_CMD_DO_REPOSITION = <span class="number">192 </span>, MAV_CMD_DO_PAUSE_CONTINUE = <span class="number">193 </span>, MAV_CMD_DO_SET_REVERSE = <span class="number">194 </span>, MAV_CMD_DO_SET_ROI_LOCATION = <span class="number">195 </span>, MAV_CMD_DO_SET_ROI_WPNEXT_OFFSET = <span class="number">196 </span>, MAV_CMD_DO_SET_ROI_NONE = <span class="number">197 </span>, MAV_CMD_DO_SET_ROI_SYSID = <span class="number">198 </span>, MAV_CMD_DO_CONTROL_VIDEO = <span class="number">200 </span>, MAV_CMD_DO_SET_ROI = <span class="number">201 </span>, MAV_CMD_DO_DIGICAM_CONFIGURE = <span class="number">202 </span>, MAV_CMD_DO_DIGICAM_CONTROL = <span class="number">203 </span>, MAV_CMD_DO_MOUNT_CONFIGURE = <span class="number">204 </span>, MAV_CMD_DO_MOUNT_CONTROL = <span class="number">205 </span>, MAV_CMD_DO_SET_CAM_TRIGG_DIST = <span class="number">206 </span>, MAV_CMD_DO_FENCE_ENABLE = <span class="number">207 </span>, MAV_CMD_DO_PARACHUTE = <span class="number">208 </span>, MAV_CMD_DO_MOTOR_TEST = <span class="number">209 </span>, MAV_CMD_DO_INVERTED_FLIGHT = <span class="number">210 </span>, MAV_CMD_DO_GRIPPER = <span class="number">211 </span>, MAV_CMD_DO_AUTOTUNE_ENABLE = <span class="number">212 </span>, MAV_CMD_NAV_SET_YAW_SPEED = <span class="number">213 </span>, MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = <span class="number">214 </span>, MAV_CMD_DO_MOUNT_CONTROL_QUAT = <span class="number">220 </span>, MAV_CMD_DO_GUIDED_MASTER = <span class="number">221 </span>, MAV_CMD_DO_GUIDED_LIMITS = <span class="number">222 </span>, MAV_CMD_DO_ENGINE_CONTROL = <span class="number">223 </span>, MAV_CMD_DO_SET_MISSION_CURRENT = <span class="number">224 </span>, MAV_CMD_DO_LAST = <span class="number">240 </span>, MAV_CMD_PREFLIGHT_CALIBRATION = <span class="number">241 </span>, MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS = <span class="number">242 </span>, MAV_CMD_PREFLIGHT_UAVCAN = <span class="number">243 </span>, MAV_CMD_PREFLIGHT_STORAGE = <span class="number">245 </span>, MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = <span class="number">246 </span>, MAV_CMD_OVERRIDE_GOTO = <span class="number">252 </span>, MAV_CMD_OBLIQUE_SURVEY = <span class="number">260 </span>, MAV_CMD_MISSION_START = <span class="number">300 </span>, MAV_CMD_ACTUATOR_TEST = <span class="number">310 </span>, MAV_CMD_CONFIGURE_ACTUATOR = <span class="number">311 </span>, MAV_CMD_COMPONENT_ARM_DISARM = <span class="number">400 </span>, MAV_CMD_RUN_PREARM_CHECKS = <span class="number">401 </span>, MAV_CMD_ILLUMINATOR_ON_OFF = <span class="number">405 </span>, MAV_CMD_GET_HOME_POSITION = <span class="number">410 </span>, MAV_CMD_INJECT_FAILURE = <span class="number">420 </span>, MAV_CMD_START_RX_PAIR = <span class="number">500 </span>, MAV_CMD_GET_MESSAGE_INTERVAL = <span class="number">510 </span>, MAV_CMD_SET_MESSAGE_INTERVAL = <span class="number">511 </span>, MAV_CMD_REQUEST_MESSAGE = <span class="number">512 </span>, MAV_CMD_REQUEST_PROTOCOL_VERSION = <span class="number">519 </span>, MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES = <span class="number">520 </span>, MAV_CMD_REQUEST_CAMERA_INFORMATION = <span class="number">521 </span>, MAV_CMD_REQUEST_CAMERA_SETTINGS = <span class="number">522 </span>, MAV_CMD_REQUEST_STORAGE_INFORMATION = <span class="number">525 </span>, MAV_CMD_STORAGE_FORMAT = <span class="number">526 </span>, MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS = <span class="number">527 </span>, MAV_CMD_REQUEST_FLIGHT_INFORMATION = <span class="number">528 </span>, MAV_CMD_RESET_CAMERA_SETTINGS = <span class="number">529 </span>, MAV_CMD_SET_CAMERA_MODE = <span class="number">530 </span>, MAV_CMD_SET_CAMERA_ZOOM = <span class="number">531 </span>, MAV_CMD_SET_CAMERA_FOCUS = <span class="number">532 </span>, MAV_CMD_SET_STORAGE_USAGE = <span class="number">533 </span>, MAV_CMD_JUMP_TAG = <span class="number">600 </span>, MAV_CMD_DO_JUMP_TAG = <span class="number">601 </span>, MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW = <span class="number">1000 </span>, MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE = <span class="number">1001 </span>, MAV_CMD_IMAGE_START_CAPTURE = <span class="number">2000 </span>, MAV_CMD_IMAGE_STOP_CAPTURE = <span class="number">2001 </span>, MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE = <span class="number">2002 </span>, MAV_CMD_DO_TRIGGER_CONTROL = <span class="number">2003 </span>, MAV_CMD_CAMERA_TRACK_POINT = <span class="number">2004 </span>, MAV_CMD_CAMERA_TRACK_RECTANGLE = <span class="number">2005 </span>, MAV_CMD_CAMERA_STOP_TRACKING = <span class="number">2010 </span>, MAV_CMD_VIDEO_START_CAPTURE = <span class="number">2500 </span>, MAV_CMD_VIDEO_STOP_CAPTURE = <span class="number">2501 </span>, MAV_CMD_VIDEO_START_STREAMING = <span class="number">2502 </span>, MAV_CMD_VIDEO_STOP_STREAMING = <span class="number">2503 </span>, MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION = <span class="number">2504 </span>, MAV_CMD_REQUEST_VIDEO_STREAM_STATUS = <span class="number">2505 </span>, MAV_CMD_LOGGING_START = <span class="number">2510 </span>, MAV_CMD_LOGGING_STOP = <span class="number">2511 </span>, MAV_CMD_AIRFRAME_CONFIGURATION = <span class="number">2520 </span>, MAV_CMD_CONTROL_HIGH_LATENCY = <span class="number">2600 </span>, MAV_CMD_PANORAMA_CREATE = <span class="number">2800 </span>, MAV_CMD_DO_VTOL_TRANSITION = <span class="number">3000 </span>, MAV_CMD_ARM_AUTHORIZATION_REQUEST = <span class="number">3001 </span>, MAV_CMD_SET_GUIDED_SUBMODE_STANDARD = <span class="number">4000 </span>, MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE = <span class="number">4001 </span>, MAV_CMD_CONDITION_GATE = <span class="number">4501 </span>, MAV_CMD_NAV_FENCE_RETURN_POINT = <span class="number">5000 </span>, MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = <span class="number">5001 </span>, MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = <span class="number">5002 </span>, MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION = <span class="number">5003 </span>, MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION = <span class="number">5004 </span>, MAV_CMD_NAV_RALLY_POINT = <span class="number">5100 </span>, MAV_CMD_UAVCAN_GET_NODE_INFO = <span class="number">5200 </span>, MAV_CMD_DO_ADSB_OUT_IDENT = <span class="number">10001 </span>, MAV_CMD_PAYLOAD_PREPARE_DEPLOY = <span class="number">30001 </span>, MAV_CMD_PAYLOAD_CONTROL_DEPLOY = <span class="number">30002 </span>, MAV_CMD_FIXED_MAG_CAL_YAW = <span class="number">42006 </span>, MAV_CMD_DO_WINCH = <span class="number">42600 </span>, MAV_CMD_WAYPOINT_USER_1 = <span class="number">31000 </span>, MAV_CMD_WAYPOINT_USER_2 = <span class="number">31001 </span>, MAV_CMD_WAYPOINT_USER_3 = <span class="number">31002 </span>, MAV_CMD_WAYPOINT_USER_4 = <span class="number">31003 </span>, MAV_CMD_WAYPOINT_USER_5 = <span class="number">31004 </span>, MAV_CMD_SPATIAL_USER_1 = <span class="number">31005 </span>, MAV_CMD_SPATIAL_USER_2 = <span class="number">31006 </span>, MAV_CMD_SPATIAL_USER_3 = <span class="number">31007 </span>, MAV_CMD_SPATIAL_USER_4 = <span class="number">31008 </span>, MAV_CMD_SPATIAL_USER_5 = <span class="number">31009 </span>, MAV_CMD_USER_1 = <span class="number">31010 </span>, MAV_CMD_USER_2 = <span class="number">31011 </span>, MAV_CMD_USER_3 = <span class="number">31012 </span>, MAV_CMD_USER_4 = <span class="number">31013 </span>, MAV_CMD_USER_5 = <span class="number">31014 </span>, MAV_CMD_CAN_FORWARD = <span class="number">32000 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavCmd { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_CMD_NAV_WAYPOINT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UavionixAdsbOutRfSelect : u8 { <span class="kw">const </span>UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY = <span class="number">0 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED = <span class="number">1 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED = <span class="number">2 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutRfSelect { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidIdType { MAV_ODID_ID_TYPE_NONE = <span class="number">0 </span>, MAV_ODID_ID_TYPE_SERIAL_NUMBER = <span class="number">1 </span>, MAV_ODID_ID_TYPE_CAA_REGISTRATION_ID = <span class="number">2 </span>, MAV_ODID_ID_TYPE_UTM_ASSIGNED_UUID = <span class="number">3 </span>, MAV_ODID_ID_TYPE_SPECIFIC_SESSION_ID = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidIdType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_ID_TYPE_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>VtolTransitionHeading { VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT = <span class="number">0 </span>, VTOL_TRANSITION_HEADING_NEXT_WAYPOINT = <span class="number">1 </span>, VTOL_TRANSITION_HEADING_TAKEOFF = <span class="number">2 </span>, VTOL_TRANSITION_HEADING_SPECIFIED = <span class="number">3 </span>, VTOL_TRANSITION_HEADING_ANY = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>VtolTransitionHeading { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ParachuteAction { PARACHUTE_DISABLE = <span class="number">0 </span>, PARACHUTE_ENABLE = <span class="number">1 </span>, PARACHUTE_RELEASE = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>ParachuteAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: PARACHUTE_DISABLE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryFunction { MAV_BATTERY_FUNCTION_UNKNOWN = <span class="number">0 </span>, MAV_BATTERY_FUNCTION_ALL = <span class="number">1 </span>, MAV_BATTERY_FUNCTION_PROPULSION = <span class="number">2 </span>, MAV_BATTERY_FUNCTION_AVIONICS = <span class="number">3 </span>, MAV_BATTERY_FUNCTION_PAYLOAD = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryFunction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_BATTERY_FUNCTION_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraTrackingStatusFlags { CAMERA_TRACKING_STATUS_FLAGS_IDLE = <span class="number">0 </span>, CAMERA_TRACKING_STATUS_FLAGS_ACTIVE = <span class="number">1 </span>, CAMERA_TRACKING_STATUS_FLAGS_ERROR = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CameraTrackingStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CAMERA_TRACKING_STATUS_FLAGS_IDLE } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalDeviceCapFlags : u16 { <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW = <span class="number">512 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK = <span class="number">1024 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW = <span class="number">2048 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME = <span class="number">4096 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_RC_INPUTS = <span class="number">8192 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalDeviceCapFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SerialControlFlag : u8 { <span class="kw">const </span>SERIAL_CONTROL_FLAG_REPLY = <span class="number">1 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_RESPOND = <span class="number">2 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_EXCLUSIVE = <span class="number">4 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_BLOCKING = <span class="number">8 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_MULTI = <span class="number">16 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>SerialControlFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: SERIAL_CONTROL_FLAG_REPLY } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavWinchStatusFlag : u32 { <span class="kw">const </span>MAV_WINCH_STATUS_HEALTHY = <span class="number">1 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_FULLY_RETRACTED = <span class="number">2 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_MOVING = <span class="number">4 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_CLUTCH_ENGAGED = <span class="number">8 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOCKED = <span class="number">16 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_DROPPING = <span class="number">32 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_ARRESTING = <span class="number">64 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_GROUND_SENSE = <span class="number">128 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_RETRACTING = <span class="number">256 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_REDELIVER = <span class="number">512 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_ABANDON_LINE = <span class="number">1024 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOCKING = <span class="number">2048 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOAD_LINE = <span class="number">4096 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOAD_PAYLOAD = <span class="number">8192 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavWinchStatusFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_WINCH_STATUS_HEALTHY } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CameraCapFlags : u32 { <span class="kw">const </span>CAMERA_CAP_FLAGS_CAPTURE_VIDEO = <span class="number">1 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_CAPTURE_IMAGE = <span class="number">2 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_MODES = <span class="number">4 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = <span class="number">8 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = <span class="number">16 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE = <span class="number">32 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_BASIC_ZOOM = <span class="number">64 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS = <span class="number">128 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_VIDEO_STREAM = <span class="number">256 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_TRACKING_POINT = <span class="number">512 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE = <span class="number">1024 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_TRACKING_GEO_STATUS = <span class="number">2048 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>CameraCapFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CAMERA_CAP_FLAGS_CAPTURE_VIDEO } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>LandingTargetType { LANDING_TARGET_TYPE_LIGHT_BEACON = <span class="number">0 </span>, LANDING_TARGET_TYPE_RADIO_BEACON = <span class="number">1 </span>, LANDING_TARGET_TYPE_VISION_FIDUCIAL = <span class="number">2 </span>, LANDING_TARGET_TYPE_VISION_OTHER = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>LandingTargetType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: LANDING_TARGET_TYPE_LIGHT_BEACON } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryChargeState { MAV_BATTERY_CHARGE_STATE_UNDEFINED = <span class="number">0 </span>, MAV_BATTERY_CHARGE_STATE_OK = <span class="number">1 </span>, MAV_BATTERY_CHARGE_STATE_LOW = <span class="number">2 </span>, MAV_BATTERY_CHARGE_STATE_CRITICAL = <span class="number">3 </span>, MAV_BATTERY_CHARGE_STATE_EMERGENCY = <span class="number">4 </span>, MAV_BATTERY_CHARGE_STATE_FAILED = <span class="number">5 </span>, MAV_BATTERY_CHARGE_STATE_UNHEALTHY = <span class="number">6 </span>, MAV_BATTERY_CHARGE_STATE_CHARGING = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryChargeState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_BATTERY_CHARGE_STATE_UNDEFINED } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EscFailureFlags : u16 { <span class="kw">const </span>ESC_FAILURE_NONE = <span class="number">0 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_CURRENT = <span class="number">1 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_VOLTAGE = <span class="number">2 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_TEMPERATURE = <span class="number">4 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_RPM = <span class="number">8 </span>; <span class="kw">const </span>ESC_FAILURE_INCONSISTENT_CMD = <span class="number">16 </span>; <span class="kw">const </span>ESC_FAILURE_MOTOR_STUCK = <span class="number">32 </span>; <span class="kw">const </span>ESC_FAILURE_GENERIC = <span class="number">64 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>EscFailureFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ESC_FAILURE_NONE } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UtmDataAvailFlags : u8 { <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_TIME_VALID = <span class="number">1 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_UAS_ID_AVAILABLE = <span class="number">2 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_POSITION_AVAILABLE = <span class="number">4 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_ALTITUDE_AVAILABLE = <span class="number">8 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_RELATIVE_ALTITUDE_AVAILABLE = <span class="number">16 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_HORIZONTAL_VELO_AVAILABLE = <span class="number">32 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_VERTICAL_VELO_AVAILABLE = <span class="number">64 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_NEXT_WAYPOINT_AVAILABLE = <span class="number">128 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>UtmDataAvailFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UTM_DATA_AVAIL_FLAGS_TIME_VALID } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutDynamicGpsFix { UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutDynamicGpsFix { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavSysStatusSensor : u32 { <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_GYRO = <span class="number">1 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_ACCEL = <span class="number">2 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_MAG = <span class="number">4 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE = <span class="number">8 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE = <span class="number">16 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_GPS = <span class="number">32 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW = <span class="number">64 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_VISION_POSITION = <span class="number">128 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_LASER_POSITION = <span class="number">256 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH = <span class="number">512 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL = <span class="number">1024 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = <span class="number">2048 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_YAW_POSITION = <span class="number">4096 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL = <span class="number">8192 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL = <span class="number">16384 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS = <span class="number">32768 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_RC_RECEIVER = <span class="number">65536 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_GYRO2 = <span class="number">131072 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_ACCEL2 = <span class="number">262144 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_MAG2 = <span class="number">524288 </span>; <span class="kw">const </span>MAV_SYS_STATUS_GEOFENCE = <span class="number">1048576 </span>; <span class="kw">const </span>MAV_SYS_STATUS_AHRS = <span class="number">2097152 </span>; <span class="kw">const </span>MAV_SYS_STATUS_TERRAIN = <span class="number">4194304 </span>; <span class="kw">const </span>MAV_SYS_STATUS_REVERSE_MOTOR = <span class="number">8388608 </span>; <span class="kw">const </span>MAV_SYS_STATUS_LOGGING = <span class="number">16777216 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_BATTERY = <span class="number">33554432 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_PROXIMITY = <span class="number">67108864 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_SATCOM = <span class="number">134217728 </span>; <span class="kw">const </span>MAV_SYS_STATUS_PREARM_CHECK = <span class="number">268435456 </span>; <span class="kw">const </span>MAV_SYS_STATUS_OBSTACLE_AVOIDANCE = <span class="number">536870912 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_PROPULSION = <span class="number">1073741824 </span>; <span class="kw">const </span>MAV_SYS_STATUS_EXTENSION_USED = <span class="number">2147483648 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>MavSysStatusSensor { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_SYS_STATUS_SENSOR_3D_GYRO } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidArmStatus { MAV_ODID_ARM_STATUS_GOOD_TO_ARM = <span class="number">0 </span>, MAV_ODID_ARM_STATUS_PRE_ARM_FAIL_GENERIC = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidArmStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_ARM_STATUS_GOOD_TO_ARM } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FailureType { FAILURE_TYPE_OK = <span class="number">0 </span>, FAILURE_TYPE_OFF = <span class="number">1 </span>, FAILURE_TYPE_STUCK = <span class="number">2 </span>, FAILURE_TYPE_GARBAGE = <span class="number">3 </span>, FAILURE_TYPE_WRONG = <span class="number">4 </span>, FAILURE_TYPE_SLOW = <span class="number">5 </span>, FAILURE_TYPE_DELAYED = <span class="number">6 </span>, FAILURE_TYPE_INTERMITTENT = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>FailureType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: FAILURE_TYPE_OK } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularNetworkRadioType { CELLULAR_NETWORK_RADIO_TYPE_NONE = <span class="number">0 </span>, CELLULAR_NETWORK_RADIO_TYPE_GSM = <span class="number">1 </span>, CELLULAR_NETWORK_RADIO_TYPE_CDMA = <span class="number">2 </span>, CELLULAR_NETWORK_RADIO_TYPE_WCDMA = <span class="number">3 </span>, CELLULAR_NETWORK_RADIO_TYPE_LTE = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CellularNetworkRadioType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CELLULAR_NETWORK_RADIO_TYPE_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryFault { MAV_BATTERY_FAULT_DEEP_DISCHARGE = <span class="number">1 </span>, MAV_BATTERY_FAULT_SPIKES = <span class="number">2 </span>, MAV_BATTERY_FAULT_CELL_FAIL = <span class="number">4 </span>, MAV_BATTERY_FAULT_OVER_CURRENT = <span class="number">8 </span>, MAV_BATTERY_FAULT_OVER_TEMPERATURE = <span class="number">16 </span>, MAV_BATTERY_FAULT_UNDER_TEMPERATURE = <span class="number">32 </span>, MAV_BATTERY_FAULT_INCOMPATIBLE_VOLTAGE = <span class="number">64 </span>, MAV_BATTERY_FAULT_INCOMPATIBLE_FIRMWARE = <span class="number">128 </span>, BATTERY_FAULT_INCOMPATIBLE_CELLS_CONFIGURATION = <span class="number">256 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryFault { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_BATTERY_FAULT_DEEP_DISCHARGE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavSeverity { MAV_SEVERITY_EMERGENCY = <span class="number">0 </span>, MAV_SEVERITY_ALERT = <span class="number">1 </span>, MAV_SEVERITY_CRITICAL = <span class="number">2 </span>, MAV_SEVERITY_ERROR = <span class="number">3 </span>, MAV_SEVERITY_WARNING = <span class="number">4 </span>, MAV_SEVERITY_NOTICE = <span class="number">5 </span>, MAV_SEVERITY_INFO = <span class="number">6 </span>, MAV_SEVERITY_DEBUG = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavSeverity { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_SEVERITY_EMERGENCY } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryType { MAV_BATTERY_TYPE_UNKNOWN = <span class="number">0 </span>, MAV_BATTERY_TYPE_LIPO = <span class="number">1 </span>, MAV_BATTERY_TYPE_LIFE = <span class="number">2 </span>, MAV_BATTERY_TYPE_LION = <span class="number">3 </span>, MAV_BATTERY_TYPE_NIMH = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_BATTERY_TYPE_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>OrbitYawBehaviour { ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER = <span class="number">0 </span>, ORBIT_YAW_BEHAVIOUR_HOLD_INITIAL_HEADING = <span class="number">1 </span>, ORBIT_YAW_BEHAVIOUR_UNCONTROLLED = <span class="number">2 </span>, ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TANGENT_TO_CIRCLE = <span class="number">3 </span>, ORBIT_YAW_BEHAVIOUR_RC_CONTROLLED = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>OrbitYawBehaviour { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCollisionAction { MAV_COLLISION_ACTION_NONE = <span class="number">0 </span>, MAV_COLLISION_ACTION_REPORT = <span class="number">1 </span>, MAV_COLLISION_ACTION_ASCEND_OR_DESCEND = <span class="number">2 </span>, MAV_COLLISION_ACTION_MOVE_HORIZONTALLY = <span class="number">3 </span>, MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = <span class="number">4 </span>, MAV_COLLISION_ACTION_RTL = <span class="number">5 </span>, MAV_COLLISION_ACTION_HOVER = <span class="number">6 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavCollisionAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_COLLISION_ACTION_NONE } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GpsInputIgnoreFlags : u16 { <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_ALT = <span class="number">1 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_HDOP = <span class="number">2 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VDOP = <span class="number">4 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VEL_HORIZ = <span class="number">8 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VEL_VERT = <span class="number">16 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY = <span class="number">32 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = <span class="number">64 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY = <span class="number">128 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>GpsInputIgnoreFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GPS_INPUT_IGNORE_FLAG_ALT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavType { MAV_TYPE_GENERIC = <span class="number">0 </span>, MAV_TYPE_FIXED_WING = <span class="number">1 </span>, MAV_TYPE_QUADROTOR = <span class="number">2 </span>, MAV_TYPE_COAXIAL = <span class="number">3 </span>, MAV_TYPE_HELICOPTER = <span class="number">4 </span>, MAV_TYPE_ANTENNA_TRACKER = <span class="number">5 </span>, MAV_TYPE_GCS = <span class="number">6 </span>, MAV_TYPE_AIRSHIP = <span class="number">7 </span>, MAV_TYPE_FREE_BALLOON = <span class="number">8 </span>, MAV_TYPE_ROCKET = <span class="number">9 </span>, MAV_TYPE_GROUND_ROVER = <span class="number">10 </span>, MAV_TYPE_SURFACE_BOAT = <span class="number">11 </span>, MAV_TYPE_SUBMARINE = <span class="number">12 </span>, MAV_TYPE_HEXAROTOR = <span class="number">13 </span>, MAV_TYPE_OCTOROTOR = <span class="number">14 </span>, MAV_TYPE_TRICOPTER = <span class="number">15 </span>, MAV_TYPE_FLAPPING_WING = <span class="number">16 </span>, MAV_TYPE_KITE = <span class="number">17 </span>, MAV_TYPE_ONBOARD_CONTROLLER = <span class="number">18 </span>, MAV_TYPE_VTOL_TAILSITTER_DUOROTOR = <span class="number">19 </span>, MAV_TYPE_VTOL_TAILSITTER_QUADROTOR = <span class="number">20 </span>, MAV_TYPE_VTOL_TILTROTOR = <span class="number">21 </span>, MAV_TYPE_VTOL_FIXEDROTOR = <span class="number">22 </span>, MAV_TYPE_VTOL_TAILSITTER = <span class="number">23 </span>, MAV_TYPE_VTOL_TILTWING = <span class="number">24 </span>, MAV_TYPE_VTOL_RESERVED5 = <span class="number">25 </span>, MAV_TYPE_GIMBAL = <span class="number">26 </span>, MAV_TYPE_ADSB = <span class="number">27 </span>, MAV_TYPE_PARAFOIL = <span class="number">28 </span>, MAV_TYPE_DODECAROTOR = <span class="number">29 </span>, MAV_TYPE_CAMERA = <span class="number">30 </span>, MAV_TYPE_CHARGING_STATION = <span class="number">31 </span>, MAV_TYPE_FLARM = <span class="number">32 </span>, MAV_TYPE_SERVO = <span class="number">33 </span>, MAV_TYPE_ODID = <span class="number">34 </span>, MAV_TYPE_DECAROTOR = <span class="number">35 </span>, MAV_TYPE_BATTERY = <span class="number">36 </span>, MAV_TYPE_PARACHUTE = <span class="number">37 </span>, MAV_TYPE_LOG = <span class="number">38 </span>, MAV_TYPE_OSD = <span class="number">39 </span>, MAV_TYPE_IMU = <span class="number">40 </span>, MAV_TYPE_GPS = <span class="number">41 </span>, MAV_TYPE_WINCH = <span class="number">42 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_TYPE_GENERIC } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavLandedState { MAV_LANDED_STATE_UNDEFINED = <span class="number">0 </span>, MAV_LANDED_STATE_ON_GROUND = <span class="number">1 </span>, MAV_LANDED_STATE_IN_AIR = <span class="number">2 </span>, MAV_LANDED_STATE_TAKEOFF = <span class="number">3 </span>, MAV_LANDED_STATE_LANDING = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavLandedState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_LANDED_STATE_UNDEFINED } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UavionixAdsbRfHealth : u8 { <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_INITIALIZING = <span class="number">0 </span>; <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_OK = <span class="number">1 </span>; <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_FAIL_TX = <span class="number">2 </span>; <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_FAIL_RX = <span class="number">16 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbRfHealth { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_RF_HEALTH_INITIALIZING } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CanFilterOp { CAN_FILTER_REPLACE = <span class="number">0 </span>, CAN_FILTER_ADD = <span class="number">1 </span>, CAN_FILTER_REMOVE = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CanFilterOp { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CAN_FILTER_REPLACE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PreflightStorageParameterAction { PARAM_READ_PERSISTENT = <span class="number">0 </span>, PARAM_WRITE_PERSISTENT = <span class="number">1 </span>, PARAM_RESET_CONFIG_DEFAULT = <span class="number">2 </span>, PARAM_RESET_SENSOR_DEFAULT = <span class="number">3 </span>, PARAM_RESET_ALL_DEFAULT = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>PreflightStorageParameterAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: PARAM_READ_PERSISTENT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ActuatorOutputFunction { ACTUATOR_OUTPUT_FUNCTION_NONE = <span class="number">0 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR1 = <span class="number">1 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR2 = <span class="number">2 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR3 = <span class="number">3 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR4 = <span class="number">4 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR5 = <span class="number">5 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR6 = <span class="number">6 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR7 = <span class="number">7 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR8 = <span class="number">8 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR9 = <span class="number">9 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR10 = <span class="number">10 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR11 = <span class="number">11 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR12 = <span class="number">12 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR13 = <span class="number">13 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR14 = <span class="number">14 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR15 = <span class="number">15 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR16 = <span class="number">16 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO1 = <span class="number">33 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO2 = <span class="number">34 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO3 = <span class="number">35 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO4 = <span class="number">36 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO5 = <span class="number">37 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO6 = <span class="number">38 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO7 = <span class="number">39 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO8 = <span class="number">40 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO9 = <span class="number">41 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO10 = <span class="number">42 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO11 = <span class="number">43 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO12 = <span class="number">44 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO13 = <span class="number">45 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO14 = <span class="number">46 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO15 = <span class="number">47 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO16 = <span class="number">48 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>ActuatorOutputFunction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ACTUATOR_OUTPUT_FUNCTION_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularStatusFlag { CELLULAR_STATUS_FLAG_UNKNOWN = <span class="number">0 </span>, CELLULAR_STATUS_FLAG_FAILED = <span class="number">1 </span>, CELLULAR_STATUS_FLAG_INITIALIZING = <span class="number">2 </span>, CELLULAR_STATUS_FLAG_LOCKED = <span class="number">3 </span>, CELLULAR_STATUS_FLAG_DISABLED = <span class="number">4 </span>, CELLULAR_STATUS_FLAG_DISABLING = <span class="number">5 </span>, CELLULAR_STATUS_FLAG_ENABLING = <span class="number">6 </span>, CELLULAR_STATUS_FLAG_ENABLED = <span class="number">7 </span>, CELLULAR_STATUS_FLAG_SEARCHING = <span class="number">8 </span>, CELLULAR_STATUS_FLAG_REGISTERED = <span class="number">9 </span>, CELLULAR_STATUS_FLAG_DISCONNECTING = <span class="number">10 </span>, CELLULAR_STATUS_FLAG_CONNECTING = <span class="number">11 </span>, CELLULAR_STATUS_FLAG_CONNECTED = <span class="number">12 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CellularStatusFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CELLULAR_STATUS_FLAG_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraZoomType { ZOOM_TYPE_STEP = <span class="number">0 </span>, ZOOM_TYPE_CONTINUOUS = <span class="number">1 </span>, ZOOM_TYPE_RANGE = <span class="number">2 </span>, ZOOM_TYPE_FOCAL_LENGTH = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CameraZoomType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ZOOM_TYPE_STEP } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCollisionThreatLevel { MAV_COLLISION_THREAT_LEVEL_NONE = <span class="number">0 </span>, MAV_COLLISION_THREAT_LEVEL_LOW = <span class="number">1 </span>, MAV_COLLISION_THREAT_LEVEL_HIGH = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavCollisionThreatLevel { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_COLLISION_THREAT_LEVEL_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraMode { CAMERA_MODE_IMAGE = <span class="number">0 </span>, CAMERA_MODE_VIDEO = <span class="number">1 </span>, CAMERA_MODE_IMAGE_SURVEY = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CameraMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CAMERA_MODE_IMAGE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidHorAcc { MAV_ODID_HOR_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_HOR_ACC_10NM = <span class="number">1 </span>, MAV_ODID_HOR_ACC_4NM = <span class="number">2 </span>, MAV_ODID_HOR_ACC_2NM = <span class="number">3 </span>, MAV_ODID_HOR_ACC_1NM = <span class="number">4 </span>, MAV_ODID_HOR_ACC_0_5NM = <span class="number">5 </span>, MAV_ODID_HOR_ACC_0_3NM = <span class="number">6 </span>, MAV_ODID_HOR_ACC_0_1NM = <span class="number">7 </span>, MAV_ODID_HOR_ACC_0_05NM = <span class="number">8 </span>, MAV_ODID_HOR_ACC_30_METER = <span class="number">9 </span>, MAV_ODID_HOR_ACC_10_METER = <span class="number">10 </span>, MAV_ODID_HOR_ACC_3_METER = <span class="number">11 </span>, MAV_ODID_HOR_ACC_1_METER = <span class="number">12 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidHorAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_HOR_ACC_UNKNOWN } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavResult { MAV_RESULT_ACCEPTED = <span class="number">0 </span>, MAV_RESULT_TEMPORARILY_REJECTED = <span class="number">1 </span>, MAV_RESULT_DENIED = <span class="number">2 </span>, MAV_RESULT_UNSUPPORTED = <span class="number">3 </span>, MAV_RESULT_FAILED = <span class="number">4 </span>, MAV_RESULT_IN_PROGRESS = <span class="number">5 </span>, MAV_RESULT_CANCELLED = <span class="number">6 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavResult { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_RESULT_ACCEPTED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ParamAck { PARAM_ACK_ACCEPTED = <span class="number">0 </span>, PARAM_ACK_VALUE_UNSUPPORTED = <span class="number">1 </span>, PARAM_ACK_FAILED = <span class="number">2 </span>, PARAM_ACK_IN_PROGRESS = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>ParamAck { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: PARAM_ACK_ACCEPTED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavFtpErr { MAV_FTP_ERR_NONE = <span class="number">0 </span>, MAV_FTP_ERR_FAIL = <span class="number">1 </span>, MAV_FTP_ERR_FAILERRNO = <span class="number">2 </span>, MAV_FTP_ERR_INVALIDDATASIZE = <span class="number">3 </span>, MAV_FTP_ERR_INVALIDSESSION = <span class="number">4 </span>, MAV_FTP_ERR_NOSESSIONSAVAILABLE = <span class="number">5 </span>, MAV_FTP_ERR_EOF = <span class="number">6 </span>, MAV_FTP_ERR_UNKNOWNCOMMAND = <span class="number">7 </span>, MAV_FTP_ERR_FILEEXISTS = <span class="number">8 </span>, MAV_FTP_ERR_FILEPROTECTED = <span class="number">9 </span>, MAV_FTP_ERR_FILENOTFOUND = <span class="number">10 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavFtpErr { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_FTP_ERR_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidClassificationType { MAV_ODID_CLASSIFICATION_TYPE_UNDECLARED = <span class="number">0 </span>, MAV_ODID_CLASSIFICATION_TYPE_EU = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidClassificationType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_CLASSIFICATION_TYPE_UNDECLARED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>RtkBaselineCoordinateSystem { RTK_BASELINE_COORDINATE_SYSTEM_ECEF = <span class="number">0 </span>, RTK_BASELINE_COORDINATE_SYSTEM_NED = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>RtkBaselineCoordinateSystem { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: RTK_BASELINE_COORDINATE_SYSTEM_ECEF } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AdsbFlags : u16 { <span class="kw">const </span>ADSB_FLAGS_VALID_COORDS = <span class="number">1 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_ALTITUDE = <span class="number">2 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_HEADING = <span class="number">4 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_VELOCITY = <span class="number">8 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_CALLSIGN = <span class="number">16 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_SQUAWK = <span class="number">32 </span>; <span class="kw">const </span>ADSB_FLAGS_SIMULATED = <span class="number">64 </span>; <span class="kw">const </span>ADSB_FLAGS_VERTICAL_VELOCITY_VALID = <span class="number">128 </span>; <span class="kw">const </span>ADSB_FLAGS_BARO_VALID = <span class="number">256 </span>; <span class="kw">const </span>ADSB_FLAGS_SOURCE_UAT = <span class="number">32768 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>AdsbFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ADSB_FLAGS_VALID_COORDS } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMissionType { MAV_MISSION_TYPE_MISSION = <span class="number">0 </span>, MAV_MISSION_TYPE_FENCE = <span class="number">1 </span>, MAV_MISSION_TYPE_RALLY = <span class="number">2 </span>, MAV_MISSION_TYPE_ALL = <span class="number">255 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavMissionType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_MISSION_TYPE_MISSION } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavState { MAV_STATE_UNINIT = <span class="number">0 </span>, MAV_STATE_BOOT = <span class="number">1 </span>, MAV_STATE_CALIBRATING = <span class="number">2 </span>, MAV_STATE_STANDBY = <span class="number">3 </span>, MAV_STATE_ACTIVE = <span class="number">4 </span>, MAV_STATE_CRITICAL = <span class="number">5 </span>, MAV_STATE_EMERGENCY = <span class="number">6 </span>, MAV_STATE_POWEROFF = <span class="number">7 </span>, MAV_STATE_FLIGHT_TERMINATION = <span class="number">8 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_STATE_UNINIT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EstimatorStatusFlags : u16 { <span class="kw">const </span>ESTIMATOR_ATTITUDE = <span class="number">1 </span>; <span class="kw">const </span>ESTIMATOR_VELOCITY_HORIZ = <span class="number">2 </span>; <span class="kw">const </span>ESTIMATOR_VELOCITY_VERT = <span class="number">4 </span>; <span class="kw">const </span>ESTIMATOR_POS_HORIZ_REL = <span class="number">8 </span>; <span class="kw">const </span>ESTIMATOR_POS_HORIZ_ABS = <span class="number">16 </span>; <span class="kw">const </span>ESTIMATOR_POS_VERT_ABS = <span class="number">32 </span>; <span class="kw">const </span>ESTIMATOR_POS_VERT_AGL = <span class="number">64 </span>; <span class="kw">const </span>ESTIMATOR_CONST_POS_MODE = <span class="number">128 </span>; <span class="kw">const </span>ESTIMATOR_PRED_POS_HORIZ_REL = <span class="number">256 </span>; <span class="kw">const </span>ESTIMATOR_PRED_POS_HORIZ_ABS = <span class="number">512 </span>; <span class="kw">const </span>ESTIMATOR_GPS_GLITCH = <span class="number">1024 </span>; <span class="kw">const </span>ESTIMATOR_ACCEL_ERROR = <span class="number">2048 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>EstimatorStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ESTIMATOR_ATTITUDE } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalDeviceErrorFlags : u32 { <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_AT_ROLL_LIMIT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_AT_PITCH_LIMIT = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_AT_YAW_LIMIT = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_ENCODER_ERROR = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_POWER_ERROR = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_MOTOR_ERROR = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_SOFTWARE_ERROR = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_COMMS_ERROR = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_CALIBRATION_RUNNING = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_NO_MANAGER = <span class="number">512 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalDeviceErrorFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GIMBAL_DEVICE_ERROR_FLAGS_AT_ROLL_LIMIT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraTrackingTargetData { CAMERA_TRACKING_TARGET_DATA_NONE = <span class="number">0 </span>, CAMERA_TRACKING_TARGET_DATA_EMBEDDED = <span class="number">1 </span>, CAMERA_TRACKING_TARGET_DATA_RENDERED = <span class="number">2 </span>, CAMERA_TRACKING_TARGET_DATA_IN_STATUS = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CameraTrackingTargetData { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CAMERA_TRACKING_TARGET_DATA_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavVtolState { MAV_VTOL_STATE_UNDEFINED = <span class="number">0 </span>, MAV_VTOL_STATE_TRANSITION_TO_FW = <span class="number">1 </span>, MAV_VTOL_STATE_TRANSITION_TO_MC = <span class="number">2 </span>, MAV_VTOL_STATE_MC = <span class="number">3 </span>, MAV_VTOL_STATE_FW = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavVtolState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_VTOL_STATE_UNDEFINED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraTrackingMode { CAMERA_TRACKING_MODE_NONE = <span class="number">0 </span>, CAMERA_TRACKING_MODE_POINT = <span class="number">1 </span>, CAMERA_TRACKING_MODE_RECTANGLE = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CameraTrackingMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CAMERA_TRACKING_MODE_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GripperActions { GRIPPER_ACTION_RELEASE = <span class="number">0 </span>, GRIPPER_ACTION_GRAB = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>GripperActions { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GRIPPER_ACTION_RELEASE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavlinkDataStreamType { MAVLINK_DATA_STREAM_IMG_JPEG = <span class="number">0 </span>, MAVLINK_DATA_STREAM_IMG_BMP = <span class="number">1 </span>, MAVLINK_DATA_STREAM_IMG_RAW8U = <span class="number">2 </span>, MAVLINK_DATA_STREAM_IMG_RAW32U = <span class="number">3 </span>, MAVLINK_DATA_STREAM_IMG_PGM = <span class="number">4 </span>, MAVLINK_DATA_STREAM_IMG_PNG = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavlinkDataStreamType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAVLINK_DATA_STREAM_IMG_JPEG } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AttitudeTargetTypemask : u8 { <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE = <span class="number">1 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_BODY_PITCH_RATE_IGNORE = <span class="number">2 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_BODY_YAW_RATE_IGNORE = <span class="number">4 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_THRUST_BODY_SET = <span class="number">32 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_THROTTLE_IGNORE = <span class="number">64 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_ATTITUDE_IGNORE = <span class="number">128 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>AttitudeTargetTypemask { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CompMetadataType { COMP_METADATA_TYPE_GENERAL = <span class="number">0 </span>, COMP_METADATA_TYPE_PARAMETER = <span class="number">1 </span>, COMP_METADATA_TYPE_COMMANDS = <span class="number">2 </span>, COMP_METADATA_TYPE_PERIPHERALS = <span class="number">3 </span>, COMP_METADATA_TYPE_EVENTS = <span class="number">4 </span>, COMP_METADATA_TYPE_ACTUATORS = <span class="number">5 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CompMetadataType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: COMP_METADATA_TYPE_GENERAL } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GpsFixType { GPS_FIX_TYPE_NO_GPS = <span class="number">0 </span>, GPS_FIX_TYPE_NO_FIX = <span class="number">1 </span>, GPS_FIX_TYPE_2D_FIX = <span class="number">2 </span>, GPS_FIX_TYPE_3D_FIX = <span class="number">3 </span>, GPS_FIX_TYPE_DGPS = <span class="number">4 </span>, GPS_FIX_TYPE_RTK_FLOAT = <span class="number">5 </span>, GPS_FIX_TYPE_RTK_FIXED = <span class="number">6 </span>, GPS_FIX_TYPE_STATIC = <span class="number">7 </span>, GPS_FIX_TYPE_PPP = <span class="number">8 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>GpsFixType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GPS_FIX_TYPE_NO_GPS } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GimbalManagerFlags { GIMBAL_MANAGER_FLAGS_RETRACT = <span class="number">1 </span>, GIMBAL_MANAGER_FLAGS_NEUTRAL = <span class="number">2 </span>, GIMBAL_MANAGER_FLAGS_ROLL_LOCK = <span class="number">4 </span>, GIMBAL_MANAGER_FLAGS_PITCH_LOCK = <span class="number">8 </span>, GIMBAL_MANAGER_FLAGS_YAW_LOCK = <span class="number">16 </span>, GIMBAL_MANAGER_FLAGS_YAW_IN_VEHICLE_FRAME = <span class="number">32 </span>, GIMBAL_MANAGER_FLAGS_YAW_IN_EARTH_FRAME = <span class="number">64 </span>, GIMBAL_MANAGER_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME = <span class="number">128 </span>, GIMBAL_MANAGER_FLAGS_RC_EXCLUSIVE = <span class="number">256 </span>, GIMBAL_MANAGER_FLAGS_RC_MIXED = <span class="number">512 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalManagerFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GIMBAL_MANAGER_FLAGS_RETRACT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>SerialControlDev { SERIAL_CONTROL_DEV_TELEM1 = <span class="number">0 </span>, SERIAL_CONTROL_DEV_TELEM2 = <span class="number">1 </span>, SERIAL_CONTROL_DEV_GPS1 = <span class="number">2 </span>, SERIAL_CONTROL_DEV_GPS2 = <span class="number">3 </span>, SERIAL_CONTROL_DEV_SHELL = <span class="number">10 </span>, SERIAL_CONTROL_SERIAL0 = <span class="number">100 </span>, SERIAL_CONTROL_SERIAL1 = <span class="number">101 </span>, SERIAL_CONTROL_SERIAL2 = <span class="number">102 </span>, SERIAL_CONTROL_SERIAL3 = <span class="number">103 </span>, SERIAL_CONTROL_SERIAL4 = <span class="number">104 </span>, SERIAL_CONTROL_SERIAL5 = <span class="number">105 </span>, SERIAL_CONTROL_SERIAL6 = <span class="number">106 </span>, SERIAL_CONTROL_SERIAL7 = <span class="number">107 </span>, SERIAL_CONTROL_SERIAL8 = <span class="number">108 </span>, SERIAL_CONTROL_SERIAL9 = <span class="number">109 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>SerialControlDev { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: SERIAL_CONTROL_DEV_TELEM1 } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularConfigResponse { CELLULAR_CONFIG_RESPONSE_ACCEPTED = <span class="number">0 </span>, CELLULAR_CONFIG_RESPONSE_APN_ERROR = <span class="number">1 </span>, CELLULAR_CONFIG_RESPONSE_PIN_ERROR = <span class="number">2 </span>, CELLULAR_CONFIG_RESPONSE_REJECTED = <span class="number">3 </span>, CELLULAR_CONFIG_BLOCKED_PUK_REQUIRED = <span class="number">4 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>CellularConfigResponse { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: CELLULAR_CONFIG_RESPONSE_ACCEPTED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavModeFlagDecodePosition { MAV_MODE_FLAG_DECODE_POSITION_SAFETY = <span class="number">128 </span>, MAV_MODE_FLAG_DECODE_POSITION_MANUAL = <span class="number">64 </span>, MAV_MODE_FLAG_DECODE_POSITION_HIL = <span class="number">32 </span>, MAV_MODE_FLAG_DECODE_POSITION_STABILIZE = <span class="number">16 </span>, MAV_MODE_FLAG_DECODE_POSITION_GUIDED = <span class="number">8 </span>, MAV_MODE_FLAG_DECODE_POSITION_AUTO = <span class="number">4 </span>, MAV_MODE_FLAG_DECODE_POSITION_TEST = <span class="number">2 </span>, MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavModeFlagDecodePosition { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_MODE_FLAG_DECODE_POSITION_SAFETY } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UavionixAdsbOutDynamicState : u16 { <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE = <span class="number">1 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED = <span class="number">2 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED = <span class="number">4 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND = <span class="number">8 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT = <span class="number">16 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutDynamicState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbEmergencyStatus { UAVIONIX_ADSB_OUT_NO_EMERGENCY = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY = <span class="number">5 </span>, UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY = <span class="number">6 </span>, UAVIONIX_ADSB_OUT_RESERVED = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbEmergencyStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_NO_EMERGENCY } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>VideoStreamStatusFlags { VIDEO_STREAM_STATUS_FLAGS_RUNNING = <span class="number">1 </span>, VIDEO_STREAM_STATUS_FLAGS_THERMAL = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>VideoStreamStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: VIDEO_STREAM_STATUS_FLAGS_RUNNING } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidHeightRef { MAV_ODID_HEIGHT_REF_OVER_TAKEOFF = <span class="number">0 </span>, MAV_ODID_HEIGHT_REF_OVER_GROUND = <span class="number">1 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidHeightRef { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_HEIGHT_REF_OVER_TAKEOFF } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MotorTestOrder { MOTOR_TEST_ORDER_DEFAULT = <span class="number">0 </span>, MOTOR_TEST_ORDER_SEQUENCE = <span class="number">1 </span>, MOTOR_TEST_ORDER_BOARD = <span class="number">2 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MotorTestOrder { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MOTOR_TEST_ORDER_DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidCategoryEu { MAV_ODID_CATEGORY_EU_UNDECLARED = <span class="number">0 </span>, MAV_ODID_CATEGORY_EU_OPEN = <span class="number">1 </span>, MAV_ODID_CATEGORY_EU_SPECIFIC = <span class="number">2 </span>, MAV_ODID_CATEGORY_EU_CERTIFIED = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidCategoryEu { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_CATEGORY_EU_UNDECLARED } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MotorTestThrottleType { MOTOR_TEST_THROTTLE_PERCENT = <span class="number">0 </span>, MOTOR_TEST_THROTTLE_PWM = <span class="number">1 </span>, MOTOR_TEST_THROTTLE_PILOT = <span class="number">2 </span>, MOTOR_TEST_COMPASS_CAL = <span class="number">3 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MotorTestThrottleType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MOTOR_TEST_THROTTLE_PERCENT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidClassEu { MAV_ODID_CLASS_EU_UNDECLARED = <span class="number">0 </span>, MAV_ODID_CLASS_EU_CLASS_0 = <span class="number">1 </span>, MAV_ODID_CLASS_EU_CLASS_1 = <span class="number">2 </span>, MAV_ODID_CLASS_EU_CLASS_2 = <span class="number">3 </span>, MAV_ODID_CLASS_EU_CLASS_3 = <span class="number">4 </span>, MAV_ODID_CLASS_EU_CLASS_4 = <span class="number">5 </span>, MAV_ODID_CLASS_EU_CLASS_5 = <span class="number">6 </span>, MAV_ODID_CLASS_EU_CLASS_6 = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidClassEu { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAV_ODID_CLASS_EU_UNDECLARED } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalDeviceFlags : u16 { <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_RETRACT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_NEUTRAL = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_ROLL_LOCK = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_PITCH_LOCK = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_YAW_LOCK = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_RC_EXCLUSIVE = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_RC_MIXED = <span class="number">512 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalDeviceFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: GIMBAL_DEVICE_FLAGS_RETRACT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HighresImuUpdatedFlags : u16 { <span class="kw">const </span>HIGHRES_IMU_UPDATED_NONE = <span class="number">0 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_XACC = <span class="number">1 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_YACC = <span class="number">2 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ZACC = <span class="number">4 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_XGYRO = <span class="number">8 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_YGYRO = <span class="number">16 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ZGYRO = <span class="number">32 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_XMAG = <span class="number">64 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_YMAG = <span class="number">128 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ZMAG = <span class="number">256 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ABS_PRESSURE = <span class="number">512 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_DIFF_PRESSURE = <span class="number">1024 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_PRESSURE_ALT = <span class="number">2048 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_TEMPERATURE = <span class="number">4096 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ALL = <span class="number">65535 </span>; } } <span class="kw">impl </span>Default <span class="kw">for </span>HighresImuUpdatedFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: HIGHRES_IMU_UPDATED_NONE } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MagCalStatus { MAG_CAL_NOT_STARTED = <span class="number">0 </span>, MAG_CAL_WAITING_TO_START = <span class="number">1 </span>, MAG_CAL_RUNNING_STEP_ONE = <span class="number">2 </span>, MAG_CAL_RUNNING_STEP_TWO = <span class="number">3 </span>, MAG_CAL_SUCCESS = <span class="number">4 </span>, MAG_CAL_FAILED = <span class="number">5 </span>, MAG_CAL_BAD_ORIENTATION = <span class="number">6 </span>, MAG_CAL_BAD_RADIUS = <span class="number">7 </span>, } <span class="kw">impl </span>Default <span class="kw">for </span>MagCalStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: MAG_CAL_NOT_STARTED } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UTM_GLOBAL_POSITION_DATA { <span class="kw">pub </span>time : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>next_lat : i32 , <span class="kw">pub </span>next_lon : i32 , <span class="kw">pub </span>next_alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>h_acc : u16 , <span class="kw">pub </span>v_acc : u16 , <span class="kw">pub </span>vel_acc : u16 , <span class="kw">pub </span>update_rate : u16 , <span class="kw">pub </span>uas_id : [u8 ; <span class="number">18</span>] , <span class="kw">pub </span>flight_state : UtmFlightState , <span class="kw">pub </span>flags : UtmDataAvailFlags , } <span class="kw">impl </span>UTM_GLOBAL_POSITION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">70usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; _struct . next_lat = buf . get_i32_le () ; _struct . next_lon = buf . get_i32_le () ; _struct . next_alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . h_acc = buf . get_u16_le () ; _struct . v_acc = buf . get_u16_le () ; _struct . vel_acc = buf . get_u16_le () ; _struct . update_rate = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">18usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . uas_id [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flight_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UtmFlightState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = UtmDataAvailFlags :: from_bits (tmp &amp; UtmDataAvailFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UtmDataAvailFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; _tmp . put_i32_le (<span class="self">self </span>. next_lat) ; _tmp . put_i32_le (<span class="self">self </span>. next_lon) ; _tmp . put_i32_le (<span class="self">self </span>. next_alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_u16_le (<span class="self">self </span>. h_acc) ; _tmp . put_u16_le (<span class="self">self </span>. v_acc) ; _tmp . put_u16_le (<span class="self">self </span>. vel_acc) ; _tmp . put_u16_le (<span class="self">self </span>. update_rate) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uas_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. flight_state <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>controls : [f32 ; <span class="number">8</span>] , <span class="kw">pub </span>group_mlx : u8 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>SET_ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">43usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . controls [idx] = val ; } _struct . group_mlx = buf . get_u8 () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. controls { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. group_mlx) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_VALUE_DATA { <span class="kw">pub </span>param_count : u16 , <span class="kw">pub </span>param_index : u16 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_value : Vec &lt; u8 , <span class="number">128 </span>&gt; , <span class="kw">pub </span>param_type : MavParamExtType , } <span class="kw">impl </span>PARAM_EXT_VALUE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">149usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_count = buf . get_u16_le () ; _struct . param_index = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">128usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_value . push (val) . unwrap () ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamExtType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. param_count) ; _tmp . put_u16_le (<span class="self">self </span>. param_index) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_value { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_STATUS_DATA { <span class="kw">pub </span>satellites_visible : u8 , <span class="kw">pub </span>satellite_prn : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>satellite_used : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>satellite_elevation : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>satellite_azimuth : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>satellite_snr : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>GPS_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">101usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . satellites_visible = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . satellite_prn [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . satellite_used [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . satellite_elevation [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . satellite_azimuth [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . satellite_snr [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_prn { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_used { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_elevation { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_azimuth { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_snr { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEBUG_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>value : f32 , <span class="kw">pub </span>ind : u8 , } <span class="kw">impl </span>DEBUG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . value = buf . get_f32_le () ; _struct . ind = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. value) ; _tmp . put_u8 (<span class="self">self </span>. ind) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_SET_ATTITUDE_DATA { <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>angular_velocity_x : f32 , <span class="kw">pub </span>angular_velocity_y : f32 , <span class="kw">pub </span>angular_velocity_z : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_SET_ATTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . angular_velocity_x = buf . get_f32_le () ; _struct . angular_velocity_y = buf . get_f32_le () ; _struct . angular_velocity_z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RESOURCE_REQUEST_DATA { <span class="kw">pub </span>request_id : u8 , <span class="kw">pub </span>uri_type : u8 , <span class="kw">pub </span>uri : Vec &lt; u8 , <span class="number">120 </span>&gt; , <span class="kw">pub </span>transfer_type : u8 , <span class="kw">pub </span>storage : Vec &lt; u8 , <span class="number">120 </span>&gt; , } <span class="kw">impl </span>RESOURCE_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">243usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u8 () ; _struct . uri_type = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">120usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . uri . push (val) . unwrap () ; } _struct . transfer_type = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">120usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . storage . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. uri_type) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. transfer_type) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ACTUATOR_OUTPUT_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>active : u32 , <span class="kw">pub </span>actuator : [f32 ; <span class="number">32</span>] , } <span class="kw">impl </span>ACTUATOR_OUTPUT_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">140usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . active = buf . get_u32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . actuator [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. active) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. actuator { _tmp . put_f32_le (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TRAJECTORY_REPRESENTATION_BEZIER_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>pos_x : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>pos_y : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>pos_z : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>delta : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>pos_yaw : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>valid_points : u8 , } <span class="kw">impl </span>TRAJECTORY_REPRESENTATION_BEZIER_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">109usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_x [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_y [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_z [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . delta [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_yaw [idx] = val ; } _struct . valid_points = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. delta { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_yaw { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. valid_points) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>gimbal_device_id : u8 , <span class="kw">pub </span>primary_control_sysid : u8 , <span class="kw">pub </span>primary_control_compid : u8 , <span class="kw">pub </span>secondary_control_sysid : u8 , <span class="kw">pub </span>secondary_control_compid : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . gimbal_device_id = buf . get_u8 () ; _struct . primary_control_sysid = buf . get_u8 () ; _struct . primary_control_compid = buf . get_u8 () ; _struct . secondary_control_sysid = buf . get_u8 () ; _struct . secondary_control_compid = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; _tmp . put_u8 (<span class="self">self </span>. primary_control_sysid) ; _tmp . put_u8 (<span class="self">self </span>. primary_control_compid) ; _tmp . put_u8 (<span class="self">self </span>. secondary_control_sysid) ; _tmp . put_u8 (<span class="self">self </span>. secondary_control_compid) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>REQUEST_EVENT_DATA { <span class="kw">pub </span>first_sequence : u16 , <span class="kw">pub </span>last_sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>REQUEST_EVENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . first_sequence = buf . get_u16_le () ; _struct . last_sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. first_sequence) ; _tmp . put_u16_le (<span class="self">self </span>. last_sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_SYSTEM_UPDATE_DATA { <span class="kw">pub </span>operator_latitude : i32 , <span class="kw">pub </span>operator_longitude : i32 , <span class="kw">pub </span>operator_altitude_geo : f32 , <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>OPEN_DRONE_ID_SYSTEM_UPDATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . operator_latitude = buf . get_i32_le () ; _struct . operator_longitude = buf . get_i32_le () ; _struct . operator_altitude_geo = buf . get_f32_le () ; _struct . timestamp = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. operator_latitude) ; _tmp . put_i32_le (<span class="self">self </span>. operator_longitude) ; _tmp . put_f32_le (<span class="self">self </span>. operator_altitude_geo) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>POWER_STATUS_DATA { <span class="kw">pub </span>Vcc : u16 , <span class="kw">pub </span>Vservo : u16 , <span class="kw">pub </span>flags : MavPowerStatus , } <span class="kw">impl </span>POWER_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . Vcc = buf . get_u16_le () ; _struct . Vservo = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = MavPowerStatus :: from_bits (tmp &amp; MavPowerStatus :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavPowerStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. Vcc) ; _tmp . put_u16_le (<span class="self">self </span>. Vservo) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_SCALED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>chan1_scaled : i16 , <span class="kw">pub </span>chan2_scaled : i16 , <span class="kw">pub </span>chan3_scaled : i16 , <span class="kw">pub </span>chan4_scaled : i16 , <span class="kw">pub </span>chan5_scaled : i16 , <span class="kw">pub </span>chan6_scaled : i16 , <span class="kw">pub </span>chan7_scaled : i16 , <span class="kw">pub </span>chan8_scaled : i16 , <span class="kw">pub </span>port : u8 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>RC_CHANNELS_SCALED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . chan1_scaled = buf . get_i16_le () ; _struct . chan2_scaled = buf . get_i16_le () ; _struct . chan3_scaled = buf . get_i16_le () ; _struct . chan4_scaled = buf . get_i16_le () ; _struct . chan5_scaled = buf . get_i16_le () ; _struct . chan6_scaled = buf . get_i16_le () ; _struct . chan7_scaled = buf . get_i16_le () ; _struct . chan8_scaled = buf . get_i16_le () ; _struct . port = buf . get_u8 () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. chan1_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan2_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan3_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan4_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan5_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan6_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan7_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan8_scaled) ; _tmp . put_u8 (<span class="self">self </span>. port) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_LIST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATT_POS_MOCAP_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , } <span class="kw">impl </span>ATT_POS_MOCAP_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_MAP_RC_DATA { <span class="kw">pub </span>param_value0 : f32 , <span class="kw">pub </span>scale : f32 , <span class="kw">pub </span>param_value_min : f32 , <span class="kw">pub </span>param_value_max : f32 , <span class="kw">pub </span>param_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>parameter_rc_channel_index : u8 , } <span class="kw">impl </span>PARAM_MAP_RC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_value0 = buf . get_f32_le () ; _struct . scale = buf . get_f32_le () ; _struct . param_value_min = buf . get_f32_le () ; _struct . param_value_max = buf . get_f32_le () ; _struct . param_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } _struct . parameter_rc_channel_index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param_value0) ; _tmp . put_f32_le (<span class="self">self </span>. scale) ; _tmp . put_f32_le (<span class="self">self </span>. param_value_min) ; _tmp . put_f32_le (<span class="self">self </span>. param_value_max) ; _tmp . put_i16_le (<span class="self">self </span>. param_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. parameter_rc_channel_index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_REQUEST_LIST_DATA { <span class="kw">pub </span>start : u16 , <span class="kw">pub </span>end : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . start = buf . get_u16_le () ; _struct . end = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. start) ; _tmp . put_u16_le (<span class="self">self </span>. end) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SERVO_OUTPUT_RAW_DATA { <span class="kw">pub </span>time_usec : u32 , <span class="kw">pub </span>servo1_raw : u16 , <span class="kw">pub </span>servo2_raw : u16 , <span class="kw">pub </span>servo3_raw : u16 , <span class="kw">pub </span>servo4_raw : u16 , <span class="kw">pub </span>servo5_raw : u16 , <span class="kw">pub </span>servo6_raw : u16 , <span class="kw">pub </span>servo7_raw : u16 , <span class="kw">pub </span>servo8_raw : u16 , <span class="kw">pub </span>port : u8 , } <span class="kw">impl </span>SERVO_OUTPUT_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">21usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u32_le () ; _struct . servo1_raw = buf . get_u16_le () ; _struct . servo2_raw = buf . get_u16_le () ; _struct . servo3_raw = buf . get_u16_le () ; _struct . servo4_raw = buf . get_u16_le () ; _struct . servo5_raw = buf . get_u16_le () ; _struct . servo6_raw = buf . get_u16_le () ; _struct . servo7_raw = buf . get_u16_le () ; _struct . servo8_raw = buf . get_u16_le () ; _struct . port = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_usec) ; _tmp . put_u16_le (<span class="self">self </span>. servo1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo8_raw) ; _tmp . put_u8 (<span class="self">self </span>. port) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_FOV_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat_camera : i32 , <span class="kw">pub </span>lon_camera : i32 , <span class="kw">pub </span>alt_camera : i32 , <span class="kw">pub </span>lat_image : i32 , <span class="kw">pub </span>lon_image : i32 , <span class="kw">pub </span>alt_image : i32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>hfov : f32 , <span class="kw">pub </span>vfov : f32 , } <span class="kw">impl </span>CAMERA_FOV_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">52usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat_camera = buf . get_i32_le () ; _struct . lon_camera = buf . get_i32_le () ; _struct . alt_camera = buf . get_i32_le () ; _struct . lat_image = buf . get_i32_le () ; _struct . lon_image = buf . get_i32_le () ; _struct . alt_image = buf . get_i32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . hfov = buf . get_f32_le () ; _struct . vfov = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat_camera) ; _tmp . put_i32_le (<span class="self">self </span>. lon_camera) ; _tmp . put_i32_le (<span class="self">self </span>. alt_camera) ; _tmp . put_i32_le (<span class="self">self </span>. lat_image) ; _tmp . put_i32_le (<span class="self">self </span>. lon_image) ; _tmp . put_i32_le (<span class="self">self </span>. alt_image) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. hfov) ; _tmp . put_f32_le (<span class="self">self </span>. vfov) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ODOMETRY_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , <span class="kw">pub </span>pose_covariance : [f32 ; <span class="number">21</span>] , <span class="kw">pub </span>velocity_covariance : [f32 ; <span class="number">21</span>] , <span class="kw">pub </span>frame_id : MavFrame , <span class="kw">pub </span>child_frame_id : MavFrame , } <span class="kw">impl </span>ODOMETRY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">230usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">21usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pose_covariance [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">21usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . velocity_covariance [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . child_frame_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pose_covariance { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. velocity_covariance { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. frame_id <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. child_frame_id <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WINCH_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>line_length : f32 , <span class="kw">pub </span>speed : f32 , <span class="kw">pub </span>tension : f32 , <span class="kw">pub </span>voltage : f32 , <span class="kw">pub </span>current : f32 , <span class="kw">pub </span>status : MavWinchStatusFlag , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>WINCH_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">34usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . line_length = buf . get_f32_le () ; _struct . speed = buf . get_f32_le () ; _struct . tension = buf . get_f32_le () ; _struct . voltage = buf . get_f32_le () ; _struct . current = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . status = MavWinchStatusFlag :: from_bits (tmp &amp; MavWinchStatusFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavWinchStatusFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. line_length) ; _tmp . put_f32_le (<span class="self">self </span>. speed) ; _tmp . put_f32_le (<span class="self">self </span>. tension) ; _tmp . put_f32_le (<span class="self">self </span>. voltage) ; _tmp . put_f32_le (<span class="self">self </span>. current) ; _tmp . put_u32_le (<span class="self">self </span>. status . bits ()) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SAFETY_ALLOWED_AREA_DATA { <span class="kw">pub </span>p1x : f32 , <span class="kw">pub </span>p1y : f32 , <span class="kw">pub </span>p1z : f32 , <span class="kw">pub </span>p2x : f32 , <span class="kw">pub </span>p2y : f32 , <span class="kw">pub </span>p2z : f32 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>SAFETY_ALLOWED_AREA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . p1x = buf . get_f32_le () ; _struct . p1y = buf . get_f32_le () ; _struct . p1z = buf . get_f32_le () ; _struct . p2x = buf . get_f32_le () ; _struct . p2y = buf . get_f32_le () ; _struct . p2z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. p1x) ; _tmp . put_f32_le (<span class="self">self </span>. p1y) ; _tmp . put_f32_le (<span class="self">self </span>. p1z) ; _tmp . put_f32_le (<span class="self">self </span>. p2x) ; _tmp . put_f32_le (<span class="self">self </span>. p2y) ; _tmp . put_f32_le (<span class="self">self </span>. p2z) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA_TRANSMISSION_HANDSHAKE_DATA { <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>width : u16 , <span class="kw">pub </span>height : u16 , <span class="kw">pub </span>packets : u16 , <span class="kw">pub </span>mavtype : MavlinkDataStreamType , <span class="kw">pub </span>payload : u8 , <span class="kw">pub </span>jpg_quality : u8 , } <span class="kw">impl </span>DATA_TRANSMISSION_HANDSHAKE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . size = buf . get_u32_le () ; _struct . width = buf . get_u16_le () ; _struct . height = buf . get_u16_le () ; _struct . packets = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavlinkDataStreamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . payload = buf . get_u8 () ; _struct . jpg_quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. size) ; _tmp . put_u16_le (<span class="self">self </span>. width) ; _tmp . put_u16_le (<span class="self">self </span>. height) ; _tmp . put_u16_le (<span class="self">self </span>. packets) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. payload) ; _tmp . put_u8 (<span class="self">self </span>. jpg_quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_MODE_DATA { <span class="kw">pub </span>custom_mode : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>base_mode : MavMode , } <span class="kw">impl </span>SET_MODE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . custom_mode = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . base_mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. custom_mode) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. base_mode <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_LONG_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>param5 : f32 , <span class="kw">pub </span>param6 : f32 , <span class="kw">pub </span>param7 : f32 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>confirmation : u8 , } <span class="kw">impl </span>COMMAND_LONG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">33usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . param5 = buf . get_f32_le () ; _struct . param6 = buf . get_f32_le () ; _struct . param7 = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . confirmation = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_f32_le (<span class="self">self </span>. param5) ; _tmp . put_f32_le (<span class="self">self </span>. param6) ; _tmp . put_f32_le (<span class="self">self </span>. param7) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. confirmation) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SMART_BATTERY_INFO_DATA { <span class="kw">pub </span>capacity_full_specification : i32 , <span class="kw">pub </span>capacity_full : i32 , <span class="kw">pub </span>cycle_count : u16 , <span class="kw">pub </span>weight : u16 , <span class="kw">pub </span>discharge_minimum_voltage : u16 , <span class="kw">pub </span>charging_minimum_voltage : u16 , <span class="kw">pub </span>resting_minimum_voltage : u16 , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>battery_function : MavBatteryFunction , <span class="kw">pub </span>mavtype : MavBatteryType , <span class="kw">pub </span>serial_number : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>device_name : Vec &lt; u8 , <span class="number">50 </span>&gt; , } <span class="kw">impl </span>SMART_BATTERY_INFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">87usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . capacity_full_specification = buf . get_i32_le () ; _struct . capacity_full = buf . get_i32_le () ; _struct . cycle_count = buf . get_u16_le () ; _struct . weight = buf . get_u16_le () ; _struct . discharge_minimum_voltage = buf . get_u16_le () ; _struct . charging_minimum_voltage = buf . get_u16_le () ; _struct . resting_minimum_voltage = buf . get_u16_le () ; _struct . id = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . battery_function = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryFunction&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . serial_number [idx] = val ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">50usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . device_name . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. capacity_full_specification) ; _tmp . put_i32_le (<span class="self">self </span>. capacity_full) ; _tmp . put_u16_le (<span class="self">self </span>. cycle_count) ; _tmp . put_u16_le (<span class="self">self </span>. weight) ; _tmp . put_u16_le (<span class="self">self </span>. discharge_minimum_voltage) ; _tmp . put_u16_le (<span class="self">self </span>. charging_minimum_voltage) ; _tmp . put_u16_le (<span class="self">self </span>. resting_minimum_voltage) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. battery_function <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. serial_number { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. device_name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_STATE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , } <span class="kw">impl </span>HIL_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">56usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>SET_POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVCAN_NODE_INFO_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>uptime_sec : u32 , <span class="kw">pub </span>sw_vcs_commit : u32 , <span class="kw">pub </span>name : Vec &lt; u8 , <span class="number">80 </span>&gt; , <span class="kw">pub </span>hw_version_major : u8 , <span class="kw">pub </span>hw_version_minor : u8 , <span class="kw">pub </span>hw_unique_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>sw_version_major : u8 , <span class="kw">pub </span>sw_version_minor : u8 , } <span class="kw">impl </span>UAVCAN_NODE_INFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">116usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . uptime_sec = buf . get_u32_le () ; _struct . sw_vcs_commit = buf . get_u32_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">80usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name . push (val) . unwrap () ; } _struct . hw_version_major = buf . get_u8 () ; _struct . hw_version_minor = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . hw_unique_id [idx] = val ; } _struct . sw_version_major = buf . get_u8 () ; _struct . sw_version_minor = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. uptime_sec) ; _tmp . put_u32_le (<span class="self">self </span>. sw_vcs_commit) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. hw_version_major) ; _tmp . put_u8 (<span class="self">self </span>. hw_version_minor) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. hw_unique_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. sw_version_major) ; _tmp . put_u8 (<span class="self">self </span>. sw_version_minor) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_DATA_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>grid_spacing : u16 , <span class="kw">pub </span>data : [i16 ; <span class="number">16</span>] , <span class="kw">pub </span>gridbit : u8 , } <span class="kw">impl </span>TERRAIN_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">43usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . grid_spacing = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_i16_le () ; _struct . data [idx] = val ; } _struct . gridbit = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_u16_le (<span class="self">self </span>. grid_spacing) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_i16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. gridbit) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ADSB_VEHICLE_DATA { <span class="kw">pub </span>ICAO_address : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>heading : u16 , <span class="kw">pub </span>hor_velocity : u16 , <span class="kw">pub </span>ver_velocity : i16 , <span class="kw">pub </span>flags : AdsbFlags , <span class="kw">pub </span>squawk : u16 , <span class="kw">pub </span>altitude_type : AdsbAltitudeType , <span class="kw">pub </span>callsign : [u8 ; <span class="number">9</span>] , <span class="kw">pub </span>emitter_type : AdsbEmitterType , <span class="kw">pub </span>tslc : u8 , } <span class="kw">impl </span>ADSB_VEHICLE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">38usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ICAO_address = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . heading = buf . get_u16_le () ; _struct . hor_velocity = buf . get_u16_le () ; _struct . ver_velocity = buf . get_i16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = AdsbFlags :: from_bits (tmp &amp; AdsbFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AdsbFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . squawk = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . altitude_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AdsbAltitudeType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">9usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . callsign [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . emitter_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AdsbEmitterType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . tslc = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ICAO_address) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_u16_le (<span class="self">self </span>. heading) ; _tmp . put_u16_le (<span class="self">self </span>. hor_velocity) ; _tmp . put_i16_le (<span class="self">self </span>. ver_velocity) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. squawk) ; _tmp . put_u8 (<span class="self">self </span>. altitude_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. callsign { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. emitter_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. tslc) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEBUG_VECT_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>DEBUG_VECT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">30usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ENCAPSULATED_DATA_DATA { <span class="kw">pub </span>seqnr : u16 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">253 </span>&gt; , } <span class="kw">impl </span>ENCAPSULATED_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seqnr = buf . get_u16_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">253usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seqnr) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>BUTTON_CHANGE_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>last_change_ms : u32 , <span class="kw">pub </span>state : u8 , } <span class="kw">impl </span>BUTTON_CHANGE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . last_change_ms = buf . get_u32_le () ; _struct . state = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. last_change_ms) ; _tmp . put_u8 (<span class="self">self </span>. state) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>target_system : u8 , } <span class="kw">impl </span>SET_GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . target_system = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MANUAL_CONTROL_DATA { <span class="kw">pub </span>x : i16 , <span class="kw">pub </span>y : i16 , <span class="kw">pub </span>z : i16 , <span class="kw">pub </span>r : i16 , <span class="kw">pub </span>buttons : u16 , <span class="kw">pub </span>target : u8 , } <span class="kw">impl </span>MANUAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">11usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . x = buf . get_i16_le () ; _struct . y = buf . get_i16_le () ; _struct . z = buf . get_i16_le () ; _struct . r = buf . get_i16_le () ; _struct . buttons = buf . get_u16_le () ; _struct . target = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. x) ; _tmp . put_i16_le (<span class="self">self </span>. y) ; _tmp . put_i16_le (<span class="self">self </span>. z) ; _tmp . put_i16_le (<span class="self">self </span>. r) ; _tmp . put_u16_le (<span class="self">self </span>. buttons) ; _tmp . put_u8 (<span class="self">self </span>. target) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RAW_PRESSURE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>press_abs : i16 , <span class="kw">pub </span>press_diff1 : i16 , <span class="kw">pub </span>press_diff2 : i16 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>RAW_PRESSURE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . press_abs = buf . get_i16_le () ; _struct . press_diff1 = buf . get_i16_le () ; _struct . press_diff2 = buf . get_i16_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i16_le (<span class="self">self </span>. press_abs) ; _tmp . put_i16_le (<span class="self">self </span>. press_diff1) ; _tmp . put_i16_le (<span class="self">self </span>. press_diff2) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ITEM_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , <span class="kw">pub </span>current : u8 , <span class="kw">pub </span>autocontinue : u8 , } <span class="kw">impl </span>MISSION_ITEM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . seq = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . current = buf . get_u8 () ; _struct . autocontinue = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. current) ; _tmp . put_u8 (<span class="self">self </span>. autocontinue) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ORBIT_EXECUTION_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>radius : f32 , <span class="kw">pub </span>x : i32 , <span class="kw">pub </span>y : i32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>ORBIT_EXECUTION_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . radius = buf . get_f32_le () ; _struct . x = buf . get_i32_le () ; _struct . y = buf . get_i32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. radius) ; _tmp . put_i32_le (<span class="self">self </span>. x) ; _tmp . put_i32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MAG_CAL_REPORT_DATA { <span class="kw">pub </span>fitness : f32 , <span class="kw">pub </span>ofs_x : f32 , <span class="kw">pub </span>ofs_y : f32 , <span class="kw">pub </span>ofs_z : f32 , <span class="kw">pub </span>diag_x : f32 , <span class="kw">pub </span>diag_y : f32 , <span class="kw">pub </span>diag_z : f32 , <span class="kw">pub </span>offdiag_x : f32 , <span class="kw">pub </span>offdiag_y : f32 , <span class="kw">pub </span>offdiag_z : f32 , <span class="kw">pub </span>compass_id : u8 , <span class="kw">pub </span>cal_mask : u8 , <span class="kw">pub </span>cal_status : MagCalStatus , <span class="kw">pub </span>autosaved : u8 , } <span class="kw">impl </span>MAG_CAL_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . fitness = buf . get_f32_le () ; _struct . ofs_x = buf . get_f32_le () ; _struct . ofs_y = buf . get_f32_le () ; _struct . ofs_z = buf . get_f32_le () ; _struct . diag_x = buf . get_f32_le () ; _struct . diag_y = buf . get_f32_le () ; _struct . diag_z = buf . get_f32_le () ; _struct . offdiag_x = buf . get_f32_le () ; _struct . offdiag_y = buf . get_f32_le () ; _struct . offdiag_z = buf . get_f32_le () ; _struct . compass_id = buf . get_u8 () ; _struct . cal_mask = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cal_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MagCalStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . autosaved = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. fitness) ; _tmp . put_f32_le (<span class="self">self </span>. ofs_x) ; _tmp . put_f32_le (<span class="self">self </span>. ofs_y) ; _tmp . put_f32_le (<span class="self">self </span>. ofs_z) ; _tmp . put_f32_le (<span class="self">self </span>. diag_x) ; _tmp . put_f32_le (<span class="self">self </span>. diag_y) ; _tmp . put_f32_le (<span class="self">self </span>. diag_z) ; _tmp . put_f32_le (<span class="self">self </span>. offdiag_x) ; _tmp . put_f32_le (<span class="self">self </span>. offdiag_y) ; _tmp . put_f32_le (<span class="self">self </span>. offdiag_z) ; _tmp . put_u8 (<span class="self">self </span>. compass_id) ; _tmp . put_u8 (<span class="self">self </span>. cal_mask) ; _tmp . put_u8 (<span class="self">self </span>. cal_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. autosaved) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HEARTBEAT_DATA { <span class="kw">pub </span>custom_mode : u32 , <span class="kw">pub </span>mavtype : MavType , <span class="kw">pub </span>autopilot : MavAutopilot , <span class="kw">pub </span>base_mode : MavModeFlag , <span class="kw">pub </span>system_status : MavState , <span class="kw">pub </span>mavlink_version : u8 , } <span class="kw">impl </span>HEARTBEAT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . custom_mode = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . autopilot = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavAutopilot&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . base_mode = MavModeFlag :: from_bits (tmp &amp; MavModeFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavModeFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . system_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . mavlink_version = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. custom_mode) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. autopilot <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. base_mode . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. system_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavlink_version) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_DEVICE_ATTITUDE_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>angular_velocity_x : f32 , <span class="kw">pub </span>angular_velocity_y : f32 , <span class="kw">pub </span>angular_velocity_z : f32 , <span class="kw">pub </span>failure_flags : GimbalDeviceErrorFlags , <span class="kw">pub </span>flags : GimbalDeviceFlags , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_DEVICE_ATTITUDE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . angular_velocity_x = buf . get_f32_le () ; _struct . angular_velocity_y = buf . get_f32_le () ; _struct . angular_velocity_z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . failure_flags = GimbalDeviceErrorFlags :: from_bits (tmp &amp; GimbalDeviceErrorFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceErrorFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = GimbalDeviceFlags :: from_bits (tmp &amp; GimbalDeviceFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_z) ; _tmp . put_u32_le (<span class="self">self </span>. failure_flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_OPERATOR_ID_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>operator_id_type : MavOdidOperatorIdType , <span class="kw">pub </span>operator_id : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_OPERATOR_ID_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">43usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . operator_id_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidOperatorIdType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . operator_id [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. operator_id_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. operator_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LINK_NODE_STATUS_DATA { <span class="kw">pub </span>timestamp : u64 , <span class="kw">pub </span>tx_rate : u32 , <span class="kw">pub </span>rx_rate : u32 , <span class="kw">pub </span>messages_sent : u32 , <span class="kw">pub </span>messages_received : u32 , <span class="kw">pub </span>messages_lost : u32 , <span class="kw">pub </span>rx_parse_err : u16 , <span class="kw">pub </span>tx_overflows : u16 , <span class="kw">pub </span>rx_overflows : u16 , <span class="kw">pub </span>tx_buf : u8 , <span class="kw">pub </span>rx_buf : u8 , } <span class="kw">impl </span>LINK_NODE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u64_le () ; _struct . tx_rate = buf . get_u32_le () ; _struct . rx_rate = buf . get_u32_le () ; _struct . messages_sent = buf . get_u32_le () ; _struct . messages_received = buf . get_u32_le () ; _struct . messages_lost = buf . get_u32_le () ; _struct . rx_parse_err = buf . get_u16_le () ; _struct . tx_overflows = buf . get_u16_le () ; _struct . rx_overflows = buf . get_u16_le () ; _struct . tx_buf = buf . get_u8 () ; _struct . rx_buf = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. timestamp) ; _tmp . put_u32_le (<span class="self">self </span>. tx_rate) ; _tmp . put_u32_le (<span class="self">self </span>. rx_rate) ; _tmp . put_u32_le (<span class="self">self </span>. messages_sent) ; _tmp . put_u32_le (<span class="self">self </span>. messages_received) ; _tmp . put_u32_le (<span class="self">self </span>. messages_lost) ; _tmp . put_u16_le (<span class="self">self </span>. rx_parse_err) ; _tmp . put_u16_le (<span class="self">self </span>. tx_overflows) ; _tmp . put_u16_le (<span class="self">self </span>. rx_overflows) ; _tmp . put_u8 (<span class="self">self </span>. tx_buf) ; _tmp . put_u8 (<span class="self">self </span>. rx_buf) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MEMORY_VECT_DATA { <span class="kw">pub </span>address : u16 , <span class="kw">pub </span>ver : u8 , <span class="kw">pub </span>mavtype : u8 , <span class="kw">pub </span>value : [i8 ; <span class="number">32</span>] , } <span class="kw">impl </span>MEMORY_VECT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . address = buf . get_u16_le () ; _struct . ver = buf . get_u8 () ; _struct . mavtype = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_i8 () ; _struct . value [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. address) ; _tmp . put_u8 (<span class="self">self </span>. ver) ; _tmp . put_u8 (<span class="self">self </span>. mavtype) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. value { _tmp . put_i8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EXTENDED_SYS_STATE_DATA { <span class="kw">pub </span>vtol_state : MavVtolState , <span class="kw">pub </span>landed_state : MavLandedState , } <span class="kw">impl </span>EXTENDED_SYS_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . vtol_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavVtolState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . landed_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavLandedState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. vtol_state <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. landed_state <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>NAMED_VALUE_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>value : i32 , <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>NAMED_VALUE_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . value = buf . get_i32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. value) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_SYSTEM_DATA { <span class="kw">pub </span>operator_latitude : i32 , <span class="kw">pub </span>operator_longitude : i32 , <span class="kw">pub </span>area_ceiling : f32 , <span class="kw">pub </span>area_floor : f32 , <span class="kw">pub </span>operator_altitude_geo : f32 , <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>area_count : u16 , <span class="kw">pub </span>area_radius : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>operator_location_type : MavOdidOperatorLocationType , <span class="kw">pub </span>classification_type : MavOdidClassificationType , <span class="kw">pub </span>category_eu : MavOdidCategoryEu , <span class="kw">pub </span>class_eu : MavOdidClassEu , } <span class="kw">impl </span>OPEN_DRONE_ID_SYSTEM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">54usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . operator_latitude = buf . get_i32_le () ; _struct . operator_longitude = buf . get_i32_le () ; _struct . area_ceiling = buf . get_f32_le () ; _struct . area_floor = buf . get_f32_le () ; _struct . operator_altitude_geo = buf . get_f32_le () ; _struct . timestamp = buf . get_u32_le () ; _struct . area_count = buf . get_u16_le () ; _struct . area_radius = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . operator_location_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidOperatorLocationType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . classification_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidClassificationType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . category_eu = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidCategoryEu&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . class_eu = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidClassEu&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. operator_latitude) ; _tmp . put_i32_le (<span class="self">self </span>. operator_longitude) ; _tmp . put_f32_le (<span class="self">self </span>. area_ceiling) ; _tmp . put_f32_le (<span class="self">self </span>. area_floor) ; _tmp . put_f32_le (<span class="self">self </span>. operator_altitude_geo) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u16_le (<span class="self">self </span>. area_count) ; _tmp . put_u16_le (<span class="self">self </span>. area_radius) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. operator_location_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. classification_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. category_eu <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. class_eu <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA { <span class="kw">pub </span>time_boot_us : u64 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>q_estimated_delay_us : u32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>v_estimated_delay_us : u32 , <span class="kw">pub </span>feed_forward_angular_velocity_z : f32 , <span class="kw">pub </span>estimator_status : EstimatorStatusFlags , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>landed_state : MavLandedState , } <span class="kw">impl </span>AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_us = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . q_estimated_delay_us = buf . get_u32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . v_estimated_delay_us = buf . get_u32_le () ; _struct . feed_forward_angular_velocity_z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . estimator_status = EstimatorStatusFlags :: from_bits (tmp &amp; EstimatorStatusFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;EstimatorStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . landed_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavLandedState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_boot_us) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_u32_le (<span class="self">self </span>. q_estimated_delay_us) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_u32_le (<span class="self">self </span>. v_estimated_delay_us) ; _tmp . put_f32_le (<span class="self">self </span>. feed_forward_angular_velocity_z) ; _tmp . put_u16_le (<span class="self">self </span>. estimator_status . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. landed_state <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_SENSOR_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>xmag : f32 , <span class="kw">pub </span>ymag : f32 , <span class="kw">pub </span>zmag : f32 , <span class="kw">pub </span>abs_pressure : f32 , <span class="kw">pub </span>diff_pressure : f32 , <span class="kw">pub </span>pressure_alt : f32 , <span class="kw">pub </span>temperature : f32 , <span class="kw">pub </span>fields_updated : HilSensorUpdatedFlags , } <span class="kw">impl </span>HIL_SENSOR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">64usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . xmag = buf . get_f32_le () ; _struct . ymag = buf . get_f32_le () ; _struct . zmag = buf . get_f32_le () ; _struct . abs_pressure = buf . get_f32_le () ; _struct . diff_pressure = buf . get_f32_le () ; _struct . pressure_alt = buf . get_f32_le () ; _struct . temperature = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . fields_updated = HilSensorUpdatedFlags :: from_bits (tmp &amp; HilSensorUpdatedFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;HilSensorUpdatedFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_f32_le (<span class="self">self </span>. xmag) ; _tmp . put_f32_le (<span class="self">self </span>. ymag) ; _tmp . put_f32_le (<span class="self">self </span>. zmag) ; _tmp . put_f32_le (<span class="self">self </span>. abs_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. diff_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. pressure_alt) ; _tmp . put_f32_le (<span class="self">self </span>. temperature) ; _tmp . put_u32_le (<span class="self">self </span>. fields_updated . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WHEEL_DISTANCE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>distance : [f64 ; <span class="number">16</span>] , <span class="kw">pub </span>count : u8 , } <span class="kw">impl </span>WHEEL_DISTANCE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">137usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_f64_le () ; _struct . distance [idx] = val ; } _struct . count = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. distance { _tmp . put_f64_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPTICAL_FLOW_RAD_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>integration_time_us : u32 , <span class="kw">pub </span>integrated_x : f32 , <span class="kw">pub </span>integrated_y : f32 , <span class="kw">pub </span>integrated_xgyro : f32 , <span class="kw">pub </span>integrated_ygyro : f32 , <span class="kw">pub </span>integrated_zgyro : f32 , <span class="kw">pub </span>time_delta_distance_us : u32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>sensor_id : u8 , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>OPTICAL_FLOW_RAD_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . integration_time_us = buf . get_u32_le () ; _struct . integrated_x = buf . get_f32_le () ; _struct . integrated_y = buf . get_f32_le () ; _struct . integrated_xgyro = buf . get_f32_le () ; _struct . integrated_ygyro = buf . get_f32_le () ; _struct . integrated_zgyro = buf . get_f32_le () ; _struct . time_delta_distance_us = buf . get_u32_le () ; _struct . distance = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; _struct . sensor_id = buf . get_u8 () ; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. integration_time_us) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_x) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_y) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_zgyro) ; _tmp . put_u32_le (<span class="self">self </span>. time_delta_distance_us) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; _tmp . put_u8 (<span class="self">self </span>. sensor_id) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_ACK_DATA { <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_value : Vec &lt; u8 , <span class="number">128 </span>&gt; , <span class="kw">pub </span>param_type : MavParamExtType , <span class="kw">pub </span>param_result : ParamAck , } <span class="kw">impl </span>PARAM_EXT_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">146usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">128usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_value . push (val) . unwrap () ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamExtType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_result = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;ParamAck&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_value { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. param_result <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_QUATERNION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>q1 : f32 , <span class="kw">pub </span>q2 : f32 , <span class="kw">pub </span>q3 : f32 , <span class="kw">pub </span>q4 : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , } <span class="kw">impl </span>ATTITUDE_QUATERNION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . q1 = buf . get_f32_le () ; _struct . q2 = buf . get_f32_le () ; _struct . q3 = buf . get_f32_le () ; _struct . q4 = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. q1) ; _tmp . put_f32_le (<span class="self">self </span>. q2) ; _tmp . put_f32_le (<span class="self">self </span>. q3) ; _tmp . put_f32_le (<span class="self">self </span>. q4) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HYGROMETER_SENSOR_DATA { <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>humidity : u16 , <span class="kw">pub </span>id : u8 , } <span class="kw">impl </span>HYGROMETER_SENSOR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . temperature = buf . get_i16_le () ; _struct . humidity = buf . get_u16_le () ; _struct . id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; _tmp . put_u16_le (<span class="self">self </span>. humidity) ; _tmp . put_u8 (<span class="self">self </span>. id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_PRESSURE_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>press_abs : f32 , <span class="kw">pub </span>press_diff : f32 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>SCALED_PRESSURE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . press_abs = buf . get_f32_le () ; _struct . press_diff = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. press_abs) ; _tmp . put_f32_le (<span class="self">self </span>. press_diff) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TUNNEL_DATA { <span class="kw">pub </span>payload_type : MavTunnelPayloadType , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>payload_length : u8 , <span class="kw">pub </span>payload : Vec &lt; u8 , <span class="number">128 </span>&gt; , } <span class="kw">impl </span>TUNNEL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">133usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . payload_type = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavTunnelPayloadType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . payload_length = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">128usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . payload . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. payload_type <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. payload_length) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. payload { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_CHECK_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , } <span class="kw">impl </span>TERRAIN_CHECK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_CAPTURE_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>image_interval : f32 , <span class="kw">pub </span>recording_time_ms : u32 , <span class="kw">pub </span>available_capacity : f32 , <span class="kw">pub </span>image_status : u8 , <span class="kw">pub </span>video_status : u8 , } <span class="kw">impl </span>CAMERA_CAPTURE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . image_interval = buf . get_f32_le () ; _struct . recording_time_ms = buf . get_u32_le () ; _struct . available_capacity = buf . get_f32_le () ; _struct . image_status = buf . get_u8 () ; _struct . video_status = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. image_interval) ; _tmp . put_u32_le (<span class="self">self </span>. recording_time_ms) ; _tmp . put_f32_le (<span class="self">self </span>. available_capacity) ; _tmp . put_u8 (<span class="self">self </span>. image_status) ; _tmp . put_u8 (<span class="self">self </span>. video_status) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SUPPORTED_TUNES_DATA { <span class="kw">pub </span>format : TuneFormat , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>SUPPORTED_TUNES_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . format = TuneFormat :: from_bits (tmp &amp; TuneFormat :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;TuneFormat&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. format . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_REQUEST_READ_DATA { <span class="kw">pub </span>param_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , } <span class="kw">impl </span>PARAM_EXT_REQUEST_READ_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. param_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_INT_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>x : i32 , <span class="kw">pub </span>y : i32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , <span class="kw">pub </span>current : u8 , <span class="kw">pub </span>autocontinue : u8 , } <span class="kw">impl </span>COMMAND_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . x = buf . get_i32_le () ; _struct . y = buf . get_i32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . current = buf . get_u8 () ; _struct . autocontinue = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_i32_le (<span class="self">self </span>. x) ; _tmp . put_i32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. current) ; _tmp . put_u8 (<span class="self">self </span>. autocontinue) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVCAN_NODE_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>uptime_sec : u32 , <span class="kw">pub </span>vendor_specific_status_code : u16 , <span class="kw">pub </span>health : UavcanNodeHealth , <span class="kw">pub </span>mode : UavcanNodeMode , <span class="kw">pub </span>sub_mode : u8 , } <span class="kw">impl </span>UAVCAN_NODE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">17usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . uptime_sec = buf . get_u32_le () ; _struct . vendor_specific_status_code = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . health = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavcanNodeHealth&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavcanNodeMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . sub_mode = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. uptime_sec) ; _tmp . put_u16_le (<span class="self">self </span>. vendor_specific_status_code) ; _tmp . put_u8 (<span class="self">self </span>. health <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. sub_mode) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTOPILOT_VERSION_DATA { <span class="kw">pub </span>capabilities : MavProtocolCapability , <span class="kw">pub </span>uid : u64 , <span class="kw">pub </span>flight_sw_version : u32 , <span class="kw">pub </span>middleware_sw_version : u32 , <span class="kw">pub </span>os_sw_version : u32 , <span class="kw">pub </span>board_version : u32 , <span class="kw">pub </span>vendor_id : u16 , <span class="kw">pub </span>product_id : u16 , <span class="kw">pub </span>flight_custom_version : [u8 ; <span class="number">8</span>] , <span class="kw">pub </span>middleware_custom_version : [u8 ; <span class="number">8</span>] , <span class="kw">pub </span>os_custom_version : [u8 ; <span class="number">8</span>] , } <span class="kw">impl </span>AUTOPILOT_VERSION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">60usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u64_le () ; _struct . capabilities = MavProtocolCapability :: from_bits (tmp &amp; MavProtocolCapability :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavProtocolCapability&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . uid = buf . get_u64_le () ; _struct . flight_sw_version = buf . get_u32_le () ; _struct . middleware_sw_version = buf . get_u32_le () ; _struct . os_sw_version = buf . get_u32_le () ; _struct . board_version = buf . get_u32_le () ; _struct . vendor_id = buf . get_u16_le () ; _struct . product_id = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . flight_custom_version [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . middleware_custom_version [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . os_custom_version [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. capabilities . bits ()) ; _tmp . put_u64_le (<span class="self">self </span>. uid) ; _tmp . put_u32_le (<span class="self">self </span>. flight_sw_version) ; _tmp . put_u32_le (<span class="self">self </span>. middleware_sw_version) ; _tmp . put_u32_le (<span class="self">self </span>. os_sw_version) ; _tmp . put_u32_le (<span class="self">self </span>. board_version) ; _tmp . put_u16_le (<span class="self">self </span>. vendor_id) ; _tmp . put_u16_le (<span class="self">self </span>. product_id) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. flight_custom_version { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. middleware_custom_version { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. os_custom_version { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOCAL_POSITION_NED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , } <span class="kw">impl </span>LOCAL_POSITION_NED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_WRITE_PARTIAL_LIST_DATA { <span class="kw">pub </span>start_index : i16 , <span class="kw">pub </span>end_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_WRITE_PARTIAL_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . start_index = buf . get_i16_le () ; _struct . end_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. start_index) ; _tmp . put_i16_le (<span class="self">self </span>. end_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LANDING_TARGET_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>angle_x : f32 , <span class="kw">pub </span>angle_y : f32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>size_x : f32 , <span class="kw">pub </span>size_y : f32 , <span class="kw">pub </span>target_num : u8 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>LANDING_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">30usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . angle_x = buf . get_f32_le () ; _struct . angle_y = buf . get_f32_le () ; _struct . distance = buf . get_f32_le () ; _struct . size_x = buf . get_f32_le () ; _struct . size_y = buf . get_f32_le () ; _struct . target_num = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. angle_x) ; _tmp . put_f32_le (<span class="self">self </span>. angle_y) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_f32_le (<span class="self">self </span>. size_x) ; _tmp . put_f32_le (<span class="self">self </span>. size_y) ; _tmp . put_u8 (<span class="self">self </span>. target_num) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , } <span class="kw">impl </span>GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_ATTITUDE_TARGET_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>body_roll_rate : f32 , <span class="kw">pub </span>body_pitch_rate : f32 , <span class="kw">pub </span>body_yaw_rate : f32 , <span class="kw">pub </span>thrust : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>type_mask : AttitudeTargetTypemask , } <span class="kw">impl </span>SET_ATTITUDE_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">39usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . body_roll_rate = buf . get_f32_le () ; _struct . body_pitch_rate = buf . get_f32_le () ; _struct . body_yaw_rate = buf . get_f32_le () ; _struct . thrust = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type_mask = AttitudeTargetTypemask :: from_bits (tmp &amp; AttitudeTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AttitudeTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. body_roll_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_yaw_rate) ; _tmp . put_f32_le (<span class="self">self </span>. thrust) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. type_mask . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>rpm : [i32 ; <span class="number">4</span>] , <span class="kw">pub </span>voltage : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>current : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>index : u8 , } <span class="kw">impl </span>ESC_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">57usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_i32_le () ; _struct . rpm [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . voltage [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . current [idx] = val ; } _struct . index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rpm { _tmp . put_i32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltage { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. current { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_ARM_STATUS_DATA { <span class="kw">pub </span>status : MavOdidArmStatus , <span class="kw">pub </span>error : Vec &lt; u8 , <span class="number">50 </span>&gt; , } <span class="kw">impl </span>OPEN_DRONE_ID_ARM_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidArmStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">50usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . error . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. error { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_STATE_QUATERNION_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>attitude_quaternion : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>ind_airspeed : u16 , <span class="kw">pub </span>true_airspeed : u16 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , } <span class="kw">impl </span>HIL_STATE_QUATERNION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">64usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . attitude_quaternion [idx] = val ; } _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . ind_airspeed = buf . get_u16_le () ; _struct . true_airspeed = buf . get_u16_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. attitude_quaternion { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_u16_le (<span class="self">self </span>. ind_airspeed) ; _tmp . put_u16_le (<span class="self">self </span>. true_airspeed) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS2_RTK_DATA { <span class="kw">pub </span>time_last_baseline_ms : u32 , <span class="kw">pub </span>tow : u32 , <span class="kw">pub </span>baseline_a_mm : i32 , <span class="kw">pub </span>baseline_b_mm : i32 , <span class="kw">pub </span>baseline_c_mm : i32 , <span class="kw">pub </span>accuracy : u32 , <span class="kw">pub </span>iar_num_hypotheses : i32 , <span class="kw">pub </span>wn : u16 , <span class="kw">pub </span>rtk_receiver_id : u8 , <span class="kw">pub </span>rtk_health : u8 , <span class="kw">pub </span>rtk_rate : u8 , <span class="kw">pub </span>nsats : u8 , <span class="kw">pub </span>baseline_coords_type : RtkBaselineCoordinateSystem , } <span class="kw">impl </span>GPS2_RTK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_last_baseline_ms = buf . get_u32_le () ; _struct . tow = buf . get_u32_le () ; _struct . baseline_a_mm = buf . get_i32_le () ; _struct . baseline_b_mm = buf . get_i32_le () ; _struct . baseline_c_mm = buf . get_i32_le () ; _struct . accuracy = buf . get_u32_le () ; _struct . iar_num_hypotheses = buf . get_i32_le () ; _struct . wn = buf . get_u16_le () ; _struct . rtk_receiver_id = buf . get_u8 () ; _struct . rtk_health = buf . get_u8 () ; _struct . rtk_rate = buf . get_u8 () ; _struct . nsats = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . baseline_coords_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;RtkBaselineCoordinateSystem&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_last_baseline_ms) ; _tmp . put_u32_le (<span class="self">self </span>. tow) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_a_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_b_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_c_mm) ; _tmp . put_u32_le (<span class="self">self </span>. accuracy) ; _tmp . put_i32_le (<span class="self">self </span>. iar_num_hypotheses) ; _tmp . put_u16_le (<span class="self">self </span>. wn) ; _tmp . put_u8 (<span class="self">self </span>. rtk_receiver_id) ; _tmp . put_u8 (<span class="self">self </span>. rtk_health) ; _tmp . put_u8 (<span class="self">self </span>. rtk_rate) ; _tmp . put_u8 (<span class="self">self </span>. nsats) ; _tmp . put_u8 (<span class="self">self </span>. baseline_coords_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat_int : i32 , <span class="kw">pub </span>lon_int : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat_int = buf . get_i32_le () ; _struct . lon_int = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat_int) ; _tmp . put_i32_le (<span class="self">self </span>. lon_int) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_SET_DATA { <span class="kw">pub </span>param_value : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_type : MavParamType , } <span class="kw">impl </span>PARAM_SET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">23usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_value = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param_value) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SETUP_SIGNING_DATA { <span class="kw">pub </span>initial_timestamp : u64 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>secret_key : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>SETUP_SIGNING_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . initial_timestamp = buf . get_u64_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . secret_key [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. initial_timestamp) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. secret_key { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_CURRENT_DATA { <span class="kw">pub </span>seq : u16 , } <span class="kw">impl </span>MISSION_CURRENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MANUAL_SETPOINT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>thrust : f32 , <span class="kw">pub </span>mode_switch : u8 , <span class="kw">pub </span>manual_override_switch : u8 , } <span class="kw">impl </span>MANUAL_SETPOINT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . thrust = buf . get_f32_le () ; _struct . mode_switch = buf . get_u8 () ; _struct . manual_override_switch = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. thrust) ; _tmp . put_u8 (<span class="self">self </span>. mode_switch) ; _tmp . put_u8 (<span class="self">self </span>. manual_override_switch) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GLOBAL_POSITION_INT_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>covariance : Vec &lt; f32 , <span class="number">36 </span>&gt; , <span class="kw">pub </span>estimator_type : MavEstimatorType , } <span class="kw">impl </span>GLOBAL_POSITION_INT_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">181usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">36usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . covariance . push (val) . unwrap () ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . estimator_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavEstimatorType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. covariance { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. estimator_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>V2_EXTENSION_DATA { <span class="kw">pub </span>message_type : u16 , <span class="kw">pub </span>target_network : u8 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>payload : Vec &lt; u8 , <span class="number">249 </span>&gt; , } <span class="kw">impl </span>V2_EXTENSION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">254usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . message_type = buf . get_u16_le () ; _struct . target_network = buf . get_u8 () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">249usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . payload . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. message_type) ; _tmp . put_u8 (<span class="self">self </span>. target_network) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. payload { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COLLISION_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>time_to_minimum_delta : f32 , <span class="kw">pub </span>altitude_minimum_delta : f32 , <span class="kw">pub </span>horizontal_minimum_delta : f32 , <span class="kw">pub </span>src : MavCollisionSrc , <span class="kw">pub </span>action : MavCollisionAction , <span class="kw">pub </span>threat_level : MavCollisionThreatLevel , } <span class="kw">impl </span>COLLISION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">19usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . time_to_minimum_delta = buf . get_f32_le () ; _struct . altitude_minimum_delta = buf . get_f32_le () ; _struct . horizontal_minimum_delta = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . src = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCollisionSrc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . action = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCollisionAction&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . threat_level = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCollisionThreatLevel&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_f32_le (<span class="self">self </span>. time_to_minimum_delta) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_minimum_delta) ; _tmp . put_f32_le (<span class="self">self </span>. horizontal_minimum_delta) ; _tmp . put_u8 (<span class="self">self </span>. src <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. action <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. threat_level <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FOLLOW_TARGET_DATA { <span class="kw">pub </span>timestamp : u64 , <span class="kw">pub </span>custom_state : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>vel : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>acc : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>attitude_q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>rates : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>position_cov : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>est_capabilities : u8 , } <span class="kw">impl </span>FOLLOW_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">93usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u64_le () ; _struct . custom_state = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">3usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . vel [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">3usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . acc [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . attitude_q [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">3usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . rates [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">3usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . position_cov [idx] = val ; } _struct . est_capabilities = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. timestamp) ; _tmp . put_u64_le (<span class="self">self </span>. custom_state) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. attitude_q { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rates { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. position_cov { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. est_capabilities) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_LOCATION_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude_barometric : f32 , <span class="kw">pub </span>altitude_geodetic : f32 , <span class="kw">pub </span>height : f32 , <span class="kw">pub </span>timestamp : f32 , <span class="kw">pub </span>direction : u16 , <span class="kw">pub </span>speed_horizontal : u16 , <span class="kw">pub </span>speed_vertical : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>status : MavOdidStatus , <span class="kw">pub </span>height_reference : MavOdidHeightRef , <span class="kw">pub </span>horizontal_accuracy : MavOdidHorAcc , <span class="kw">pub </span>vertical_accuracy : MavOdidVerAcc , <span class="kw">pub </span>barometer_accuracy : MavOdidVerAcc , <span class="kw">pub </span>speed_accuracy : MavOdidSpeedAcc , <span class="kw">pub </span>timestamp_accuracy : MavOdidTimeAcc , } <span class="kw">impl </span>OPEN_DRONE_ID_LOCATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">59usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude_barometric = buf . get_f32_le () ; _struct . altitude_geodetic = buf . get_f32_le () ; _struct . height = buf . get_f32_le () ; _struct . timestamp = buf . get_f32_le () ; _struct . direction = buf . get_u16_le () ; _struct . speed_horizontal = buf . get_u16_le () ; _struct . speed_vertical = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . height_reference = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidHeightRef&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . horizontal_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidHorAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . vertical_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidVerAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . barometer_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidVerAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . speed_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidSpeedAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . timestamp_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidTimeAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_barometric) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_geodetic) ; _tmp . put_f32_le (<span class="self">self </span>. height) ; _tmp . put_f32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u16_le (<span class="self">self </span>. direction) ; _tmp . put_u16_le (<span class="self">self </span>. speed_horizontal) ; _tmp . put_i16_le (<span class="self">self </span>. speed_vertical) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. height_reference <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. horizontal_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. vertical_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. barometer_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. speed_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. timestamp_accuracy <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPTICAL_FLOW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>flow_comp_m_x : f32 , <span class="kw">pub </span>flow_comp_m_y : f32 , <span class="kw">pub </span>ground_distance : f32 , <span class="kw">pub </span>flow_x : i16 , <span class="kw">pub </span>flow_y : i16 , <span class="kw">pub </span>sensor_id : u8 , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>OPTICAL_FLOW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">26usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . flow_comp_m_x = buf . get_f32_le () ; _struct . flow_comp_m_y = buf . get_f32_le () ; _struct . ground_distance = buf . get_f32_le () ; _struct . flow_x = buf . get_i16_le () ; _struct . flow_y = buf . get_i16_le () ; _struct . sensor_id = buf . get_u8 () ; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. flow_comp_m_x) ; _tmp . put_f32_le (<span class="self">self </span>. flow_comp_m_y) ; _tmp . put_f32_le (<span class="self">self </span>. ground_distance) ; _tmp . put_i16_le (<span class="self">self </span>. flow_x) ; _tmp . put_i16_le (<span class="self">self </span>. flow_y) ; _tmp . put_u8 (<span class="self">self </span>. sensor_id) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CHANGE_OPERATOR_CONTROL_ACK_DATA { <span class="kw">pub </span>gcs_system_id : u8 , <span class="kw">pub </span>control_request : u8 , <span class="kw">pub </span>ack : u8 , } <span class="kw">impl </span>CHANGE_OPERATOR_CONTROL_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . gcs_system_id = buf . get_u8 () ; _struct . control_request = buf . get_u8 () ; _struct . ack = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. gcs_system_id) ; _tmp . put_u8 (<span class="self">self </span>. control_request) ; _tmp . put_u8 (<span class="self">self </span>. ack) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVIONIX_ADSB_OUT_DYNAMIC_DATA { <span class="kw">pub </span>utcTime : u32 , <span class="kw">pub </span>gpsLat : i32 , <span class="kw">pub </span>gpsLon : i32 , <span class="kw">pub </span>gpsAlt : i32 , <span class="kw">pub </span>baroAltMSL : i32 , <span class="kw">pub </span>accuracyHor : u32 , <span class="kw">pub </span>accuracyVert : u16 , <span class="kw">pub </span>accuracyVel : u16 , <span class="kw">pub </span>velVert : i16 , <span class="kw">pub </span>velNS : i16 , <span class="kw">pub </span>VelEW : i16 , <span class="kw">pub </span>state : UavionixAdsbOutDynamicState , <span class="kw">pub </span>squawk : u16 , <span class="kw">pub </span>gpsFix : UavionixAdsbOutDynamicGpsFix , <span class="kw">pub </span>numSats : u8 , <span class="kw">pub </span>emergencyStatus : UavionixAdsbEmergencyStatus , } <span class="kw">impl </span>UAVIONIX_ADSB_OUT_DYNAMIC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">41usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . utcTime = buf . get_u32_le () ; _struct . gpsLat = buf . get_i32_le () ; _struct . gpsLon = buf . get_i32_le () ; _struct . gpsAlt = buf . get_i32_le () ; _struct . baroAltMSL = buf . get_i32_le () ; _struct . accuracyHor = buf . get_u32_le () ; _struct . accuracyVert = buf . get_u16_le () ; _struct . accuracyVel = buf . get_u16_le () ; _struct . velVert = buf . get_i16_le () ; _struct . velNS = buf . get_i16_le () ; _struct . VelEW = buf . get_i16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . state = UavionixAdsbOutDynamicState :: from_bits (tmp &amp; UavionixAdsbOutDynamicState :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UavionixAdsbOutDynamicState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . squawk = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gpsFix = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutDynamicGpsFix&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . numSats = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . emergencyStatus = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbEmergencyStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. utcTime) ; _tmp . put_i32_le (<span class="self">self </span>. gpsLat) ; _tmp . put_i32_le (<span class="self">self </span>. gpsLon) ; _tmp . put_i32_le (<span class="self">self </span>. gpsAlt) ; _tmp . put_i32_le (<span class="self">self </span>. baroAltMSL) ; _tmp . put_u32_le (<span class="self">self </span>. accuracyHor) ; _tmp . put_u16_le (<span class="self">self </span>. accuracyVert) ; _tmp . put_u16_le (<span class="self">self </span>. accuracyVel) ; _tmp . put_i16_le (<span class="self">self </span>. velVert) ; _tmp . put_i16_le (<span class="self">self </span>. velNS) ; _tmp . put_i16_le (<span class="self">self </span>. VelEW) ; _tmp . put_u16_le (<span class="self">self </span>. state . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. squawk) ; _tmp . put_u8 (<span class="self">self </span>. gpsFix <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. numSats) ; _tmp . put_u8 (<span class="self">self </span>. emergencyStatus <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOCAL_POSITION_NED_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>ax : f32 , <span class="kw">pub </span>ay : f32 , <span class="kw">pub </span>az : f32 , <span class="kw">pub </span>covariance : Vec &lt; f32 , <span class="number">45 </span>&gt; , <span class="kw">pub </span>estimator_type : MavEstimatorType , } <span class="kw">impl </span>LOCAL_POSITION_NED_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">225usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . ax = buf . get_f32_le () ; _struct . ay = buf . get_f32_le () ; _struct . az = buf . get_f32_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">45usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . covariance . push (val) . unwrap () ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . estimator_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavEstimatorType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. ax) ; _tmp . put_f32_le (<span class="self">self </span>. ay) ; _tmp . put_f32_le (<span class="self">self </span>. az) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. covariance { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. estimator_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMPONENT_METADATA_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>file_crc : u32 , <span class="kw">pub </span>uri : Vec &lt; u8 , <span class="number">100 </span>&gt; , } <span class="kw">impl </span>COMPONENT_METADATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">108usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . file_crc = buf . get_u32_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">100usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . uri . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. file_crc) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOGGING_ACK_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOGGING_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_BASIC_ID_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>id_type : MavOdidIdType , <span class="kw">pub </span>ua_type : MavOdidUaType , <span class="kw">pub </span>uas_id : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_BASIC_ID_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . id_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidIdType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . ua_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidUaType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . uas_id [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. id_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. ua_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uas_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA_STREAM_DATA { <span class="kw">pub </span>message_rate : u16 , <span class="kw">pub </span>stream_id : u8 , <span class="kw">pub </span>on_off : u8 , } <span class="kw">impl </span>DATA_STREAM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . message_rate = buf . get_u16_le () ; _struct . stream_id = buf . get_u8 () ; _struct . on_off = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. message_rate) ; _tmp . put_u8 (<span class="self">self </span>. stream_id) ; _tmp . put_u8 (<span class="self">self </span>. on_off) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_DEVICE_SET_ATTITUDE_DATA { <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>angular_velocity_x : f32 , <span class="kw">pub </span>angular_velocity_y : f32 , <span class="kw">pub </span>angular_velocity_z : f32 , <span class="kw">pub </span>flags : GimbalDeviceFlags , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_DEVICE_SET_ATTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . angular_velocity_x = buf . get_f32_le () ; _struct . angular_velocity_y = buf . get_f32_le () ; _struct . angular_velocity_z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = GimbalDeviceFlags :: from_bits (tmp &amp; GimbalDeviceFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_z) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>STORAGE_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>total_capacity : f32 , <span class="kw">pub </span>used_capacity : f32 , <span class="kw">pub </span>available_capacity : f32 , <span class="kw">pub </span>read_speed : f32 , <span class="kw">pub </span>write_speed : f32 , <span class="kw">pub </span>storage_id : u8 , <span class="kw">pub </span>storage_count : u8 , <span class="kw">pub </span>status : StorageStatus , } <span class="kw">impl </span>STORAGE_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">27usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . total_capacity = buf . get_f32_le () ; _struct . used_capacity = buf . get_f32_le () ; _struct . available_capacity = buf . get_f32_le () ; _struct . read_speed = buf . get_f32_le () ; _struct . write_speed = buf . get_f32_le () ; _struct . storage_id = buf . get_u8 () ; _struct . storage_count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;StorageStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. total_capacity) ; _tmp . put_f32_le (<span class="self">self </span>. used_capacity) ; _tmp . put_f32_le (<span class="self">self </span>. available_capacity) ; _tmp . put_f32_le (<span class="self">self </span>. read_speed) ; _tmp . put_f32_le (<span class="self">self </span>. write_speed) ; _tmp . put_u8 (<span class="self">self </span>. storage_id) ; _tmp . put_u8 (<span class="self">self </span>. storage_count) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_PARTIAL_LIST_DATA { <span class="kw">pub </span>start_index : i16 , <span class="kw">pub </span>end_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_PARTIAL_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . start_index = buf . get_i16_le () ; _struct . end_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. start_index) ; _tmp . put_i16_le (<span class="self">self </span>. end_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_TRIGGER_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>seq : u32 , } <span class="kw">impl </span>CAMERA_TRIGGER_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . seq = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. seq) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RAW_RPM_DATA { <span class="kw">pub </span>frequency : f32 , <span class="kw">pub </span>index : u8 , } <span class="kw">impl </span>RAW_RPM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . frequency = buf . get_f32_le () ; _struct . index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. frequency) ; _tmp . put_u8 (<span class="self">self </span>. index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PLAY_TUNE_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>tune : [u8 ; <span class="number">30</span>] , } <span class="kw">impl </span>PLAY_TUNE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">30usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . tune [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. tune { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_CONTROLS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>roll_ailerons : f32 , <span class="kw">pub </span>pitch_elevator : f32 , <span class="kw">pub </span>yaw_rudder : f32 , <span class="kw">pub </span>throttle : f32 , <span class="kw">pub </span>aux1 : f32 , <span class="kw">pub </span>aux2 : f32 , <span class="kw">pub </span>aux3 : f32 , <span class="kw">pub </span>aux4 : f32 , <span class="kw">pub </span>mode : MavMode , <span class="kw">pub </span>nav_mode : u8 , } <span class="kw">impl </span>HIL_CONTROLS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . roll_ailerons = buf . get_f32_le () ; _struct . pitch_elevator = buf . get_f32_le () ; _struct . yaw_rudder = buf . get_f32_le () ; _struct . throttle = buf . get_f32_le () ; _struct . aux1 = buf . get_f32_le () ; _struct . aux2 = buf . get_f32_le () ; _struct . aux3 = buf . get_f32_le () ; _struct . aux4 = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . nav_mode = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. roll_ailerons) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_elevator) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rudder) ; _tmp . put_f32_le (<span class="self">self </span>. throttle) ; _tmp . put_f32_le (<span class="self">self </span>. aux1) ; _tmp . put_f32_le (<span class="self">self </span>. aux2) ; _tmp . put_f32_le (<span class="self">self </span>. aux3) ; _tmp . put_f32_le (<span class="self">self </span>. aux4) ; _tmp . put_u8 (<span class="self">self </span>. mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. nav_mode) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RADIO_STATUS_DATA { <span class="kw">pub </span>rxerrors : u16 , <span class="kw">pub </span>fixed : u16 , <span class="kw">pub </span>rssi : u8 , <span class="kw">pub </span>remrssi : u8 , <span class="kw">pub </span>txbuf : u8 , <span class="kw">pub </span>noise : u8 , <span class="kw">pub </span>remnoise : u8 , } <span class="kw">impl </span>RADIO_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . rxerrors = buf . get_u16_le () ; _struct . fixed = buf . get_u16_le () ; _struct . rssi = buf . get_u8 () ; _struct . remrssi = buf . get_u8 () ; _struct . txbuf = buf . get_u8 () ; _struct . noise = buf . get_u8 () ; _struct . remnoise = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. rxerrors) ; _tmp . put_u16_le (<span class="self">self </span>. fixed) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; _tmp . put_u8 (<span class="self">self </span>. remrssi) ; _tmp . put_u8 (<span class="self">self </span>. txbuf) ; _tmp . put_u8 (<span class="self">self </span>. noise) ; _tmp . put_u8 (<span class="self">self </span>. remnoise) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_ENTRY_DATA { <span class="kw">pub </span>time_utc : u32 , <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>id : u16 , <span class="kw">pub </span>num_logs : u16 , <span class="kw">pub </span>last_log_num : u16 , } <span class="kw">impl </span>LOG_ENTRY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_utc = buf . get_u32_le () ; _struct . size = buf . get_u32_le () ; _struct . id = buf . get_u16_le () ; _struct . num_logs = buf . get_u16_le () ; _struct . last_log_num = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_utc) ; _tmp . put_u32_le (<span class="self">self </span>. size) ; _tmp . put_u16_le (<span class="self">self </span>. id) ; _tmp . put_u16_le (<span class="self">self </span>. num_logs) ; _tmp . put_u16_le (<span class="self">self </span>. last_log_num) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>REQUEST_DATA_STREAM_DATA { <span class="kw">pub </span>req_message_rate : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>req_stream_id : u8 , <span class="kw">pub </span>start_stop : u8 , } <span class="kw">impl </span>REQUEST_DATA_STREAM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . req_message_rate = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . req_stream_id = buf . get_u8 () ; _struct . start_stop = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. req_message_rate) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. req_stream_id) ; _tmp . put_u8 (<span class="self">self </span>. start_stop) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VISION_SPEED_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , } <span class="kw">impl </span>VISION_SPEED_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , } <span class="kw">impl </span>ATTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_SELF_ID_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>description_type : MavOdidDescType , <span class="kw">pub </span>description : [u8 ; <span class="number">23</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_SELF_ID_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">46usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . description_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidDescType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">23usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . description [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. description_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. description { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_ACK_DATA { <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>result : MavResult , } <span class="kw">impl </span>COMMAND_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . result = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavResult&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. result <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VIBRATION_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>vibration_x : f32 , <span class="kw">pub </span>vibration_y : f32 , <span class="kw">pub </span>vibration_z : f32 , <span class="kw">pub </span>clipping_0 : u32 , <span class="kw">pub </span>clipping_1 : u32 , <span class="kw">pub </span>clipping_2 : u32 , } <span class="kw">impl </span>VIBRATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . vibration_x = buf . get_f32_le () ; _struct . vibration_y = buf . get_f32_le () ; _struct . vibration_z = buf . get_f32_le () ; _struct . clipping_0 = buf . get_u32_le () ; _struct . clipping_1 = buf . get_u32_le () ; _struct . clipping_2 = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. vibration_x) ; _tmp . put_f32_le (<span class="self">self </span>. vibration_y) ; _tmp . put_f32_le (<span class="self">self </span>. vibration_z) ; _tmp . put_u32_le (<span class="self">self </span>. clipping_0) ; _tmp . put_u32_le (<span class="self">self </span>. clipping_1) ; _tmp . put_u32_le (<span class="self">self </span>. clipping_2) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VIDEO_STREAM_INFORMATION_DATA { <span class="kw">pub </span>framerate : f32 , <span class="kw">pub </span>bitrate : u32 , <span class="kw">pub </span>flags : VideoStreamStatusFlags , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>rotation : u16 , <span class="kw">pub </span>hfov : u16 , <span class="kw">pub </span>stream_id : u8 , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>mavtype : VideoStreamType , <span class="kw">pub </span>name : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>uri : Vec &lt; u8 , <span class="number">160 </span>&gt; , } <span class="kw">impl </span>VIDEO_STREAM_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">213usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . framerate = buf . get_f32_le () ; _struct . bitrate = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;VideoStreamStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . rotation = buf . get_u16_le () ; _struct . hfov = buf . get_u16_le () ; _struct . stream_id = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;VideoStreamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name [idx] = val ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">160usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . uri . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. framerate) ; _tmp . put_u32_le (<span class="self">self </span>. bitrate) ; _tmp . put_u16_le (<span class="self">self </span>. flags <span class="kw">as </span>u16) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. rotation) ; _tmp . put_u16_le (<span class="self">self </span>. hfov) ; _tmp . put_u8 (<span class="self">self </span>. stream_id) ; _tmp . put_u8 (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>pos_x : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>pos_y : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>pos_z : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>vel_x : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>vel_y : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>vel_z : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>acc_x : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>acc_y : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>acc_z : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>pos_yaw : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>vel_yaw : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>command : [u16 ; <span class="number">5</span>] , <span class="kw">pub </span>valid_points : u8 , } <span class="kw">impl </span>TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">239usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_x [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_y [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_z [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . vel_x [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . vel_y [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . vel_z [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . acc_x [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . acc_y [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . acc_z [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_yaw [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . vel_yaw [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">5usize </span>{ <span class="kw">let </span>val = buf . get_u16_le () ; _struct . command [idx] = val ; } _struct . valid_points = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_yaw { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_yaw { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. command { _tmp . put_u16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. valid_points) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMPONENT_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>general_metadata_file_crc : u32 , <span class="kw">pub </span>peripherals_metadata_file_crc : u32 , <span class="kw">pub </span>general_metadata_uri : Vec &lt; u8 , <span class="number">100 </span>&gt; , <span class="kw">pub </span>peripherals_metadata_uri : Vec &lt; u8 , <span class="number">100 </span>&gt; , } <span class="kw">impl </span>COMPONENT_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">212usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . general_metadata_file_crc = buf . get_u32_le () ; _struct . peripherals_metadata_file_crc = buf . get_u32_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">100usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . general_metadata_uri . push (val) . unwrap () ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">100usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . peripherals_metadata_uri . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. general_metadata_file_crc) ; _tmp . put_u32_le (<span class="self">self </span>. peripherals_metadata_file_crc) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. general_metadata_uri { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. peripherals_metadata_uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TIME_ESTIMATE_TO_TARGET_DATA { <span class="kw">pub </span>safe_return : i32 , <span class="kw">pub </span>land : i32 , <span class="kw">pub </span>mission_next_item : i32 , <span class="kw">pub </span>mission_end : i32 , <span class="kw">pub </span>commanded_action : i32 , } <span class="kw">impl </span>TIME_ESTIMATE_TO_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . safe_return = buf . get_i32_le () ; _struct . land = buf . get_i32_le () ; _struct . mission_next_item = buf . get_i32_le () ; _struct . mission_end = buf . get_i32_le () ; _struct . commanded_action = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. safe_return) ; _tmp . put_i32_le (<span class="self">self </span>. land) ; _tmp . put_i32_le (<span class="self">self </span>. mission_next_item) ; _tmp . put_i32_le (<span class="self">self </span>. mission_end) ; _tmp . put_i32_le (<span class="self">self </span>. commanded_action) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ITEM_INT_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>x : i32 , <span class="kw">pub </span>y : i32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , <span class="kw">pub </span>current : u8 , <span class="kw">pub </span>autocontinue : u8 , } <span class="kw">impl </span>MISSION_ITEM_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . x = buf . get_i32_le () ; _struct . y = buf . get_i32_le () ; _struct . z = buf . get_f32_le () ; _struct . seq = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . current = buf . get_u8 () ; _struct . autocontinue = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_i32_le (<span class="self">self </span>. x) ; _tmp . put_i32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. current) ; _tmp . put_u8 (<span class="self">self </span>. autocontinue) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EVENT_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>event_time_boot_ms : u32 , <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>destination_component : u8 , <span class="kw">pub </span>destination_system : u8 , <span class="kw">pub </span>log_levels : u8 , <span class="kw">pub </span>arguments : Vec &lt; u8 , <span class="number">40 </span>&gt; , } <span class="kw">impl </span>EVENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . event_time_boot_ms = buf . get_u32_le () ; _struct . sequence = buf . get_u16_le () ; _struct . destination_component = buf . get_u8 () ; _struct . destination_system = buf . get_u8 () ; _struct . log_levels = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">40usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . arguments . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_u32_le (<span class="self">self </span>. event_time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. destination_component) ; _tmp . put_u8 (<span class="self">self </span>. destination_system) ; _tmp . put_u8 (<span class="self">self </span>. log_levels) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. arguments { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_REQUEST_END_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_REQUEST_END_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_ACTUATOR_CONTROLS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>flags : u64 , <span class="kw">pub </span>controls : [f32 ; <span class="number">16</span>] , <span class="kw">pub </span>mode : MavModeFlag , } <span class="kw">impl </span>HIL_ACTUATOR_CONTROLS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">81usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . flags = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . controls [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode = MavModeFlag :: from_bits (tmp &amp; MavModeFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavModeFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u64_le (<span class="self">self </span>. flags) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. controls { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. mode . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_REQUEST_LIST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>PARAM_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RAW_IMU_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>RAW_IMU_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">26usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_COUNT_DATA { <span class="kw">pub </span>count : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_COUNT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . count = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SAFETY_SET_ALLOWED_AREA_DATA { <span class="kw">pub </span>p1x : f32 , <span class="kw">pub </span>p1y : f32 , <span class="kw">pub </span>p1z : f32 , <span class="kw">pub </span>p2x : f32 , <span class="kw">pub </span>p2y : f32 , <span class="kw">pub </span>p2z : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>SAFETY_SET_ALLOWED_AREA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">27usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . p1x = buf . get_f32_le () ; _struct . p1y = buf . get_f32_le () ; _struct . p1z = buf . get_f32_le () ; _struct . p2x = buf . get_f32_le () ; _struct . p2y = buf . get_f32_le () ; _struct . p2z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. p1x) ; _tmp . put_f32_le (<span class="self">self </span>. p1y) ; _tmp . put_f32_le (<span class="self">self </span>. p1z) ; _tmp . put_f32_le (<span class="self">self </span>. p2x) ; _tmp . put_f32_le (<span class="self">self </span>. p2y) ; _tmp . put_f32_le (<span class="self">self </span>. p2z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA { <span class="kw">pub </span>rfHealth : UavionixAdsbRfHealth , } <span class="kw">impl </span>UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">1usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . rfHealth = UavionixAdsbRfHealth :: from_bits (tmp &amp; UavionixAdsbRfHealth :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UavionixAdsbRfHealth&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. rfHealth . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_DEVICE_INFORMATION_DATA { <span class="kw">pub </span>uid : u64 , <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>firmware_version : u32 , <span class="kw">pub </span>hardware_version : u32 , <span class="kw">pub </span>roll_min : f32 , <span class="kw">pub </span>roll_max : f32 , <span class="kw">pub </span>pitch_min : f32 , <span class="kw">pub </span>pitch_max : f32 , <span class="kw">pub </span>yaw_min : f32 , <span class="kw">pub </span>yaw_max : f32 , <span class="kw">pub </span>cap_flags : GimbalDeviceCapFlags , <span class="kw">pub </span>custom_cap_flags : u16 , <span class="kw">pub </span>vendor_name : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>model_name : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>custom_name : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>GIMBAL_DEVICE_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">144usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . uid = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . firmware_version = buf . get_u32_le () ; _struct . hardware_version = buf . get_u32_le () ; _struct . roll_min = buf . get_f32_le () ; _struct . roll_max = buf . get_f32_le () ; _struct . pitch_min = buf . get_f32_le () ; _struct . pitch_max = buf . get_f32_le () ; _struct . yaw_min = buf . get_f32_le () ; _struct . yaw_max = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . cap_flags = GimbalDeviceCapFlags :: from_bits (tmp &amp; GimbalDeviceCapFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceCapFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . custom_cap_flags = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . vendor_name [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . model_name [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . custom_name [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. uid) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. firmware_version) ; _tmp . put_u32_le (<span class="self">self </span>. hardware_version) ; _tmp . put_f32_le (<span class="self">self </span>. roll_min) ; _tmp . put_f32_le (<span class="self">self </span>. roll_max) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_min) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_max) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_min) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_max) ; _tmp . put_u16_le (<span class="self">self </span>. cap_flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. custom_cap_flags) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vendor_name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. model_name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. custom_name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CELLULAR_CONFIG_DATA { <span class="kw">pub </span>enable_lte : u8 , <span class="kw">pub </span>enable_pin : u8 , <span class="kw">pub </span>pin : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>new_pin : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>apn : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>puk : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>roaming : u8 , <span class="kw">pub </span>response : CellularConfigResponse , } <span class="kw">impl </span>CELLULAR_CONFIG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">84usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . enable_lte = buf . get_u8 () ; _struct . enable_pin = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . pin [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . new_pin [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . apn [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . puk [idx] = val ; } _struct . roaming = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . response = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularConfigResponse&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. enable_lte) ; _tmp . put_u8 (<span class="self">self </span>. enable_pin) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pin { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. new_pin { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. apn { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. puk { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. roaming) ; _tmp . put_u8 (<span class="self">self </span>. response <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AIS_VESSEL_DATA { <span class="kw">pub </span>MMSI : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>COG : u16 , <span class="kw">pub </span>heading : u16 , <span class="kw">pub </span>velocity : u16 , <span class="kw">pub </span>dimension_bow : u16 , <span class="kw">pub </span>dimension_stern : u16 , <span class="kw">pub </span>tslc : u16 , <span class="kw">pub </span>flags : AisFlags , <span class="kw">pub </span>turn_rate : i8 , <span class="kw">pub </span>navigational_status : AisNavStatus , <span class="kw">pub </span>mavtype : AisType , <span class="kw">pub </span>dimension_port : u8 , <span class="kw">pub </span>dimension_starboard : u8 , <span class="kw">pub </span>callsign : [u8 ; <span class="number">7</span>] , <span class="kw">pub </span>name : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>AIS_VESSEL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">58usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . MMSI = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . COG = buf . get_u16_le () ; _struct . heading = buf . get_u16_le () ; _struct . velocity = buf . get_u16_le () ; _struct . dimension_bow = buf . get_u16_le () ; _struct . dimension_stern = buf . get_u16_le () ; _struct . tslc = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = AisFlags :: from_bits (tmp &amp; AisFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AisFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . turn_rate = buf . get_i8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . navigational_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AisNavStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AisType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . dimension_port = buf . get_u8 () ; _struct . dimension_starboard = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">7usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . callsign [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. MMSI) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_u16_le (<span class="self">self </span>. COG) ; _tmp . put_u16_le (<span class="self">self </span>. heading) ; _tmp . put_u16_le (<span class="self">self </span>. velocity) ; _tmp . put_u16_le (<span class="self">self </span>. dimension_bow) ; _tmp . put_u16_le (<span class="self">self </span>. dimension_stern) ; _tmp . put_u16_le (<span class="self">self </span>. tslc) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_i8 (<span class="self">self </span>. turn_rate) ; _tmp . put_u8 (<span class="self">self </span>. navigational_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. dimension_port) ; _tmp . put_u8 (<span class="self">self </span>. dimension_starboard) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. callsign { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_TRACKING_GEO_STATUS_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>h_acc : f32 , <span class="kw">pub </span>v_acc : f32 , <span class="kw">pub </span>vel_n : f32 , <span class="kw">pub </span>vel_e : f32 , <span class="kw">pub </span>vel_d : f32 , <span class="kw">pub </span>vel_acc : f32 , <span class="kw">pub </span>dist : f32 , <span class="kw">pub </span>hdg : f32 , <span class="kw">pub </span>hdg_acc : f32 , <span class="kw">pub </span>tracking_status : CameraTrackingStatusFlags , } <span class="kw">impl </span>CAMERA_TRACKING_GEO_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">49usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . h_acc = buf . get_f32_le () ; _struct . v_acc = buf . get_f32_le () ; _struct . vel_n = buf . get_f32_le () ; _struct . vel_e = buf . get_f32_le () ; _struct . vel_d = buf . get_f32_le () ; _struct . vel_acc = buf . get_f32_le () ; _struct . dist = buf . get_f32_le () ; _struct . hdg = buf . get_f32_le () ; _struct . hdg_acc = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . tracking_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. h_acc) ; _tmp . put_f32_le (<span class="self">self </span>. v_acc) ; _tmp . put_f32_le (<span class="self">self </span>. vel_n) ; _tmp . put_f32_le (<span class="self">self </span>. vel_e) ; _tmp . put_f32_le (<span class="self">self </span>. vel_d) ; _tmp . put_f32_le (<span class="self">self </span>. vel_acc) ; _tmp . put_f32_le (<span class="self">self </span>. dist) ; _tmp . put_f32_le (<span class="self">self </span>. hdg) ; _tmp . put_f32_le (<span class="self">self </span>. hdg_acc) ; _tmp . put_u8 (<span class="self">self </span>. tracking_status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIGHRES_IMU_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>xmag : f32 , <span class="kw">pub </span>ymag : f32 , <span class="kw">pub </span>zmag : f32 , <span class="kw">pub </span>abs_pressure : f32 , <span class="kw">pub </span>diff_pressure : f32 , <span class="kw">pub </span>pressure_alt : f32 , <span class="kw">pub </span>temperature : f32 , <span class="kw">pub </span>fields_updated : HighresImuUpdatedFlags , } <span class="kw">impl </span>HIGHRES_IMU_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">62usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . xmag = buf . get_f32_le () ; _struct . ymag = buf . get_f32_le () ; _struct . zmag = buf . get_f32_le () ; _struct . abs_pressure = buf . get_f32_le () ; _struct . diff_pressure = buf . get_f32_le () ; _struct . pressure_alt = buf . get_f32_le () ; _struct . temperature = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . fields_updated = HighresImuUpdatedFlags :: from_bits (tmp &amp; HighresImuUpdatedFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;HighresImuUpdatedFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_f32_le (<span class="self">self </span>. xmag) ; _tmp . put_f32_le (<span class="self">self </span>. ymag) ; _tmp . put_f32_le (<span class="self">self </span>. zmag) ; _tmp . put_f32_le (<span class="self">self </span>. abs_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. diff_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. pressure_alt) ; _tmp . put_f32_le (<span class="self">self </span>. temperature) ; _tmp . put_u16_le (<span class="self">self </span>. fields_updated . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_RAW_INT_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>eph : u16 , <span class="kw">pub </span>epv : u16 , <span class="kw">pub </span>vel : u16 , <span class="kw">pub </span>cog : u16 , <span class="kw">pub </span>fix_type : GpsFixType , <span class="kw">pub </span>satellites_visible : u8 , } <span class="kw">impl </span>GPS_RAW_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">30usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . eph = buf . get_u16_le () ; _struct . epv = buf . get_u16_le () ; _struct . vel = buf . get_u16_le () ; _struct . cog = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . fix_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GpsFixType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . satellites_visible = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_u16_le (<span class="self">self </span>. eph) ; _tmp . put_u16_le (<span class="self">self </span>. epv) ; _tmp . put_u16_le (<span class="self">self </span>. vel) ; _tmp . put_u16_le (<span class="self">self </span>. cog) ; _tmp . put_u8 (<span class="self">self </span>. fix_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ITEM_REACHED_DATA { <span class="kw">pub </span>seq : u16 , } <span class="kw">impl </span>MISSION_ITEM_REACHED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_GPS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>eph : u16 , <span class="kw">pub </span>epv : u16 , <span class="kw">pub </span>vel : u16 , <span class="kw">pub </span>vn : i16 , <span class="kw">pub </span>ve : i16 , <span class="kw">pub </span>vd : i16 , <span class="kw">pub </span>cog : u16 , <span class="kw">pub </span>fix_type : u8 , <span class="kw">pub </span>satellites_visible : u8 , } <span class="kw">impl </span>HIL_GPS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . eph = buf . get_u16_le () ; _struct . epv = buf . get_u16_le () ; _struct . vel = buf . get_u16_le () ; _struct . vn = buf . get_i16_le () ; _struct . ve = buf . get_i16_le () ; _struct . vd = buf . get_i16_le () ; _struct . cog = buf . get_u16_le () ; _struct . fix_type = buf . get_u8 () ; _struct . satellites_visible = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_u16_le (<span class="self">self </span>. eph) ; _tmp . put_u16_le (<span class="self">self </span>. epv) ; _tmp . put_u16_le (<span class="self">self </span>. vel) ; _tmp . put_i16_le (<span class="self">self </span>. vn) ; _tmp . put_i16_le (<span class="self">self </span>. ve) ; _tmp . put_i16_le (<span class="self">self </span>. vd) ; _tmp . put_u16_le (<span class="self">self </span>. cog) ; _tmp . put_u8 (<span class="self">self </span>. fix_type) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_RTK_DATA { <span class="kw">pub </span>time_last_baseline_ms : u32 , <span class="kw">pub </span>tow : u32 , <span class="kw">pub </span>baseline_a_mm : i32 , <span class="kw">pub </span>baseline_b_mm : i32 , <span class="kw">pub </span>baseline_c_mm : i32 , <span class="kw">pub </span>accuracy : u32 , <span class="kw">pub </span>iar_num_hypotheses : i32 , <span class="kw">pub </span>wn : u16 , <span class="kw">pub </span>rtk_receiver_id : u8 , <span class="kw">pub </span>rtk_health : u8 , <span class="kw">pub </span>rtk_rate : u8 , <span class="kw">pub </span>nsats : u8 , <span class="kw">pub </span>baseline_coords_type : RtkBaselineCoordinateSystem , } <span class="kw">impl </span>GPS_RTK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_last_baseline_ms = buf . get_u32_le () ; _struct . tow = buf . get_u32_le () ; _struct . baseline_a_mm = buf . get_i32_le () ; _struct . baseline_b_mm = buf . get_i32_le () ; _struct . baseline_c_mm = buf . get_i32_le () ; _struct . accuracy = buf . get_u32_le () ; _struct . iar_num_hypotheses = buf . get_i32_le () ; _struct . wn = buf . get_u16_le () ; _struct . rtk_receiver_id = buf . get_u8 () ; _struct . rtk_health = buf . get_u8 () ; _struct . rtk_rate = buf . get_u8 () ; _struct . nsats = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . baseline_coords_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;RtkBaselineCoordinateSystem&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_last_baseline_ms) ; _tmp . put_u32_le (<span class="self">self </span>. tow) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_a_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_b_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_c_mm) ; _tmp . put_u32_le (<span class="self">self </span>. accuracy) ; _tmp . put_i32_le (<span class="self">self </span>. iar_num_hypotheses) ; _tmp . put_u16_le (<span class="self">self </span>. wn) ; _tmp . put_u8 (<span class="self">self </span>. rtk_receiver_id) ; _tmp . put_u8 (<span class="self">self </span>. rtk_health) ; _tmp . put_u8 (<span class="self">self </span>. rtk_rate) ; _tmp . put_u8 (<span class="self">self </span>. nsats) ; _tmp . put_u8 (<span class="self">self </span>. baseline_coords_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ACK_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>mavtype : MavMissionResult , } <span class="kw">impl </span>MISSION_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMissionResult&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SYSTEM_TIME_DATA { <span class="kw">pub </span>time_unix_usec : u64 , <span class="kw">pub </span>time_boot_ms : u32 , } <span class="kw">impl </span>SYSTEM_TIME_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_unix_usec = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_unix_usec) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESTIMATOR_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>vel_ratio : f32 , <span class="kw">pub </span>pos_horiz_ratio : f32 , <span class="kw">pub </span>pos_vert_ratio : f32 , <span class="kw">pub </span>mag_ratio : f32 , <span class="kw">pub </span>hagl_ratio : f32 , <span class="kw">pub </span>tas_ratio : f32 , <span class="kw">pub </span>pos_horiz_accuracy : f32 , <span class="kw">pub </span>pos_vert_accuracy : f32 , <span class="kw">pub </span>flags : EstimatorStatusFlags , } <span class="kw">impl </span>ESTIMATOR_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . vel_ratio = buf . get_f32_le () ; _struct . pos_horiz_ratio = buf . get_f32_le () ; _struct . pos_vert_ratio = buf . get_f32_le () ; _struct . mag_ratio = buf . get_f32_le () ; _struct . hagl_ratio = buf . get_f32_le () ; _struct . tas_ratio = buf . get_f32_le () ; _struct . pos_horiz_accuracy = buf . get_f32_le () ; _struct . pos_vert_accuracy = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = EstimatorStatusFlags :: from_bits (tmp &amp; EstimatorStatusFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;EstimatorStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. vel_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. pos_horiz_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. pos_vert_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. mag_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. hagl_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. tas_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. pos_horiz_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. pos_vert_accuracy) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat_int : i32 , <span class="kw">pub </span>lon_int : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>SET_POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat_int = buf . get_i32_le () ; _struct . lon_int = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat_int) ; _tmp . put_i32_le (<span class="self">self </span>. lon_int) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_HOME_POSITION_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>approach_x : f32 , <span class="kw">pub </span>approach_y : f32 , <span class="kw">pub </span>approach_z : f32 , <span class="kw">pub </span>target_system : u8 , } <span class="kw">impl </span>SET_HOME_POSITION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . approach_x = buf . get_f32_le () ; _struct . approach_y = buf . get_f32_le () ; _struct . approach_z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. approach_x) ; _tmp . put_f32_le (<span class="self">self </span>. approach_y) ; _tmp . put_f32_le (<span class="self">self </span>. approach_z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GENERATOR_STATUS_DATA { <span class="kw">pub </span>status : MavGeneratorStatusFlag , <span class="kw">pub </span>battery_current : f32 , <span class="kw">pub </span>load_current : f32 , <span class="kw">pub </span>power_generated : f32 , <span class="kw">pub </span>bus_voltage : f32 , <span class="kw">pub </span>bat_current_setpoint : f32 , <span class="kw">pub </span>runtime : u32 , <span class="kw">pub </span>time_until_maintenance : i32 , <span class="kw">pub </span>generator_speed : u16 , <span class="kw">pub </span>rectifier_temperature : i16 , <span class="kw">pub </span>generator_temperature : i16 , } <span class="kw">impl </span>GENERATOR_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u64_le () ; _struct . status = MavGeneratorStatusFlag :: from_bits (tmp &amp; MavGeneratorStatusFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavGeneratorStatusFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . battery_current = buf . get_f32_le () ; _struct . load_current = buf . get_f32_le () ; _struct . power_generated = buf . get_f32_le () ; _struct . bus_voltage = buf . get_f32_le () ; _struct . bat_current_setpoint = buf . get_f32_le () ; _struct . runtime = buf . get_u32_le () ; _struct . time_until_maintenance = buf . get_i32_le () ; _struct . generator_speed = buf . get_u16_le () ; _struct . rectifier_temperature = buf . get_i16_le () ; _struct . generator_temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. status . bits ()) ; _tmp . put_f32_le (<span class="self">self </span>. battery_current) ; _tmp . put_f32_le (<span class="self">self </span>. load_current) ; _tmp . put_f32_le (<span class="self">self </span>. power_generated) ; _tmp . put_f32_le (<span class="self">self </span>. bus_voltage) ; _tmp . put_f32_le (<span class="self">self </span>. bat_current_setpoint) ; _tmp . put_u32_le (<span class="self">self </span>. runtime) ; _tmp . put_i32_le (<span class="self">self </span>. time_until_maintenance) ; _tmp . put_u16_le (<span class="self">self </span>. generator_speed) ; _tmp . put_i16_le (<span class="self">self </span>. rectifier_temperature) ; _tmp . put_i16_le (<span class="self">self </span>. generator_temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_RTCM_DATA_DATA { <span class="kw">pub </span>flags : u8 , <span class="kw">pub </span>len : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">180 </span>&gt; , } <span class="kw">impl </span>GPS_RTCM_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">182usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . flags = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">180usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. flags) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OBSTACLE_DISTANCE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>distances : Vec &lt; u16 , <span class="number">72 </span>&gt; , <span class="kw">pub </span>min_distance : u16 , <span class="kw">pub </span>max_distance : u16 , <span class="kw">pub </span>sensor_type : MavDistanceSensor , <span class="kw">pub </span>increment : u8 , } <span class="kw">impl </span>OBSTACLE_DISTANCE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">158usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">72usize </span>{ <span class="kw">let </span>val = buf . get_u16_le () ; _struct . distances . push (val) . unwrap () ; } _struct . min_distance = buf . get_u16_le () ; _struct . max_distance = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . sensor_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavDistanceSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . increment = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. distances { _tmp . put_u16_le (* val) ; } _tmp . put_u16_le (<span class="self">self </span>. min_distance) ; _tmp . put_u16_le (<span class="self">self </span>. max_distance) ; _tmp . put_u8 (<span class="self">self </span>. sensor_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. increment) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_CANCEL_DATA { <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>COMMAND_CANCEL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MESSAGE_INTERVAL_DATA { <span class="kw">pub </span>interval_us : i32 , <span class="kw">pub </span>message_id : u16 , } <span class="kw">impl </span>MESSAGE_INTERVAL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . interval_us = buf . get_i32_le () ; _struct . message_id = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. interval_us) ; _tmp . put_u16_le (<span class="self">self </span>. message_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_SET_CURRENT_DATA { <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_SET_CURRENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_PRESSURE3_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>press_abs : f32 , <span class="kw">pub </span>press_diff : f32 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>SCALED_PRESSURE3_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . press_abs = buf . get_f32_le () ; _struct . press_diff = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. press_abs) ; _tmp . put_f32_le (<span class="self">self </span>. press_diff) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVIONIX_ADSB_OUT_CFG_DATA { <span class="kw">pub </span>ICAO : u32 , <span class="kw">pub </span>stallSpeed : u16 , <span class="kw">pub </span>callsign : [u8 ; <span class="number">9</span>] , <span class="kw">pub </span>emitterType : AdsbEmitterType , <span class="kw">pub </span>aircraftSize : UavionixAdsbOutCfgAircraftSize , <span class="kw">pub </span>gpsOffsetLat : UavionixAdsbOutCfgGpsOffsetLat , <span class="kw">pub </span>gpsOffsetLon : UavionixAdsbOutCfgGpsOffsetLon , <span class="kw">pub </span>rfSelect : UavionixAdsbOutRfSelect , } <span class="kw">impl </span>UAVIONIX_ADSB_OUT_CFG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ICAO = buf . get_u32_le () ; _struct . stallSpeed = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">9usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . callsign [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . emitterType = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AdsbEmitterType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . aircraftSize = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutCfgAircraftSize&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gpsOffsetLat = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutCfgGpsOffsetLat&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gpsOffsetLon = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutCfgGpsOffsetLon&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . rfSelect = UavionixAdsbOutRfSelect :: from_bits (tmp &amp; UavionixAdsbOutRfSelect :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UavionixAdsbOutRfSelect&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ICAO) ; _tmp . put_u16_le (<span class="self">self </span>. stallSpeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. callsign { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. emitterType <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. aircraftSize <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. gpsOffsetLat <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. gpsOffsetLon <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. rfSelect . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SIM_STATE_DATA { <span class="kw">pub </span>q1 : f32 , <span class="kw">pub </span>q2 : f32 , <span class="kw">pub </span>q3 : f32 , <span class="kw">pub </span>q4 : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>lat : f32 , <span class="kw">pub </span>lon : f32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>std_dev_horz : f32 , <span class="kw">pub </span>std_dev_vert : f32 , <span class="kw">pub </span>vn : f32 , <span class="kw">pub </span>ve : f32 , <span class="kw">pub </span>vd : f32 , } <span class="kw">impl </span>SIM_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">84usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . q1 = buf . get_f32_le () ; _struct . q2 = buf . get_f32_le () ; _struct . q3 = buf . get_f32_le () ; _struct . q4 = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . lat = buf . get_f32_le () ; _struct . lon = buf . get_f32_le () ; _struct . alt = buf . get_f32_le () ; _struct . std_dev_horz = buf . get_f32_le () ; _struct . std_dev_vert = buf . get_f32_le () ; _struct . vn = buf . get_f32_le () ; _struct . ve = buf . get_f32_le () ; _struct . vd = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. q1) ; _tmp . put_f32_le (<span class="self">self </span>. q2) ; _tmp . put_f32_le (<span class="self">self </span>. q3) ; _tmp . put_f32_le (<span class="self">self </span>. q4) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_f32_le (<span class="self">self </span>. lat) ; _tmp . put_f32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. std_dev_horz) ; _tmp . put_f32_le (<span class="self">self </span>. std_dev_vert) ; _tmp . put_f32_le (<span class="self">self </span>. vn) ; _tmp . put_f32_le (<span class="self">self </span>. ve) ; _tmp . put_f32_le (<span class="self">self </span>. vd) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GLOBAL_POSITION_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>hdg : u16 , } <span class="kw">impl </span>GLOBAL_POSITION_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . hdg = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_u16_le (<span class="self">self </span>. hdg) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CURRENT_EVENT_SEQUENCE_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>flags : MavEventCurrentSequenceFlags , } <span class="kw">impl </span>CURRENT_EVENT_SEQUENCE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = MavEventCurrentSequenceFlags :: from_bits (tmp &amp; MavEventCurrentSequenceFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavEventCurrentSequenceFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>BATTERY_STATUS_DATA { <span class="kw">pub </span>current_consumed : i32 , <span class="kw">pub </span>energy_consumed : i32 , <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>voltages : [u16 ; <span class="number">10</span>] , <span class="kw">pub </span>current_battery : i16 , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>battery_function : MavBatteryFunction , <span class="kw">pub </span>mavtype : MavBatteryType , <span class="kw">pub </span>battery_remaining : i8 , } <span class="kw">impl </span>BATTERY_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . current_consumed = buf . get_i32_le () ; _struct . energy_consumed = buf . get_i32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u16_le () ; _struct . voltages [idx] = val ; } _struct . current_battery = buf . get_i16_le () ; _struct . id = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . battery_function = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryFunction&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . battery_remaining = buf . get_i8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. current_consumed) ; _tmp . put_i32_le (<span class="self">self </span>. energy_consumed) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltages { _tmp . put_u16_le (* val) ; } _tmp . put_i16_le (<span class="self">self </span>. current_battery) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. battery_function <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_i8 (<span class="self">self </span>. battery_remaining) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WIND_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>wind_x : f32 , <span class="kw">pub </span>wind_y : f32 , <span class="kw">pub </span>wind_z : f32 , <span class="kw">pub </span>var_horiz : f32 , <span class="kw">pub </span>var_vert : f32 , <span class="kw">pub </span>wind_alt : f32 , <span class="kw">pub </span>horiz_accuracy : f32 , <span class="kw">pub </span>vert_accuracy : f32 , } <span class="kw">impl </span>WIND_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . wind_x = buf . get_f32_le () ; _struct . wind_y = buf . get_f32_le () ; _struct . wind_z = buf . get_f32_le () ; _struct . var_horiz = buf . get_f32_le () ; _struct . var_vert = buf . get_f32_le () ; _struct . wind_alt = buf . get_f32_le () ; _struct . horiz_accuracy = buf . get_f32_le () ; _struct . vert_accuracy = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. wind_x) ; _tmp . put_f32_le (<span class="self">self </span>. wind_y) ; _tmp . put_f32_le (<span class="self">self </span>. wind_z) ; _tmp . put_f32_le (<span class="self">self </span>. var_horiz) ; _tmp . put_f32_le (<span class="self">self </span>. var_vert) ; _tmp . put_f32_le (<span class="self">self </span>. wind_alt) ; _tmp . put_f32_le (<span class="self">self </span>. horiz_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. vert_accuracy) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>STATUSTEXT_DATA { <span class="kw">pub </span>severity : MavSeverity , <span class="kw">pub </span>text : Vec &lt; u8 , <span class="number">50 </span>&gt; , } <span class="kw">impl </span>STATUSTEXT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . severity = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavSeverity&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">50usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . text . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. severity <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. text { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CANFD_FRAME_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>len : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">64 </span>&gt; , } <span class="kw">impl </span>CANFD_FRAME_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">72usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . bus = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">64usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_INPUT_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>time_week_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>hdop : f32 , <span class="kw">pub </span>vdop : f32 , <span class="kw">pub </span>vn : f32 , <span class="kw">pub </span>ve : f32 , <span class="kw">pub </span>vd : f32 , <span class="kw">pub </span>speed_accuracy : f32 , <span class="kw">pub </span>horiz_accuracy : f32 , <span class="kw">pub </span>vert_accuracy : f32 , <span class="kw">pub </span>ignore_flags : GpsInputIgnoreFlags , <span class="kw">pub </span>time_week : u16 , <span class="kw">pub </span>gps_id : u8 , <span class="kw">pub </span>fix_type : u8 , <span class="kw">pub </span>satellites_visible : u8 , } <span class="kw">impl </span>GPS_INPUT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">63usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . time_week_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . hdop = buf . get_f32_le () ; _struct . vdop = buf . get_f32_le () ; _struct . vn = buf . get_f32_le () ; _struct . ve = buf . get_f32_le () ; _struct . vd = buf . get_f32_le () ; _struct . speed_accuracy = buf . get_f32_le () ; _struct . horiz_accuracy = buf . get_f32_le () ; _struct . vert_accuracy = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . ignore_flags = GpsInputIgnoreFlags :: from_bits (tmp &amp; GpsInputIgnoreFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GpsInputIgnoreFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . time_week = buf . get_u16_le () ; _struct . gps_id = buf . get_u8 () ; _struct . fix_type = buf . get_u8 () ; _struct . satellites_visible = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. time_week_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. hdop) ; _tmp . put_f32_le (<span class="self">self </span>. vdop) ; _tmp . put_f32_le (<span class="self">self </span>. vn) ; _tmp . put_f32_le (<span class="self">self </span>. ve) ; _tmp . put_f32_le (<span class="self">self </span>. vd) ; _tmp . put_f32_le (<span class="self">self </span>. speed_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. horiz_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. vert_accuracy) ; _tmp . put_u16_le (<span class="self">self </span>. ignore_flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. time_week) ; _tmp . put_u8 (<span class="self">self </span>. gps_id) ; _tmp . put_u8 (<span class="self">self </span>. fix_type) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_IMU3_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>SCALED_IMU3_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_RAW_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>port : u8 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>RC_CHANNELS_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . port = buf . get_u8 () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u8 (<span class="self">self </span>. port) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_CLEAR_ALL_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_CLEAR_ALL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_SET_PITCHYAW_DATA { <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>pitch_rate : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_SET_PITCHYAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">23usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . pitch_rate = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA { <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>pitch_rate : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">23usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . pitch_rate = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PROTOCOL_VERSION_DATA { <span class="kw">pub </span>version : u16 , <span class="kw">pub </span>min_version : u16 , <span class="kw">pub </span>max_version : u16 , <span class="kw">pub </span>spec_version_hash : [u8 ; <span class="number">8</span>] , <span class="kw">pub </span>library_version_hash : [u8 ; <span class="number">8</span>] , } <span class="kw">impl </span>PROTOCOL_VERSION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . version = buf . get_u16_le () ; _struct . min_version = buf . get_u16_le () ; _struct . max_version = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . spec_version_hash [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . library_version_hash [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. version) ; _tmp . put_u16_le (<span class="self">self </span>. min_version) ; _tmp . put_u16_le (<span class="self">self </span>. max_version) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. spec_version_hash { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. library_version_hash { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_SET_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_value : Vec &lt; u8 , <span class="number">128 </span>&gt; , <span class="kw">pub </span>param_type : MavParamExtType , } <span class="kw">impl </span>PARAM_EXT_SET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">147usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">128usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_value . push (val) . unwrap () ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamExtType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_value { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_INT_DATA { <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SERIAL_CONTROL_DATA { <span class="kw">pub </span>baudrate : u32 , <span class="kw">pub </span>timeout : u16 , <span class="kw">pub </span>device : SerialControlDev , <span class="kw">pub </span>flags : SerialControlFlag , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">70 </span>&gt; , } <span class="kw">impl </span>SERIAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">79usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . baudrate = buf . get_u32_le () ; _struct . timeout = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . device = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;SerialControlDev&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = SerialControlFlag :: from_bits (tmp &amp; SerialControlFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;SerialControlFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . count = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">70usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. baudrate) ; _tmp . put_u16_le (<span class="self">self </span>. timeout) ; _tmp . put_u8 (<span class="self">self </span>. device <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>controls : [f32 ; <span class="number">8</span>] , <span class="kw">pub </span>group_mlx : u8 , } <span class="kw">impl </span>ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">41usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . controls [idx] = val ; } _struct . group_mlx = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. controls { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. group_mlx) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ISBD_LINK_STATUS_DATA { <span class="kw">pub </span>timestamp : u64 , <span class="kw">pub </span>last_heartbeat : u64 , <span class="kw">pub </span>failed_sessions : u16 , <span class="kw">pub </span>successful_sessions : u16 , <span class="kw">pub </span>signal_quality : u8 , <span class="kw">pub </span>ring_pending : u8 , <span class="kw">pub </span>tx_session_pending : u8 , <span class="kw">pub </span>rx_session_pending : u8 , } <span class="kw">impl </span>ISBD_LINK_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">24usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u64_le () ; _struct . last_heartbeat = buf . get_u64_le () ; _struct . failed_sessions = buf . get_u16_le () ; _struct . successful_sessions = buf . get_u16_le () ; _struct . signal_quality = buf . get_u8 () ; _struct . ring_pending = buf . get_u8 () ; _struct . tx_session_pending = buf . get_u8 () ; _struct . rx_session_pending = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. timestamp) ; _tmp . put_u64_le (<span class="self">self </span>. last_heartbeat) ; _tmp . put_u16_le (<span class="self">self </span>. failed_sessions) ; _tmp . put_u16_le (<span class="self">self </span>. successful_sessions) ; _tmp . put_u8 (<span class="self">self </span>. signal_quality) ; _tmp . put_u8 (<span class="self">self </span>. ring_pending) ; _tmp . put_u8 (<span class="self">self </span>. tx_session_pending) ; _tmp . put_u8 (<span class="self">self </span>. rx_session_pending) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOGGING_DATA_ACKED_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>length : u8 , <span class="kw">pub </span>first_message_offset : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">249 </span>&gt; , } <span class="kw">impl </span>LOGGING_DATA_ACKED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . length = buf . get_u8 () ; _struct . first_message_offset = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">249usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. length) ; _tmp . put_u8 (<span class="self">self </span>. first_message_offset) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_RC_INPUTS_RAW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>chan9_raw : u16 , <span class="kw">pub </span>chan10_raw : u16 , <span class="kw">pub </span>chan11_raw : u16 , <span class="kw">pub </span>chan12_raw : u16 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>HIL_RC_INPUTS_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">33usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . chan9_raw = buf . get_u16_le () ; _struct . chan10_raw = buf . get_u16_le () ; _struct . chan11_raw = buf . get_u16_le () ; _struct . chan12_raw = buf . get_u16_le () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan9_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan10_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan11_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan12_raw) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>chan9_raw : u16 , <span class="kw">pub </span>chan10_raw : u16 , <span class="kw">pub </span>chan11_raw : u16 , <span class="kw">pub </span>chan12_raw : u16 , <span class="kw">pub </span>chan13_raw : u16 , <span class="kw">pub </span>chan14_raw : u16 , <span class="kw">pub </span>chan15_raw : u16 , <span class="kw">pub </span>chan16_raw : u16 , <span class="kw">pub </span>chan17_raw : u16 , <span class="kw">pub </span>chan18_raw : u16 , <span class="kw">pub </span>chancount : u8 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>RC_CHANNELS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . chan9_raw = buf . get_u16_le () ; _struct . chan10_raw = buf . get_u16_le () ; _struct . chan11_raw = buf . get_u16_le () ; _struct . chan12_raw = buf . get_u16_le () ; _struct . chan13_raw = buf . get_u16_le () ; _struct . chan14_raw = buf . get_u16_le () ; _struct . chan15_raw = buf . get_u16_le () ; _struct . chan16_raw = buf . get_u16_le () ; _struct . chan17_raw = buf . get_u16_le () ; _struct . chan18_raw = buf . get_u16_le () ; _struct . chancount = buf . get_u8 () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan9_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan10_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan11_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan12_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan13_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan14_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan15_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan16_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan17_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan18_raw) ; _tmp . put_u8 (<span class="self">self </span>. chancount) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>NAMED_VALUE_FLOAT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>value : f32 , <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>NAMED_VALUE_FLOAT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . value = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. value) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAN_FILTER_MODIFY_DATA { <span class="kw">pub </span>ids : [u16 ; <span class="number">16</span>] , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>operation : CanFilterOp , <span class="kw">pub </span>num_ids : u8 , } <span class="kw">impl </span>CAN_FILTER_MODIFY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u16_le () ; _struct . ids [idx] = val ; } _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . bus = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . operation = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CanFilterOp&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . num_ids = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. ids { _tmp . put_u16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. operation <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. num_ids) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_INFO_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>error_count : [u32 ; <span class="number">4</span>] , <span class="kw">pub </span>counter : u16 , <span class="kw">pub </span>failure_flags : [u16 ; <span class="number">4</span>] , <span class="kw">pub </span>temperature : [i16 ; <span class="number">4</span>] , <span class="kw">pub </span>index : u8 , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>connection_type : EscConnectionType , <span class="kw">pub </span>info : u8 , } <span class="kw">impl </span>ESC_INFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">46usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . error_count [idx] = val ; } _struct . counter = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_u16_le () ; _struct . failure_flags [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_i16_le () ; _struct . temperature [idx] = val ; } _struct . index = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . connection_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;EscConnectionType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . info = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. error_count { _tmp . put_u32_le (* val) ; } _tmp . put_u16_le (<span class="self">self </span>. counter) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. failure_flags { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature { _tmp . put_i16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. index) ; _tmp . put_u8 (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. connection_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. info) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_DATA { <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_OPTICAL_FLOW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>integration_time_us : u32 , <span class="kw">pub </span>integrated_x : f32 , <span class="kw">pub </span>integrated_y : f32 , <span class="kw">pub </span>integrated_xgyro : f32 , <span class="kw">pub </span>integrated_ygyro : f32 , <span class="kw">pub </span>integrated_zgyro : f32 , <span class="kw">pub </span>time_delta_distance_us : u32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>sensor_id : u8 , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>HIL_OPTICAL_FLOW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . integration_time_us = buf . get_u32_le () ; _struct . integrated_x = buf . get_f32_le () ; _struct . integrated_y = buf . get_f32_le () ; _struct . integrated_xgyro = buf . get_f32_le () ; _struct . integrated_ygyro = buf . get_f32_le () ; _struct . integrated_zgyro = buf . get_f32_le () ; _struct . time_delta_distance_us = buf . get_u32_le () ; _struct . distance = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; _struct . sensor_id = buf . get_u8 () ; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. integration_time_us) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_x) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_y) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_zgyro) ; _tmp . put_u32_le (<span class="self">self </span>. time_delta_distance_us) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; _tmp . put_u8 (<span class="self">self </span>. sensor_id) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIGH_LATENCY2_DATA { <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>custom_mode : u16 , <span class="kw">pub </span>altitude : i16 , <span class="kw">pub </span>target_altitude : i16 , <span class="kw">pub </span>target_distance : u16 , <span class="kw">pub </span>wp_num : u16 , <span class="kw">pub </span>failure_flags : HlFailureFlag , <span class="kw">pub </span>mavtype : MavType , <span class="kw">pub </span>autopilot : MavAutopilot , <span class="kw">pub </span>heading : u8 , <span class="kw">pub </span>target_heading : u8 , <span class="kw">pub </span>throttle : u8 , <span class="kw">pub </span>airspeed : u8 , <span class="kw">pub </span>airspeed_sp : u8 , <span class="kw">pub </span>groundspeed : u8 , <span class="kw">pub </span>windspeed : u8 , <span class="kw">pub </span>wind_heading : u8 , <span class="kw">pub </span>eph : u8 , <span class="kw">pub </span>epv : u8 , <span class="kw">pub </span>temperature_air : i8 , <span class="kw">pub </span>climb_rate : i8 , <span class="kw">pub </span>battery : i8 , <span class="kw">pub </span>custom0 : i8 , <span class="kw">pub </span>custom1 : i8 , <span class="kw">pub </span>custom2 : i8 , } <span class="kw">impl </span>HIGH_LATENCY2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u32_le () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . custom_mode = buf . get_u16_le () ; _struct . altitude = buf . get_i16_le () ; _struct . target_altitude = buf . get_i16_le () ; _struct . target_distance = buf . get_u16_le () ; _struct . wp_num = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . failure_flags = HlFailureFlag :: from_bits (tmp &amp; HlFailureFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;HlFailureFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . autopilot = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavAutopilot&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . heading = buf . get_u8 () ; _struct . target_heading = buf . get_u8 () ; _struct . throttle = buf . get_u8 () ; _struct . airspeed = buf . get_u8 () ; _struct . airspeed_sp = buf . get_u8 () ; _struct . groundspeed = buf . get_u8 () ; _struct . windspeed = buf . get_u8 () ; _struct . wind_heading = buf . get_u8 () ; _struct . eph = buf . get_u8 () ; _struct . epv = buf . get_u8 () ; _struct . temperature_air = buf . get_i8 () ; _struct . climb_rate = buf . get_i8 () ; _struct . battery = buf . get_i8 () ; _struct . custom0 = buf . get_i8 () ; _struct . custom1 = buf . get_i8 () ; _struct . custom2 = buf . get_i8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_u16_le (<span class="self">self </span>. custom_mode) ; _tmp . put_i16_le (<span class="self">self </span>. altitude) ; _tmp . put_i16_le (<span class="self">self </span>. target_altitude) ; _tmp . put_u16_le (<span class="self">self </span>. target_distance) ; _tmp . put_u16_le (<span class="self">self </span>. wp_num) ; _tmp . put_u16_le (<span class="self">self </span>. failure_flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. autopilot <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. heading) ; _tmp . put_u8 (<span class="self">self </span>. target_heading) ; _tmp . put_u8 (<span class="self">self </span>. throttle) ; _tmp . put_u8 (<span class="self">self </span>. airspeed) ; _tmp . put_u8 (<span class="self">self </span>. airspeed_sp) ; _tmp . put_u8 (<span class="self">self </span>. groundspeed) ; _tmp . put_u8 (<span class="self">self </span>. windspeed) ; _tmp . put_u8 (<span class="self">self </span>. wind_heading) ; _tmp . put_u8 (<span class="self">self </span>. eph) ; _tmp . put_u8 (<span class="self">self </span>. epv) ; _tmp . put_i8 (<span class="self">self </span>. temperature_air) ; _tmp . put_i8 (<span class="self">self </span>. climb_rate) ; _tmp . put_i8 (<span class="self">self </span>. battery) ; _tmp . put_i8 (<span class="self">self </span>. custom0) ; _tmp . put_i8 (<span class="self">self </span>. custom1) ; _tmp . put_i8 (<span class="self">self </span>. custom2) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_IMU_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>SCALED_IMU_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_ERASE_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_ERASE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_INJECT_DATA_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>len : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">110 </span>&gt; , } <span class="kw">impl </span>GPS_INJECT_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">113usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">110usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOGGING_DATA_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>length : u8 , <span class="kw">pub </span>first_message_offset : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">249 </span>&gt; , } <span class="kw">impl </span>LOGGING_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . length = buf . get_u8 () ; _struct . first_message_offset = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">249usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. length) ; _tmp . put_u8 (<span class="self">self </span>. first_message_offset) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIGH_LATENCY_DATA { <span class="kw">pub </span>custom_mode : u32 , <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>roll : i16 , <span class="kw">pub </span>pitch : i16 , <span class="kw">pub </span>heading : u16 , <span class="kw">pub </span>heading_sp : i16 , <span class="kw">pub </span>altitude_amsl : i16 , <span class="kw">pub </span>altitude_sp : i16 , <span class="kw">pub </span>wp_distance : u16 , <span class="kw">pub </span>base_mode : MavModeFlag , <span class="kw">pub </span>landed_state : MavLandedState , <span class="kw">pub </span>throttle : i8 , <span class="kw">pub </span>airspeed : u8 , <span class="kw">pub </span>airspeed_sp : u8 , <span class="kw">pub </span>groundspeed : u8 , <span class="kw">pub </span>climb_rate : i8 , <span class="kw">pub </span>gps_nsat : u8 , <span class="kw">pub </span>gps_fix_type : GpsFixType , <span class="kw">pub </span>battery_remaining : u8 , <span class="kw">pub </span>temperature : i8 , <span class="kw">pub </span>temperature_air : i8 , <span class="kw">pub </span>failsafe : u8 , <span class="kw">pub </span>wp_num : u8 , } <span class="kw">impl </span>HIGH_LATENCY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . custom_mode = buf . get_u32_le () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . roll = buf . get_i16_le () ; _struct . pitch = buf . get_i16_le () ; _struct . heading = buf . get_u16_le () ; _struct . heading_sp = buf . get_i16_le () ; _struct . altitude_amsl = buf . get_i16_le () ; _struct . altitude_sp = buf . get_i16_le () ; _struct . wp_distance = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . base_mode = MavModeFlag :: from_bits (tmp &amp; MavModeFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavModeFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . landed_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavLandedState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . throttle = buf . get_i8 () ; _struct . airspeed = buf . get_u8 () ; _struct . airspeed_sp = buf . get_u8 () ; _struct . groundspeed = buf . get_u8 () ; _struct . climb_rate = buf . get_i8 () ; _struct . gps_nsat = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gps_fix_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GpsFixType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . battery_remaining = buf . get_u8 () ; _struct . temperature = buf . get_i8 () ; _struct . temperature_air = buf . get_i8 () ; _struct . failsafe = buf . get_u8 () ; _struct . wp_num = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. custom_mode) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i16_le (<span class="self">self </span>. roll) ; _tmp . put_i16_le (<span class="self">self </span>. pitch) ; _tmp . put_u16_le (<span class="self">self </span>. heading) ; _tmp . put_i16_le (<span class="self">self </span>. heading_sp) ; _tmp . put_i16_le (<span class="self">self </span>. altitude_amsl) ; _tmp . put_i16_le (<span class="self">self </span>. altitude_sp) ; _tmp . put_u16_le (<span class="self">self </span>. wp_distance) ; _tmp . put_u8 (<span class="self">self </span>. base_mode . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. landed_state <span class="kw">as </span>u8) ; _tmp . put_i8 (<span class="self">self </span>. throttle) ; _tmp . put_u8 (<span class="self">self </span>. airspeed) ; _tmp . put_u8 (<span class="self">self </span>. airspeed_sp) ; _tmp . put_u8 (<span class="self">self </span>. groundspeed) ; _tmp . put_i8 (<span class="self">self </span>. climb_rate) ; _tmp . put_u8 (<span class="self">self </span>. gps_nsat) ; _tmp . put_u8 (<span class="self">self </span>. gps_fix_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. battery_remaining) ; _tmp . put_i8 (<span class="self">self </span>. temperature) ; _tmp . put_i8 (<span class="self">self </span>. temperature_air) ; _tmp . put_u8 (<span class="self">self </span>. failsafe) ; _tmp . put_u8 (<span class="self">self </span>. wp_num) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ALTITUDE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>altitude_monotonic : f32 , <span class="kw">pub </span>altitude_amsl : f32 , <span class="kw">pub </span>altitude_local : f32 , <span class="kw">pub </span>altitude_relative : f32 , <span class="kw">pub </span>altitude_terrain : f32 , <span class="kw">pub </span>bottom_clearance : f32 , } <span class="kw">impl </span>ALTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . altitude_monotonic = buf . get_f32_le () ; _struct . altitude_amsl = buf . get_f32_le () ; _struct . altitude_local = buf . get_f32_le () ; _struct . altitude_relative = buf . get_f32_le () ; _struct . altitude_terrain = buf . get_f32_le () ; _struct . bottom_clearance = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_monotonic) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_amsl) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_local) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_relative) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_terrain) ; _tmp . put_f32_le (<span class="self">self </span>. bottom_clearance) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_REQUEST_DATA { <span class="kw">pub </span>mask : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>grid_spacing : u16 , } <span class="kw">impl </span>TERRAIN_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mask = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . grid_spacing = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. mask) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_u16_le (<span class="self">self </span>. grid_spacing) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_REQUEST_LIST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>PARAM_EXT_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_REQUEST_DATA_DATA { <span class="kw">pub </span>ofs : u32 , <span class="kw">pub </span>count : u32 , <span class="kw">pub </span>id : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_REQUEST_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ofs = buf . get_u32_le () ; _struct . count = buf . get_u32_le () ; _struct . id = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ofs) ; _tmp . put_u32_le (<span class="self">self </span>. count) ; _tmp . put_u16_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEBUG_FLOAT_ARRAY_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>array_id : u16 , <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>DEBUG_FLOAT_ARRAY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . array_id = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . name [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u16_le (<span class="self">self </span>. array_id) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_OVERRIDE_DATA { <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>RC_CHANNELS_OVERRIDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GLOBAL_VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>GLOBAL_VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_MESSAGE_PACK_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>single_message_size : u8 , <span class="kw">pub </span>msg_pack_size : u8 , <span class="kw">pub </span>messages : Vec &lt; u8 , <span class="number">225 </span>&gt; , } <span class="kw">impl </span>OPEN_DRONE_ID_MESSAGE_PACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">249usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } _struct . single_message_size = buf . get_u8 () ; _struct . msg_pack_size = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">225usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . messages . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. single_message_size) ; _tmp . put_u8 (<span class="self">self </span>. msg_pack_size) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. messages { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FILE_TRANSFER_PROTOCOL_DATA { <span class="kw">pub </span>target_network : u8 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>payload : Vec &lt; u8 , <span class="number">251 </span>&gt; , } <span class="kw">impl </span>FILE_TRANSFER_PROTOCOL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">254usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_network = buf . get_u8 () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">251usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . payload . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_network) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. payload { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_IMAGE_CAPTURED_DATA { <span class="kw">pub </span>time_utc : u64 , <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>image_index : i32 , <span class="kw">pub </span>camera_id : u8 , <span class="kw">pub </span>capture_result : i8 , <span class="kw">pub </span>file_url : Vec &lt; u8 , <span class="number">205 </span>&gt; , } <span class="kw">impl </span>CAMERA_IMAGE_CAPTURED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_utc = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . image_index = buf . get_i32_le () ; _struct . camera_id = buf . get_u8 () ; _struct . capture_result = buf . get_i8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">205usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . file_url . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_utc) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_i32_le (<span class="self">self </span>. image_index) ; _tmp . put_u8 (<span class="self">self </span>. camera_id) ; _tmp . put_i8 (<span class="self">self </span>. capture_result) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. file_url { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CELLULAR_STATUS_DATA { <span class="kw">pub </span>mcc : u16 , <span class="kw">pub </span>mnc : u16 , <span class="kw">pub </span>lac : u16 , <span class="kw">pub </span>status : CellularStatusFlag , <span class="kw">pub </span>failure_reason : CellularNetworkFailedReason , <span class="kw">pub </span>mavtype : CellularNetworkRadioType , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>CELLULAR_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">10usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mcc = buf . get_u16_le () ; _struct . mnc = buf . get_u16_le () ; _struct . lac = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularStatusFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . failure_reason = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularNetworkFailedReason&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularNetworkRadioType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. mcc) ; _tmp . put_u16_le (<span class="self">self </span>. mnc) ; _tmp . put_u16_le (<span class="self">self </span>. lac) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. failure_reason <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DISTANCE_SENSOR_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>min_distance : u16 , <span class="kw">pub </span>max_distance : u16 , <span class="kw">pub </span>current_distance : u16 , <span class="kw">pub </span>mavtype : MavDistanceSensor , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>orientation : MavSensorOrientation , <span class="kw">pub </span>covariance : u8 , } <span class="kw">impl </span>DISTANCE_SENSOR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . min_distance = buf . get_u16_le () ; _struct . max_distance = buf . get_u16_le () ; _struct . current_distance = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavDistanceSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . id = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . orientation = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavSensorOrientation&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . covariance = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. min_distance) ; _tmp . put_u16_le (<span class="self">self </span>. max_distance) ; _tmp . put_u16_le (<span class="self">self </span>. current_distance) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. orientation <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. covariance) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VICON_POSITION_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>VICON_POSITION_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>cap_flags : GimbalManagerCapFlags , <span class="kw">pub </span>roll_min : f32 , <span class="kw">pub </span>roll_max : f32 , <span class="kw">pub </span>pitch_min : f32 , <span class="kw">pub </span>pitch_max : f32 , <span class="kw">pub </span>yaw_min : f32 , <span class="kw">pub </span>yaw_max : f32 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">33usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . cap_flags = GimbalManagerCapFlags :: from_bits (tmp &amp; GimbalManagerCapFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalManagerCapFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . roll_min = buf . get_f32_le () ; _struct . roll_max = buf . get_f32_le () ; _struct . pitch_min = buf . get_f32_le () ; _struct . pitch_max = buf . get_f32_le () ; _struct . yaw_min = buf . get_f32_le () ; _struct . yaw_max = buf . get_f32_le () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. cap_flags . bits ()) ; _tmp . put_f32_le (<span class="self">self </span>. roll_min) ; _tmp . put_f32_le (<span class="self">self </span>. roll_max) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_min) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_max) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_min) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_max) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VFR_HUD_DATA { <span class="kw">pub </span>airspeed : f32 , <span class="kw">pub </span>groundspeed : f32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>climb : f32 , <span class="kw">pub </span>heading : i16 , <span class="kw">pub </span>throttle : u16 , } <span class="kw">impl </span>VFR_HUD_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . airspeed = buf . get_f32_le () ; _struct . groundspeed = buf . get_f32_le () ; _struct . alt = buf . get_f32_le () ; _struct . climb = buf . get_f32_le () ; _struct . heading = buf . get_i16_le () ; _struct . throttle = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. airspeed) ; _tmp . put_f32_le (<span class="self">self </span>. groundspeed) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. climb) ; _tmp . put_i16_le (<span class="self">self </span>. heading) ; _tmp . put_u16_le (<span class="self">self </span>. throttle) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CHANGE_OPERATOR_CONTROL_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>control_request : u8 , <span class="kw">pub </span>version : u8 , <span class="kw">pub </span>passkey : [u8 ; <span class="number">25</span>] , } <span class="kw">impl </span>CHANGE_OPERATOR_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . control_request = buf . get_u8 () ; _struct . version = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">25usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . passkey [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. control_request) ; _tmp . put_u8 (<span class="self">self </span>. version) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. passkey { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HOME_POSITION_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>approach_x : f32 , <span class="kw">pub </span>approach_y : f32 , <span class="kw">pub </span>approach_z : f32 , } <span class="kw">impl </span>HOME_POSITION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">52usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . approach_x = buf . get_f32_le () ; _struct . approach_y = buf . get_f32_le () ; _struct . approach_z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. approach_x) ; _tmp . put_f32_le (<span class="self">self </span>. approach_y) ; _tmp . put_f32_le (<span class="self">self </span>. approach_z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAN_FRAME_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>len : u8 , <span class="kw">pub </span>data : [u8 ; <span class="number">8</span>] , } <span class="kw">impl </span>CAN_FRAME_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . bus = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_TARGET_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>body_roll_rate : f32 , <span class="kw">pub </span>body_pitch_rate : f32 , <span class="kw">pub </span>body_yaw_rate : f32 , <span class="kw">pub </span>thrust : f32 , <span class="kw">pub </span>type_mask : AttitudeTargetTypemask , } <span class="kw">impl </span>ATTITUDE_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . body_roll_rate = buf . get_f32_le () ; _struct . body_pitch_rate = buf . get_f32_le () ; _struct . body_yaw_rate = buf . get_f32_le () ; _struct . thrust = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type_mask = AttitudeTargetTypemask :: from_bits (tmp &amp; AttitudeTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AttitudeTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. body_roll_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_yaw_rate) ; _tmp . put_f32_le (<span class="self">self </span>. thrust) ; _tmp . put_u8 (<span class="self">self </span>. type_mask . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TIMESYNC_DATA { <span class="kw">pub </span>tc1 : i64 , <span class="kw">pub </span>ts1 : i64 , } <span class="kw">impl </span>TIMESYNC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . tc1 = buf . get_i64_le () ; _struct . ts1 = buf . get_i64_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i64_le (<span class="self">self </span>. tc1) ; _tmp . put_i64_le (<span class="self">self </span>. ts1) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PLAY_TUNE_V2_DATA { <span class="kw">pub </span>format : TuneFormat , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>tune : Vec &lt; u8 , <span class="number">248 </span>&gt; , } <span class="kw">impl </span>PLAY_TUNE_V2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">254usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . format = TuneFormat :: from_bits (tmp &amp; TuneFormat :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;TuneFormat&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">248usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . tune . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. format . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. tune { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SYS_STATUS_DATA { <span class="kw">pub </span>onboard_control_sensors_present : MavSysStatusSensor , <span class="kw">pub </span>onboard_control_sensors_enabled : MavSysStatusSensor , <span class="kw">pub </span>onboard_control_sensors_health : MavSysStatusSensor , <span class="kw">pub </span>load : u16 , <span class="kw">pub </span>voltage_battery : u16 , <span class="kw">pub </span>current_battery : i16 , <span class="kw">pub </span>drop_rate_comm : u16 , <span class="kw">pub </span>errors_comm : u16 , <span class="kw">pub </span>errors_count1 : u16 , <span class="kw">pub </span>errors_count2 : u16 , <span class="kw">pub </span>errors_count3 : u16 , <span class="kw">pub </span>errors_count4 : u16 , <span class="kw">pub </span>battery_remaining : i8 , } <span class="kw">impl </span>SYS_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">31usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . onboard_control_sensors_present = MavSysStatusSensor :: from_bits (tmp &amp; MavSysStatusSensor :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavSysStatusSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . onboard_control_sensors_enabled = MavSysStatusSensor :: from_bits (tmp &amp; MavSysStatusSensor :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavSysStatusSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . onboard_control_sensors_health = MavSysStatusSensor :: from_bits (tmp &amp; MavSysStatusSensor :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavSysStatusSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . load = buf . get_u16_le () ; _struct . voltage_battery = buf . get_u16_le () ; _struct . current_battery = buf . get_i16_le () ; _struct . drop_rate_comm = buf . get_u16_le () ; _struct . errors_comm = buf . get_u16_le () ; _struct . errors_count1 = buf . get_u16_le () ; _struct . errors_count2 = buf . get_u16_le () ; _struct . errors_count3 = buf . get_u16_le () ; _struct . errors_count4 = buf . get_u16_le () ; _struct . battery_remaining = buf . get_i8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. onboard_control_sensors_present . bits ()) ; _tmp . put_u32_le (<span class="self">self </span>. onboard_control_sensors_enabled . bits ()) ; _tmp . put_u32_le (<span class="self">self </span>. onboard_control_sensors_health . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. load) ; _tmp . put_u16_le (<span class="self">self </span>. voltage_battery) ; _tmp . put_i16_le (<span class="self">self </span>. current_battery) ; _tmp . put_u16_le (<span class="self">self </span>. drop_rate_comm) ; _tmp . put_u16_le (<span class="self">self </span>. errors_comm) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count1) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count2) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count3) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count4) ; _tmp . put_i8 (<span class="self">self </span>. battery_remaining) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_SETTINGS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>mode_id : CameraMode , } <span class="kw">impl </span>CAMERA_SETTINGS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u8 (<span class="self">self </span>. mode_id <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FLIGHT_INFORMATION_DATA { <span class="kw">pub </span>arming_time_utc : u64 , <span class="kw">pub </span>takeoff_time_utc : u64 , <span class="kw">pub </span>flight_uuid : u64 , <span class="kw">pub </span>time_boot_ms : u32 , } <span class="kw">impl </span>FLIGHT_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . arming_time_utc = buf . get_u64_le () ; _struct . takeoff_time_utc = buf . get_u64_le () ; _struct . flight_uuid = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. arming_time_utc) ; _tmp . put_u64_le (<span class="self">self </span>. takeoff_time_utc) ; _tmp . put_u64_le (<span class="self">self </span>. flight_uuid) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MOUNT_ORIENTATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>MOUNT_ORIENTATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>NAV_CONTROLLER_OUTPUT_DATA { <span class="kw">pub </span>nav_roll : f32 , <span class="kw">pub </span>nav_pitch : f32 , <span class="kw">pub </span>alt_error : f32 , <span class="kw">pub </span>aspd_error : f32 , <span class="kw">pub </span>xtrack_error : f32 , <span class="kw">pub </span>nav_bearing : i16 , <span class="kw">pub </span>target_bearing : i16 , <span class="kw">pub </span>wp_dist : u16 , } <span class="kw">impl </span>NAV_CONTROLLER_OUTPUT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">26usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . nav_roll = buf . get_f32_le () ; _struct . nav_pitch = buf . get_f32_le () ; _struct . alt_error = buf . get_f32_le () ; _struct . aspd_error = buf . get_f32_le () ; _struct . xtrack_error = buf . get_f32_le () ; _struct . nav_bearing = buf . get_i16_le () ; _struct . target_bearing = buf . get_i16_le () ; _struct . wp_dist = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. nav_roll) ; _tmp . put_f32_le (<span class="self">self </span>. nav_pitch) ; _tmp . put_f32_le (<span class="self">self </span>. alt_error) ; _tmp . put_f32_le (<span class="self">self </span>. aspd_error) ; _tmp . put_f32_le (<span class="self">self </span>. xtrack_error) ; _tmp . put_i16_le (<span class="self">self </span>. nav_bearing) ; _tmp . put_i16_le (<span class="self">self </span>. target_bearing) ; _tmp . put_u16_le (<span class="self">self </span>. wp_dist) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>firmware_version : u32 , <span class="kw">pub </span>focal_length : f32 , <span class="kw">pub </span>sensor_size_h : f32 , <span class="kw">pub </span>sensor_size_v : f32 , <span class="kw">pub </span>flags : CameraCapFlags , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>cam_definition_version : u16 , <span class="kw">pub </span>vendor_name : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>model_name : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>lens_id : u8 , <span class="kw">pub </span>cam_definition_uri : Vec &lt; u8 , <span class="number">140 </span>&gt; , } <span class="kw">impl </span>CAMERA_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">235usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . firmware_version = buf . get_u32_le () ; _struct . focal_length = buf . get_f32_le () ; _struct . sensor_size_h = buf . get_f32_le () ; _struct . sensor_size_v = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = CameraCapFlags :: from_bits (tmp &amp; CameraCapFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;CameraCapFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . cam_definition_version = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . vendor_name [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . model_name [idx] = val ; } _struct . lens_id = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">140usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . cam_definition_uri . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. firmware_version) ; _tmp . put_f32_le (<span class="self">self </span>. focal_length) ; _tmp . put_f32_le (<span class="self">self </span>. sensor_size_h) ; _tmp . put_f32_le (<span class="self">self </span>. sensor_size_v) ; _tmp . put_u32_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. cam_definition_version) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vendor_name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. model_name { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. lens_id) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. cam_definition_uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_PRESSURE2_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>press_abs : f32 , <span class="kw">pub </span>press_diff : f32 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>SCALED_PRESSURE2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . press_abs = buf . get_f32_le () ; _struct . press_diff = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. press_abs) ; _tmp . put_f32_le (<span class="self">self </span>. press_diff) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WIFI_CONFIG_AP_DATA { <span class="kw">pub </span>ssid : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>password : Vec &lt; u8 , <span class="number">64 </span>&gt; , } <span class="kw">impl </span>WIFI_CONFIG_AP_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">96usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . ssid [idx] = val ; } <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">64usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . password . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. ssid { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. password { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ONBOARD_COMPUTER_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>uptime : u32 , <span class="kw">pub </span>ram_usage : u32 , <span class="kw">pub </span>ram_total : u32 , <span class="kw">pub </span>storage_type : [u32 ; <span class="number">4</span>] , <span class="kw">pub </span>storage_usage : [u32 ; <span class="number">4</span>] , <span class="kw">pub </span>storage_total : [u32 ; <span class="number">4</span>] , <span class="kw">pub </span>link_type : [u32 ; <span class="number">6</span>] , <span class="kw">pub </span>link_tx_rate : [u32 ; <span class="number">6</span>] , <span class="kw">pub </span>link_rx_rate : [u32 ; <span class="number">6</span>] , <span class="kw">pub </span>link_tx_max : [u32 ; <span class="number">6</span>] , <span class="kw">pub </span>link_rx_max : [u32 ; <span class="number">6</span>] , <span class="kw">pub </span>fan_speed : [i16 ; <span class="number">4</span>] , <span class="kw">pub </span>mavtype : u8 , <span class="kw">pub </span>cpu_cores : [u8 ; <span class="number">8</span>] , <span class="kw">pub </span>cpu_combined : [u8 ; <span class="number">10</span>] , <span class="kw">pub </span>gpu_cores : [u8 ; <span class="number">4</span>] , <span class="kw">pub </span>gpu_combined : [u8 ; <span class="number">10</span>] , <span class="kw">pub </span>temperature_board : i8 , <span class="kw">pub </span>temperature_core : [i8 ; <span class="number">8</span>] , } <span class="kw">impl </span>ONBOARD_COMPUTER_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">238usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . uptime = buf . get_u32_le () ; _struct . ram_usage = buf . get_u32_le () ; _struct . ram_total = buf . get_u32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . storage_type [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . storage_usage [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . storage_total [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">6usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . link_type [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">6usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . link_tx_rate [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">6usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . link_rx_rate [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">6usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . link_tx_max [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">6usize </span>{ <span class="kw">let </span>val = buf . get_u32_le () ; _struct . link_rx_max [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_i16_le () ; _struct . fan_speed [idx] = val ; } _struct . mavtype = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . cpu_cores [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . cpu_combined [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . gpu_cores [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">10usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . gpu_combined [idx] = val ; } _struct . temperature_board = buf . get_i8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">8usize </span>{ <span class="kw">let </span>val = buf . get_i8 () ; _struct . temperature_core [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. uptime) ; _tmp . put_u32_le (<span class="self">self </span>. ram_usage) ; _tmp . put_u32_le (<span class="self">self </span>. ram_total) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage_type { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage_usage { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage_total { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_type { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_tx_rate { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_rx_rate { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_tx_max { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_rx_max { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. fan_speed { _tmp . put_i16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. mavtype) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. cpu_cores { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. cpu_combined { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. gpu_cores { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. gpu_combined { _tmp . put_u8 (* val) ; } _tmp . put_i8 (<span class="self">self </span>. temperature_board) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature_core { _tmp . put_i8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_REPORT_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>terrain_height : f32 , <span class="kw">pub </span>current_height : f32 , <span class="kw">pub </span>spacing : u16 , <span class="kw">pub </span>pending : u16 , <span class="kw">pub </span>loaded : u16 , } <span class="kw">impl </span>TERRAIN_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . terrain_height = buf . get_f32_le () ; _struct . current_height = buf . get_f32_le () ; _struct . spacing = buf . get_u16_le () ; _struct . pending = buf . get_u16_le () ; _struct . loaded = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. terrain_height) ; _tmp . put_f32_le (<span class="self">self </span>. current_height) ; _tmp . put_u16_le (<span class="self">self </span>. spacing) ; _tmp . put_u16_le (<span class="self">self </span>. pending) ; _tmp . put_u16_le (<span class="self">self </span>. loaded) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_TRACKING_IMAGE_STATUS_DATA { <span class="kw">pub </span>point_x : f32 , <span class="kw">pub </span>point_y : f32 , <span class="kw">pub </span>radius : f32 , <span class="kw">pub </span>rec_top_x : f32 , <span class="kw">pub </span>rec_top_y : f32 , <span class="kw">pub </span>rec_bottom_x : f32 , <span class="kw">pub </span>rec_bottom_y : f32 , <span class="kw">pub </span>tracking_status : CameraTrackingStatusFlags , <span class="kw">pub </span>tracking_mode : CameraTrackingMode , <span class="kw">pub </span>target_data : CameraTrackingTargetData , } <span class="kw">impl </span>CAMERA_TRACKING_IMAGE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">31usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . point_x = buf . get_f32_le () ; _struct . point_y = buf . get_f32_le () ; _struct . radius = buf . get_f32_le () ; _struct . rec_top_x = buf . get_f32_le () ; _struct . rec_top_y = buf . get_f32_le () ; _struct . rec_bottom_x = buf . get_f32_le () ; _struct . rec_bottom_y = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . tracking_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . tracking_mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . target_data = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingTargetData&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. point_x) ; _tmp . put_f32_le (<span class="self">self </span>. point_y) ; _tmp . put_f32_le (<span class="self">self </span>. radius) ; _tmp . put_f32_le (<span class="self">self </span>. rec_top_x) ; _tmp . put_f32_le (<span class="self">self </span>. rec_top_y) ; _tmp . put_f32_le (<span class="self">self </span>. rec_bottom_x) ; _tmp . put_f32_le (<span class="self">self </span>. rec_bottom_y) ; _tmp . put_u8 (<span class="self">self </span>. tracking_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. tracking_mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. target_data <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CONTROL_SYSTEM_STATE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x_acc : f32 , <span class="kw">pub </span>y_acc : f32 , <span class="kw">pub </span>z_acc : f32 , <span class="kw">pub </span>x_vel : f32 , <span class="kw">pub </span>y_vel : f32 , <span class="kw">pub </span>z_vel : f32 , <span class="kw">pub </span>x_pos : f32 , <span class="kw">pub </span>y_pos : f32 , <span class="kw">pub </span>z_pos : f32 , <span class="kw">pub </span>airspeed : f32 , <span class="kw">pub </span>vel_variance : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>pos_variance : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>roll_rate : f32 , <span class="kw">pub </span>pitch_rate : f32 , <span class="kw">pub </span>yaw_rate : f32 , } <span class="kw">impl </span>CONTROL_SYSTEM_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">100usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x_acc = buf . get_f32_le () ; _struct . y_acc = buf . get_f32_le () ; _struct . z_acc = buf . get_f32_le () ; _struct . x_vel = buf . get_f32_le () ; _struct . y_vel = buf . get_f32_le () ; _struct . z_vel = buf . get_f32_le () ; _struct . x_pos = buf . get_f32_le () ; _struct . y_pos = buf . get_f32_le () ; _struct . z_pos = buf . get_f32_le () ; _struct . airspeed = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">3usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . vel_variance [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">3usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . pos_variance [idx] = val ; } <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . roll_rate = buf . get_f32_le () ; _struct . pitch_rate = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x_acc) ; _tmp . put_f32_le (<span class="self">self </span>. y_acc) ; _tmp . put_f32_le (<span class="self">self </span>. z_acc) ; _tmp . put_f32_le (<span class="self">self </span>. x_vel) ; _tmp . put_f32_le (<span class="self">self </span>. y_vel) ; _tmp . put_f32_le (<span class="self">self </span>. z_vel) ; _tmp . put_f32_le (<span class="self">self </span>. x_pos) ; _tmp . put_f32_le (<span class="self">self </span>. y_pos) ; _tmp . put_f32_le (<span class="self">self </span>. z_pos) ; _tmp . put_f32_le (<span class="self">self </span>. airspeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_variance { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_variance { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. roll_rate) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_DATA_DATA { <span class="kw">pub </span>ofs : u32 , <span class="kw">pub </span>id : u16 , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>data : Vec &lt; u8 , <span class="number">90 </span>&gt; , } <span class="kw">impl </span>LOG_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">97usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ofs = buf . get_u32_le () ; _struct . id = buf . get_u16_le () ; _struct . count = buf . get_u8 () ; <span class="kw">for _ in </span><span class="number">0 </span>.. <span class="number">90usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . data . push (val) . unwrap () ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ofs) ; _tmp . put_u16_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_REQUEST_READ_DATA { <span class="kw">pub </span>param_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , } <span class="kw">impl </span>PARAM_REQUEST_READ_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. param_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PING_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>seq : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>PING_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . seq = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_IMU2_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>SCALED_IMU2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTH_KEY_DATA { <span class="kw">pub </span>key : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>AUTH_KEY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">32usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . key [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. key { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RESPONSE_EVENT_ERROR_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>sequence_oldest_available : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>reason : MavEventErrorReason , } <span class="kw">impl </span>RESPONSE_EVENT_ERROR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">7usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . sequence_oldest_available = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . reason = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavEventErrorReason&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u16_le (<span class="self">self </span>. sequence_oldest_available) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. reason <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FENCE_STATUS_DATA { <span class="kw">pub </span>breach_time : u32 , <span class="kw">pub </span>breach_count : u16 , <span class="kw">pub </span>breach_status : u8 , <span class="kw">pub </span>breach_type : FenceBreach , } <span class="kw">impl </span>FENCE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . breach_time = buf . get_u32_le () ; _struct . breach_count = buf . get_u16_le () ; _struct . breach_status = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . breach_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;FenceBreach&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. breach_time) ; _tmp . put_u16_le (<span class="self">self </span>. breach_count) ; _tmp . put_u8 (<span class="self">self </span>. breach_status) ; _tmp . put_u8 (<span class="self">self </span>. breach_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS2_RAW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>dgps_age : u32 , <span class="kw">pub </span>eph : u16 , <span class="kw">pub </span>epv : u16 , <span class="kw">pub </span>vel : u16 , <span class="kw">pub </span>cog : u16 , <span class="kw">pub </span>fix_type : GpsFixType , <span class="kw">pub </span>satellites_visible : u8 , <span class="kw">pub </span>dgps_numch : u8 , } <span class="kw">impl </span>GPS2_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . dgps_age = buf . get_u32_le () ; _struct . eph = buf . get_u16_le () ; _struct . epv = buf . get_u16_le () ; _struct . vel = buf . get_u16_le () ; _struct . cog = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . fix_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GpsFixType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . satellites_visible = buf . get_u8 () ; _struct . dgps_numch = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_u32_le (<span class="self">self </span>. dgps_age) ; _tmp . put_u16_le (<span class="self">self </span>. eph) ; _tmp . put_u16_le (<span class="self">self </span>. epv) ; _tmp . put_u16_le (<span class="self">self </span>. vel) ; _tmp . put_u16_le (<span class="self">self </span>. cog) ; _tmp . put_u8 (<span class="self">self </span>. fix_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; _tmp . put_u8 (<span class="self">self </span>. dgps_numch) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_VALUE_DATA { <span class="kw">pub </span>param_value : f32 , <span class="kw">pub </span>param_count : u16 , <span class="kw">pub </span>param_index : u16 , <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_type : MavParamType , } <span class="kw">impl </span>PARAM_VALUE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_value = buf . get_f32_le () ; _struct . param_count = buf . get_u16_le () ; _struct . param_index = buf . get_u16_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">16usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . param_id [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param_value) ; _tmp . put_u16_le (<span class="self">self </span>. param_count) ; _tmp . put_u16_le (<span class="self">self </span>. param_index) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_QUATERNION_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , <span class="kw">pub </span>covariance : [f32 ; <span class="number">9</span>] , } <span class="kw">impl </span>ATTITUDE_QUATERNION_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">72usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">4usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . q [idx] = val ; } _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">9usize </span>{ <span class="kw">let </span>val = buf . get_f32_le () ; _struct . covariance [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. covariance { _tmp . put_f32_le (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_AUTHENTICATION_DATA { <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>authentication_type : MavOdidAuthType , <span class="kw">pub </span>data_page : u8 , <span class="kw">pub </span>last_page_index : u8 , <span class="kw">pub </span>length : u8 , <span class="kw">pub </span>authentication_data : [u8 ; <span class="number">23</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_AUTHENTICATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">20usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . id_or_mac [idx] = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . authentication_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidAuthType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . data_page = buf . get_u8 () ; _struct . last_page_index = buf . get_u8 () ; _struct . length = buf . get_u8 () ; <span class="kw">for </span>idx <span class="kw">in </span><span class="number">0 </span>.. <span class="number">23usize </span>{ <span class="kw">let </span>val = buf . get_u8 () ; _struct . authentication_data [idx] = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. authentication_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. data_page) ; _tmp . put_u8 (<span class="self">self </span>. last_page_index) ; _tmp . put_u8 (<span class="self">self </span>. length) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. authentication_data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EFI_STATUS_DATA { <span class="kw">pub </span>ecu_index : f32 , <span class="kw">pub </span>rpm : f32 , <span class="kw">pub </span>fuel_consumed : f32 , <span class="kw">pub </span>fuel_flow : f32 , <span class="kw">pub </span>engine_load : f32 , <span class="kw">pub </span>throttle_position : f32 , <span class="kw">pub </span>spark_dwell_time : f32 , <span class="kw">pub </span>barometric_pressure : f32 , <span class="kw">pub </span>intake_manifold_pressure : f32 , <span class="kw">pub </span>intake_manifold_temperature : f32 , <span class="kw">pub </span>cylinder_head_temperature : f32 , <span class="kw">pub </span>ignition_timing : f32 , <span class="kw">pub </span>injection_time : f32 , <span class="kw">pub </span>exhaust_gas_temperature : f32 , <span class="kw">pub </span>throttle_out : f32 , <span class="kw">pub </span>pt_compensation : f32 , <span class="kw">pub </span>health : u8 , } <span class="kw">impl </span>EFI_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">65usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ecu_index = buf . get_f32_le () ; _struct . rpm = buf . get_f32_le () ; _struct . fuel_consumed = buf . get_f32_le () ; _struct . fuel_flow = buf . get_f32_le () ; _struct . engine_load = buf . get_f32_le () ; _struct . throttle_position = buf . get_f32_le () ; _struct . spark_dwell_time = buf . get_f32_le () ; _struct . barometric_pressure = buf . get_f32_le () ; _struct . intake_manifold_pressure = buf . get_f32_le () ; _struct . intake_manifold_temperature = buf . get_f32_le () ; _struct . cylinder_head_temperature = buf . get_f32_le () ; _struct . ignition_timing = buf . get_f32_le () ; _struct . injection_time = buf . get_f32_le () ; _struct . exhaust_gas_temperature = buf . get_f32_le () ; _struct . throttle_out = buf . get_f32_le () ; _struct . pt_compensation = buf . get_f32_le () ; _struct . health = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. ecu_index) ; _tmp . put_f32_le (<span class="self">self </span>. rpm) ; _tmp . put_f32_le (<span class="self">self </span>. fuel_consumed) ; _tmp . put_f32_le (<span class="self">self </span>. fuel_flow) ; _tmp . put_f32_le (<span class="self">self </span>. engine_load) ; _tmp . put_f32_le (<span class="self">self </span>. throttle_position) ; _tmp . put_f32_le (<span class="self">self </span>. spark_dwell_time) ; _tmp . put_f32_le (<span class="self">self </span>. barometric_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. intake_manifold_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. intake_manifold_temperature) ; _tmp . put_f32_le (<span class="self">self </span>. cylinder_head_temperature) ; _tmp . put_f32_le (<span class="self">self </span>. ignition_timing) ; _tmp . put_f32_le (<span class="self">self </span>. injection_time) ; _tmp . put_f32_le (<span class="self">self </span>. exhaust_gas_temperature) ; _tmp . put_f32_le (<span class="self">self </span>. throttle_out) ; _tmp . put_f32_le (<span class="self">self </span>. pt_compensation) ; _tmp . put_u8 (<span class="self">self </span>. health) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Debug , Clone , PartialEq , Default)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VIDEO_STREAM_STATUS_DATA { <span class="kw">pub </span>framerate : f32 , <span class="kw">pub </span>bitrate : u32 , <span class="kw">pub </span>flags : VideoStreamStatusFlags , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>rotation : u16 , <span class="kw">pub </span>hfov : u16 , <span class="kw">pub </span>stream_id : u8 , } <span class="kw">impl </span>VIDEO_STREAM_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">19usize </span>; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . framerate = buf . get_f32_le () ; _struct . bitrate = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;VideoStreamStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . rotation = buf . get_u16_le () ; _struct . hfov = buf . get_u16_le () ; _struct . stream_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. framerate) ; _tmp . put_u32_le (<span class="self">self </span>. bitrate) ; _tmp . put_u16_le (<span class="self">self </span>. flags <span class="kw">as </span>u16) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. rotation) ; _tmp . put_u16_le (<span class="self">self </span>. hfov) ; _tmp . put_u8 (<span class="self">self </span>. stream_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } # [derive (Clone , PartialEq , Debug)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMessage { UTM_GLOBAL_POSITION (UTM_GLOBAL_POSITION_DATA) , VISION_POSITION_ESTIMATE (VISION_POSITION_ESTIMATE_DATA) , SET_ACTUATOR_CONTROL_TARGET (SET_ACTUATOR_CONTROL_TARGET_DATA) , PARAM_EXT_VALUE (PARAM_EXT_VALUE_DATA) , GPS_STATUS (GPS_STATUS_DATA) , DEBUG (DEBUG_DATA) , GIMBAL_MANAGER_SET_ATTITUDE (GIMBAL_MANAGER_SET_ATTITUDE_DATA) , RESOURCE_REQUEST (RESOURCE_REQUEST_DATA) , ACTUATOR_OUTPUT_STATUS (ACTUATOR_OUTPUT_STATUS_DATA) , TRAJECTORY_REPRESENTATION_BEZIER (TRAJECTORY_REPRESENTATION_BEZIER_DATA) , GIMBAL_MANAGER_STATUS (GIMBAL_MANAGER_STATUS_DATA) , REQUEST_EVENT (REQUEST_EVENT_DATA) , OPEN_DRONE_ID_SYSTEM_UPDATE (OPEN_DRONE_ID_SYSTEM_UPDATE_DATA) , POWER_STATUS (POWER_STATUS_DATA) , RC_CHANNELS_SCALED (RC_CHANNELS_SCALED_DATA) , MISSION_REQUEST_LIST (MISSION_REQUEST_LIST_DATA) , ATT_POS_MOCAP (ATT_POS_MOCAP_DATA) , PARAM_MAP_RC (PARAM_MAP_RC_DATA) , LOG_REQUEST_LIST (LOG_REQUEST_LIST_DATA) , SERVO_OUTPUT_RAW (SERVO_OUTPUT_RAW_DATA) , CAMERA_FOV_STATUS (CAMERA_FOV_STATUS_DATA) , ODOMETRY (ODOMETRY_DATA) , WINCH_STATUS (WINCH_STATUS_DATA) , SAFETY_ALLOWED_AREA (SAFETY_ALLOWED_AREA_DATA) , DATA_TRANSMISSION_HANDSHAKE (DATA_TRANSMISSION_HANDSHAKE_DATA) , SET_MODE (SET_MODE_DATA) , COMMAND_LONG (COMMAND_LONG_DATA) , SMART_BATTERY_INFO (SMART_BATTERY_INFO_DATA) , POSITION_TARGET_LOCAL_NED (POSITION_TARGET_LOCAL_NED_DATA) , HIL_STATE (HIL_STATE_DATA) , SET_POSITION_TARGET_LOCAL_NED (SET_POSITION_TARGET_LOCAL_NED_DATA) , UAVCAN_NODE_INFO (UAVCAN_NODE_INFO_DATA) , TERRAIN_DATA (TERRAIN_DATA_DATA) , ADSB_VEHICLE (ADSB_VEHICLE_DATA) , DEBUG_VECT (DEBUG_VECT_DATA) , ENCAPSULATED_DATA (ENCAPSULATED_DATA_DATA) , BUTTON_CHANGE (BUTTON_CHANGE_DATA) , SET_GPS_GLOBAL_ORIGIN (SET_GPS_GLOBAL_ORIGIN_DATA) , MANUAL_CONTROL (MANUAL_CONTROL_DATA) , RAW_PRESSURE (RAW_PRESSURE_DATA) , MISSION_ITEM (MISSION_ITEM_DATA) , ORBIT_EXECUTION_STATUS (ORBIT_EXECUTION_STATUS_DATA) , MAG_CAL_REPORT (MAG_CAL_REPORT_DATA) , HEARTBEAT (HEARTBEAT_DATA) , GIMBAL_DEVICE_ATTITUDE_STATUS (GIMBAL_DEVICE_ATTITUDE_STATUS_DATA) , OPEN_DRONE_ID_OPERATOR_ID (OPEN_DRONE_ID_OPERATOR_ID_DATA) , LINK_NODE_STATUS (LINK_NODE_STATUS_DATA) , MEMORY_VECT (MEMORY_VECT_DATA) , EXTENDED_SYS_STATE (EXTENDED_SYS_STATE_DATA) , NAMED_VALUE_INT (NAMED_VALUE_INT_DATA) , OPEN_DRONE_ID_SYSTEM (OPEN_DRONE_ID_SYSTEM_DATA) , AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA) , HIL_SENSOR (HIL_SENSOR_DATA) , WHEEL_DISTANCE (WHEEL_DISTANCE_DATA) , OPTICAL_FLOW_RAD (OPTICAL_FLOW_RAD_DATA) , PARAM_EXT_ACK (PARAM_EXT_ACK_DATA) , ATTITUDE_QUATERNION (ATTITUDE_QUATERNION_DATA) , HYGROMETER_SENSOR (HYGROMETER_SENSOR_DATA) , SCALED_PRESSURE (SCALED_PRESSURE_DATA) , TUNNEL (TUNNEL_DATA) , TERRAIN_CHECK (TERRAIN_CHECK_DATA) , CAMERA_CAPTURE_STATUS (CAMERA_CAPTURE_STATUS_DATA) , SUPPORTED_TUNES (SUPPORTED_TUNES_DATA) , PARAM_EXT_REQUEST_READ (PARAM_EXT_REQUEST_READ_DATA) , COMMAND_INT (COMMAND_INT_DATA) , UAVCAN_NODE_STATUS (UAVCAN_NODE_STATUS_DATA) , AUTOPILOT_VERSION (AUTOPILOT_VERSION_DATA) , LOCAL_POSITION_NED (LOCAL_POSITION_NED_DATA) , MISSION_WRITE_PARTIAL_LIST (MISSION_WRITE_PARTIAL_LIST_DATA) , LANDING_TARGET (LANDING_TARGET_DATA) , GPS_GLOBAL_ORIGIN (GPS_GLOBAL_ORIGIN_DATA) , SET_ATTITUDE_TARGET (SET_ATTITUDE_TARGET_DATA) , ESC_STATUS (ESC_STATUS_DATA) , OPEN_DRONE_ID_ARM_STATUS (OPEN_DRONE_ID_ARM_STATUS_DATA) , HIL_STATE_QUATERNION (HIL_STATE_QUATERNION_DATA) , GPS2_RTK (GPS2_RTK_DATA) , POSITION_TARGET_GLOBAL_INT (POSITION_TARGET_GLOBAL_INT_DATA) , PARAM_SET (PARAM_SET_DATA) , SETUP_SIGNING (SETUP_SIGNING_DATA) , MISSION_CURRENT (MISSION_CURRENT_DATA) , MANUAL_SETPOINT (MANUAL_SETPOINT_DATA) , GLOBAL_POSITION_INT_COV (GLOBAL_POSITION_INT_COV_DATA) , V2_EXTENSION (V2_EXTENSION_DATA) , COLLISION (COLLISION_DATA) , FOLLOW_TARGET (FOLLOW_TARGET_DATA) , OPEN_DRONE_ID_LOCATION (OPEN_DRONE_ID_LOCATION_DATA) , OPTICAL_FLOW (OPTICAL_FLOW_DATA) , CHANGE_OPERATOR_CONTROL_ACK (CHANGE_OPERATOR_CONTROL_ACK_DATA) , UAVIONIX_ADSB_OUT_DYNAMIC (UAVIONIX_ADSB_OUT_DYNAMIC_DATA) , LOCAL_POSITION_NED_COV (LOCAL_POSITION_NED_COV_DATA) , COMPONENT_METADATA (COMPONENT_METADATA_DATA) , LOGGING_ACK (LOGGING_ACK_DATA) , LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA) , OPEN_DRONE_ID_BASIC_ID (OPEN_DRONE_ID_BASIC_ID_DATA) , DATA_STREAM (DATA_STREAM_DATA) , GIMBAL_DEVICE_SET_ATTITUDE (GIMBAL_DEVICE_SET_ATTITUDE_DATA) , STORAGE_INFORMATION (STORAGE_INFORMATION_DATA) , MISSION_REQUEST_PARTIAL_LIST (MISSION_REQUEST_PARTIAL_LIST_DATA) , CAMERA_TRIGGER (CAMERA_TRIGGER_DATA) , RAW_RPM (RAW_RPM_DATA) , PLAY_TUNE (PLAY_TUNE_DATA) , HIL_CONTROLS (HIL_CONTROLS_DATA) , RADIO_STATUS (RADIO_STATUS_DATA) , LOG_ENTRY (LOG_ENTRY_DATA) , REQUEST_DATA_STREAM (REQUEST_DATA_STREAM_DATA) , VISION_SPEED_ESTIMATE (VISION_SPEED_ESTIMATE_DATA) , ATTITUDE (ATTITUDE_DATA) , OPEN_DRONE_ID_SELF_ID (OPEN_DRONE_ID_SELF_ID_DATA) , COMMAND_ACK (COMMAND_ACK_DATA) , VIBRATION (VIBRATION_DATA) , VIDEO_STREAM_INFORMATION (VIDEO_STREAM_INFORMATION_DATA) , TRAJECTORY_REPRESENTATION_WAYPOINTS (TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA) , COMPONENT_INFORMATION (COMPONENT_INFORMATION_DATA) , TIME_ESTIMATE_TO_TARGET (TIME_ESTIMATE_TO_TARGET_DATA) , MISSION_ITEM_INT (MISSION_ITEM_INT_DATA) , EVENT (EVENT_DATA) , LOG_REQUEST_END (LOG_REQUEST_END_DATA) , HIL_ACTUATOR_CONTROLS (HIL_ACTUATOR_CONTROLS_DATA) , PARAM_REQUEST_LIST (PARAM_REQUEST_LIST_DATA) , RAW_IMU (RAW_IMU_DATA) , MISSION_COUNT (MISSION_COUNT_DATA) , SAFETY_SET_ALLOWED_AREA (SAFETY_SET_ALLOWED_AREA_DATA) , UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA) , GIMBAL_DEVICE_INFORMATION (GIMBAL_DEVICE_INFORMATION_DATA) , CELLULAR_CONFIG (CELLULAR_CONFIG_DATA) , AIS_VESSEL (AIS_VESSEL_DATA) , CAMERA_TRACKING_GEO_STATUS (CAMERA_TRACKING_GEO_STATUS_DATA) , HIGHRES_IMU (HIGHRES_IMU_DATA) , GPS_RAW_INT (GPS_RAW_INT_DATA) , MISSION_ITEM_REACHED (MISSION_ITEM_REACHED_DATA) , HIL_GPS (HIL_GPS_DATA) , GPS_RTK (GPS_RTK_DATA) , MISSION_ACK (MISSION_ACK_DATA) , SYSTEM_TIME (SYSTEM_TIME_DATA) , ESTIMATOR_STATUS (ESTIMATOR_STATUS_DATA) , SET_POSITION_TARGET_GLOBAL_INT (SET_POSITION_TARGET_GLOBAL_INT_DATA) , SET_HOME_POSITION (SET_HOME_POSITION_DATA) , GENERATOR_STATUS (GENERATOR_STATUS_DATA) , GPS_RTCM_DATA (GPS_RTCM_DATA_DATA) , OBSTACLE_DISTANCE (OBSTACLE_DISTANCE_DATA) , COMMAND_CANCEL (COMMAND_CANCEL_DATA) , MESSAGE_INTERVAL (MESSAGE_INTERVAL_DATA) , MISSION_SET_CURRENT (MISSION_SET_CURRENT_DATA) , SCALED_PRESSURE3 (SCALED_PRESSURE3_DATA) , UAVIONIX_ADSB_OUT_CFG (UAVIONIX_ADSB_OUT_CFG_DATA) , SIM_STATE (SIM_STATE_DATA) , GLOBAL_POSITION_INT (GLOBAL_POSITION_INT_DATA) , CURRENT_EVENT_SEQUENCE (CURRENT_EVENT_SEQUENCE_DATA) , BATTERY_STATUS (BATTERY_STATUS_DATA) , WIND_COV (WIND_COV_DATA) , STATUSTEXT (STATUSTEXT_DATA) , CANFD_FRAME (CANFD_FRAME_DATA) , GPS_INPUT (GPS_INPUT_DATA) , SCALED_IMU3 (SCALED_IMU3_DATA) , RC_CHANNELS_RAW (RC_CHANNELS_RAW_DATA) , MISSION_CLEAR_ALL (MISSION_CLEAR_ALL_DATA) , GIMBAL_MANAGER_SET_PITCHYAW (GIMBAL_MANAGER_SET_PITCHYAW_DATA) , GIMBAL_MANAGER_SET_MANUAL_CONTROL (GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA) , PROTOCOL_VERSION (PROTOCOL_VERSION_DATA) , PARAM_EXT_SET (PARAM_EXT_SET_DATA) , MISSION_REQUEST_INT (MISSION_REQUEST_INT_DATA) , SERIAL_CONTROL (SERIAL_CONTROL_DATA) , ACTUATOR_CONTROL_TARGET (ACTUATOR_CONTROL_TARGET_DATA) , ISBD_LINK_STATUS (ISBD_LINK_STATUS_DATA) , LOGGING_DATA_ACKED (LOGGING_DATA_ACKED_DATA) , HIL_RC_INPUTS_RAW (HIL_RC_INPUTS_RAW_DATA) , RC_CHANNELS (RC_CHANNELS_DATA) , NAMED_VALUE_FLOAT (NAMED_VALUE_FLOAT_DATA) , CAN_FILTER_MODIFY (CAN_FILTER_MODIFY_DATA) , ESC_INFO (ESC_INFO_DATA) , MISSION_REQUEST (MISSION_REQUEST_DATA) , HIL_OPTICAL_FLOW (HIL_OPTICAL_FLOW_DATA) , HIGH_LATENCY2 (HIGH_LATENCY2_DATA) , SCALED_IMU (SCALED_IMU_DATA) , LOG_ERASE (LOG_ERASE_DATA) , GPS_INJECT_DATA (GPS_INJECT_DATA_DATA) , LOGGING_DATA (LOGGING_DATA_DATA) , HIGH_LATENCY (HIGH_LATENCY_DATA) , ALTITUDE (ALTITUDE_DATA) , TERRAIN_REQUEST (TERRAIN_REQUEST_DATA) , PARAM_EXT_REQUEST_LIST (PARAM_EXT_REQUEST_LIST_DATA) , LOG_REQUEST_DATA (LOG_REQUEST_DATA_DATA) , DEBUG_FLOAT_ARRAY (DEBUG_FLOAT_ARRAY_DATA) , RC_CHANNELS_OVERRIDE (RC_CHANNELS_OVERRIDE_DATA) , GLOBAL_VISION_POSITION_ESTIMATE (GLOBAL_VISION_POSITION_ESTIMATE_DATA) , OPEN_DRONE_ID_MESSAGE_PACK (OPEN_DRONE_ID_MESSAGE_PACK_DATA) , FILE_TRANSFER_PROTOCOL (FILE_TRANSFER_PROTOCOL_DATA) , CAMERA_IMAGE_CAPTURED (CAMERA_IMAGE_CAPTURED_DATA) , CELLULAR_STATUS (CELLULAR_STATUS_DATA) , DISTANCE_SENSOR (DISTANCE_SENSOR_DATA) , VICON_POSITION_ESTIMATE (VICON_POSITION_ESTIMATE_DATA) , GIMBAL_MANAGER_INFORMATION (GIMBAL_MANAGER_INFORMATION_DATA) , VFR_HUD (VFR_HUD_DATA) , CHANGE_OPERATOR_CONTROL (CHANGE_OPERATOR_CONTROL_DATA) , HOME_POSITION (HOME_POSITION_DATA) , CAN_FRAME (CAN_FRAME_DATA) , ATTITUDE_TARGET (ATTITUDE_TARGET_DATA) , TIMESYNC (TIMESYNC_DATA) , PLAY_TUNE_V2 (PLAY_TUNE_V2_DATA) , SYS_STATUS (SYS_STATUS_DATA) , CAMERA_SETTINGS (CAMERA_SETTINGS_DATA) , FLIGHT_INFORMATION (FLIGHT_INFORMATION_DATA) , MOUNT_ORIENTATION (MOUNT_ORIENTATION_DATA) , NAV_CONTROLLER_OUTPUT (NAV_CONTROLLER_OUTPUT_DATA) , CAMERA_INFORMATION (CAMERA_INFORMATION_DATA) , SCALED_PRESSURE2 (SCALED_PRESSURE2_DATA) , WIFI_CONFIG_AP (WIFI_CONFIG_AP_DATA) , ONBOARD_COMPUTER_STATUS (ONBOARD_COMPUTER_STATUS_DATA) , TERRAIN_REPORT (TERRAIN_REPORT_DATA) , CAMERA_TRACKING_IMAGE_STATUS (CAMERA_TRACKING_IMAGE_STATUS_DATA) , CONTROL_SYSTEM_STATE (CONTROL_SYSTEM_STATE_DATA) , LOG_DATA (LOG_DATA_DATA) , PARAM_REQUEST_READ (PARAM_REQUEST_READ_DATA) , PING (PING_DATA) , SCALED_IMU2 (SCALED_IMU2_DATA) , AUTH_KEY (AUTH_KEY_DATA) , RESPONSE_EVENT_ERROR (RESPONSE_EVENT_ERROR_DATA) , FENCE_STATUS (FENCE_STATUS_DATA) , GPS2_RAW (GPS2_RAW_DATA) , PARAM_VALUE (PARAM_VALUE_DATA) , ATTITUDE_QUATERNION_COV (ATTITUDE_QUATERNION_COV_DATA) , OPEN_DRONE_ID_AUTHENTICATION (OPEN_DRONE_ID_AUTHENTICATION_DATA) , EFI_STATUS (EFI_STATUS_DATA) , VIDEO_STREAM_STATUS (VIDEO_STREAM_STATUS_DATA) , } <span class="kw">impl </span>Message <span class="kw">for </span>MavMessage { <span class="kw">fn </span>parse (version : MavlinkVersion , id : u32 , payload : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">match </span>id { <span class="number">340u32 </span>=&gt; UTM_GLOBAL_POSITION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UTM_GLOBAL_POSITION) , <span class="number">102u32 </span>=&gt; VISION_POSITION_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VISION_POSITION_ESTIMATE) , <span class="number">139u32 </span>=&gt; SET_ACTUATOR_CONTROL_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET) , <span class="number">322u32 </span>=&gt; PARAM_EXT_VALUE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_VALUE) , <span class="number">25u32 </span>=&gt; GPS_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_STATUS) , <span class="number">254u32 </span>=&gt; DEBUG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEBUG) , <span class="number">282u32 </span>=&gt; GIMBAL_MANAGER_SET_ATTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE) , <span class="number">142u32 </span>=&gt; RESOURCE_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RESOURCE_REQUEST) , <span class="number">375u32 </span>=&gt; ACTUATOR_OUTPUT_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS) , <span class="number">333u32 </span>=&gt; TRAJECTORY_REPRESENTATION_BEZIER_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER) , <span class="number">281u32 </span>=&gt; GIMBAL_MANAGER_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_STATUS) , <span class="number">412u32 </span>=&gt; REQUEST_EVENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: REQUEST_EVENT) , <span class="number">12919u32 </span>=&gt; OPEN_DRONE_ID_SYSTEM_UPDATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE) , <span class="number">125u32 </span>=&gt; POWER_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: POWER_STATUS) , <span class="number">34u32 </span>=&gt; RC_CHANNELS_SCALED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS_SCALED) , <span class="number">43u32 </span>=&gt; MISSION_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST_LIST) , <span class="number">138u32 </span>=&gt; ATT_POS_MOCAP_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATT_POS_MOCAP) , <span class="number">50u32 </span>=&gt; PARAM_MAP_RC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_MAP_RC) , <span class="number">117u32 </span>=&gt; LOG_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_REQUEST_LIST) , <span class="number">36u32 </span>=&gt; SERVO_OUTPUT_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SERVO_OUTPUT_RAW) , <span class="number">271u32 </span>=&gt; CAMERA_FOV_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_FOV_STATUS) , <span class="number">331u32 </span>=&gt; ODOMETRY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ODOMETRY) , <span class="number">9005u32 </span>=&gt; WINCH_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WINCH_STATUS) , <span class="number">55u32 </span>=&gt; SAFETY_ALLOWED_AREA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SAFETY_ALLOWED_AREA) , <span class="number">130u32 </span>=&gt; DATA_TRANSMISSION_HANDSHAKE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE) , <span class="number">11u32 </span>=&gt; SET_MODE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_MODE) , <span class="number">76u32 </span>=&gt; COMMAND_LONG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_LONG) , <span class="number">370u32 </span>=&gt; SMART_BATTERY_INFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SMART_BATTERY_INFO) , <span class="number">85u32 </span>=&gt; POSITION_TARGET_LOCAL_NED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED) , <span class="number">90u32 </span>=&gt; HIL_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_STATE) , <span class="number">84u32 </span>=&gt; SET_POSITION_TARGET_LOCAL_NED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED) , <span class="number">311u32 </span>=&gt; UAVCAN_NODE_INFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVCAN_NODE_INFO) , <span class="number">134u32 </span>=&gt; TERRAIN_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_DATA) , <span class="number">246u32 </span>=&gt; ADSB_VEHICLE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ADSB_VEHICLE) , <span class="number">250u32 </span>=&gt; DEBUG_VECT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEBUG_VECT) , <span class="number">131u32 </span>=&gt; ENCAPSULATED_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ENCAPSULATED_DATA) , <span class="number">257u32 </span>=&gt; BUTTON_CHANGE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: BUTTON_CHANGE) , <span class="number">48u32 </span>=&gt; SET_GPS_GLOBAL_ORIGIN_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN) , <span class="number">69u32 </span>=&gt; MANUAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MANUAL_CONTROL) , <span class="number">28u32 </span>=&gt; RAW_PRESSURE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RAW_PRESSURE) , <span class="number">39u32 </span>=&gt; MISSION_ITEM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ITEM) , <span class="number">360u32 </span>=&gt; ORBIT_EXECUTION_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ORBIT_EXECUTION_STATUS) , <span class="number">192u32 </span>=&gt; MAG_CAL_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MAG_CAL_REPORT) , <span class="number">0u32 </span>=&gt; HEARTBEAT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HEARTBEAT) , <span class="number">285u32 </span>=&gt; GIMBAL_DEVICE_ATTITUDE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS) , <span class="number">12905u32 </span>=&gt; OPEN_DRONE_ID_OPERATOR_ID_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID) , <span class="number">8u32 </span>=&gt; LINK_NODE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LINK_NODE_STATUS) , <span class="number">249u32 </span>=&gt; MEMORY_VECT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MEMORY_VECT) , <span class="number">245u32 </span>=&gt; EXTENDED_SYS_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EXTENDED_SYS_STATE) , <span class="number">252u32 </span>=&gt; NAMED_VALUE_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: NAMED_VALUE_INT) , <span class="number">12904u32 </span>=&gt; OPEN_DRONE_ID_SYSTEM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM) , <span class="number">286u32 </span>=&gt; AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE) , <span class="number">107u32 </span>=&gt; HIL_SENSOR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_SENSOR) , <span class="number">9000u32 </span>=&gt; WHEEL_DISTANCE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WHEEL_DISTANCE) , <span class="number">106u32 </span>=&gt; OPTICAL_FLOW_RAD_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPTICAL_FLOW_RAD) , <span class="number">324u32 </span>=&gt; PARAM_EXT_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_ACK) , <span class="number">31u32 </span>=&gt; ATTITUDE_QUATERNION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE_QUATERNION) , <span class="number">12920u32 </span>=&gt; HYGROMETER_SENSOR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HYGROMETER_SENSOR) , <span class="number">29u32 </span>=&gt; SCALED_PRESSURE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_PRESSURE) , <span class="number">385u32 </span>=&gt; TUNNEL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TUNNEL) , <span class="number">135u32 </span>=&gt; TERRAIN_CHECK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_CHECK) , <span class="number">262u32 </span>=&gt; CAMERA_CAPTURE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_CAPTURE_STATUS) , <span class="number">401u32 </span>=&gt; SUPPORTED_TUNES_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SUPPORTED_TUNES) , <span class="number">320u32 </span>=&gt; PARAM_EXT_REQUEST_READ_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_REQUEST_READ) , <span class="number">75u32 </span>=&gt; COMMAND_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_INT) , <span class="number">310u32 </span>=&gt; UAVCAN_NODE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVCAN_NODE_STATUS) , <span class="number">148u32 </span>=&gt; AUTOPILOT_VERSION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTOPILOT_VERSION) , <span class="number">32u32 </span>=&gt; LOCAL_POSITION_NED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOCAL_POSITION_NED) , <span class="number">38u32 </span>=&gt; MISSION_WRITE_PARTIAL_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST) , <span class="number">149u32 </span>=&gt; LANDING_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LANDING_TARGET) , <span class="number">49u32 </span>=&gt; GPS_GLOBAL_ORIGIN_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_GLOBAL_ORIGIN) , <span class="number">82u32 </span>=&gt; SET_ATTITUDE_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_ATTITUDE_TARGET) , <span class="number">291u32 </span>=&gt; ESC_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_STATUS) , <span class="number">12918u32 </span>=&gt; OPEN_DRONE_ID_ARM_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS) , <span class="number">115u32 </span>=&gt; HIL_STATE_QUATERNION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_STATE_QUATERNION) , <span class="number">128u32 </span>=&gt; GPS2_RTK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS2_RTK) , <span class="number">87u32 </span>=&gt; POSITION_TARGET_GLOBAL_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT) , <span class="number">23u32 </span>=&gt; PARAM_SET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_SET) , <span class="number">256u32 </span>=&gt; SETUP_SIGNING_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SETUP_SIGNING) , <span class="number">42u32 </span>=&gt; MISSION_CURRENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_CURRENT) , <span class="number">81u32 </span>=&gt; MANUAL_SETPOINT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MANUAL_SETPOINT) , <span class="number">63u32 </span>=&gt; GLOBAL_POSITION_INT_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GLOBAL_POSITION_INT_COV) , <span class="number">248u32 </span>=&gt; V2_EXTENSION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: V2_EXTENSION) , <span class="number">247u32 </span>=&gt; COLLISION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COLLISION) , <span class="number">144u32 </span>=&gt; FOLLOW_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FOLLOW_TARGET) , <span class="number">12901u32 </span>=&gt; OPEN_DRONE_ID_LOCATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION) , <span class="number">100u32 </span>=&gt; OPTICAL_FLOW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPTICAL_FLOW) , <span class="number">6u32 </span>=&gt; CHANGE_OPERATOR_CONTROL_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK) , <span class="number">10002u32 </span>=&gt; UAVIONIX_ADSB_OUT_DYNAMIC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC) , <span class="number">64u32 </span>=&gt; LOCAL_POSITION_NED_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOCAL_POSITION_NED_COV) , <span class="number">397u32 </span>=&gt; COMPONENT_METADATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMPONENT_METADATA) , <span class="number">268u32 </span>=&gt; LOGGING_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOGGING_ACK) , <span class="number">89u32 </span>=&gt; LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET) , <span class="number">12900u32 </span>=&gt; OPEN_DRONE_ID_BASIC_ID_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID) , <span class="number">67u32 </span>=&gt; DATA_STREAM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA_STREAM) , <span class="number">284u32 </span>=&gt; GIMBAL_DEVICE_SET_ATTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE) , <span class="number">261u32 </span>=&gt; STORAGE_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: STORAGE_INFORMATION) , <span class="number">37u32 </span>=&gt; MISSION_REQUEST_PARTIAL_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST) , <span class="number">112u32 </span>=&gt; CAMERA_TRIGGER_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_TRIGGER) , <span class="number">339u32 </span>=&gt; RAW_RPM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RAW_RPM) , <span class="number">258u32 </span>=&gt; PLAY_TUNE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PLAY_TUNE) , <span class="number">91u32 </span>=&gt; HIL_CONTROLS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_CONTROLS) , <span class="number">109u32 </span>=&gt; RADIO_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RADIO_STATUS) , <span class="number">118u32 </span>=&gt; LOG_ENTRY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_ENTRY) , <span class="number">66u32 </span>=&gt; REQUEST_DATA_STREAM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: REQUEST_DATA_STREAM) , <span class="number">103u32 </span>=&gt; VISION_SPEED_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VISION_SPEED_ESTIMATE) , <span class="number">30u32 </span>=&gt; ATTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE) , <span class="number">12903u32 </span>=&gt; OPEN_DRONE_ID_SELF_ID_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID) , <span class="number">77u32 </span>=&gt; COMMAND_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_ACK) , <span class="number">241u32 </span>=&gt; VIBRATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VIBRATION) , <span class="number">269u32 </span>=&gt; VIDEO_STREAM_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VIDEO_STREAM_INFORMATION) , <span class="number">332u32 </span>=&gt; TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS) , <span class="number">395u32 </span>=&gt; COMPONENT_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMPONENT_INFORMATION) , <span class="number">380u32 </span>=&gt; TIME_ESTIMATE_TO_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET) , <span class="number">73u32 </span>=&gt; MISSION_ITEM_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ITEM_INT) , <span class="number">410u32 </span>=&gt; EVENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EVENT) , <span class="number">122u32 </span>=&gt; LOG_REQUEST_END_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_REQUEST_END) , <span class="number">93u32 </span>=&gt; HIL_ACTUATOR_CONTROLS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS) , <span class="number">21u32 </span>=&gt; PARAM_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_REQUEST_LIST) , <span class="number">27u32 </span>=&gt; RAW_IMU_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RAW_IMU) , <span class="number">44u32 </span>=&gt; MISSION_COUNT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_COUNT) , <span class="number">54u32 </span>=&gt; SAFETY_SET_ALLOWED_AREA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA) , <span class="number">10003u32 </span>=&gt; UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT) , <span class="number">283u32 </span>=&gt; GIMBAL_DEVICE_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION) , <span class="number">336u32 </span>=&gt; CELLULAR_CONFIG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CELLULAR_CONFIG) , <span class="number">301u32 </span>=&gt; AIS_VESSEL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AIS_VESSEL) , <span class="number">276u32 </span>=&gt; CAMERA_TRACKING_GEO_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS) , <span class="number">105u32 </span>=&gt; HIGHRES_IMU_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIGHRES_IMU) , <span class="number">24u32 </span>=&gt; GPS_RAW_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_RAW_INT) , <span class="number">46u32 </span>=&gt; MISSION_ITEM_REACHED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ITEM_REACHED) , <span class="number">113u32 </span>=&gt; HIL_GPS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_GPS) , <span class="number">127u32 </span>=&gt; GPS_RTK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_RTK) , <span class="number">47u32 </span>=&gt; MISSION_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ACK) , <span class="number">2u32 </span>=&gt; SYSTEM_TIME_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SYSTEM_TIME) , <span class="number">230u32 </span>=&gt; ESTIMATOR_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESTIMATOR_STATUS) , <span class="number">86u32 </span>=&gt; SET_POSITION_TARGET_GLOBAL_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT) , <span class="number">243u32 </span>=&gt; SET_HOME_POSITION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_HOME_POSITION) , <span class="number">373u32 </span>=&gt; GENERATOR_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GENERATOR_STATUS) , <span class="number">233u32 </span>=&gt; GPS_RTCM_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_RTCM_DATA) , <span class="number">330u32 </span>=&gt; OBSTACLE_DISTANCE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OBSTACLE_DISTANCE) , <span class="number">80u32 </span>=&gt; COMMAND_CANCEL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_CANCEL) , <span class="number">244u32 </span>=&gt; MESSAGE_INTERVAL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MESSAGE_INTERVAL) , <span class="number">41u32 </span>=&gt; MISSION_SET_CURRENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_SET_CURRENT) , <span class="number">143u32 </span>=&gt; SCALED_PRESSURE3_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_PRESSURE3) , <span class="number">10001u32 </span>=&gt; UAVIONIX_ADSB_OUT_CFG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG) , <span class="number">108u32 </span>=&gt; SIM_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SIM_STATE) , <span class="number">33u32 </span>=&gt; GLOBAL_POSITION_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GLOBAL_POSITION_INT) , <span class="number">411u32 </span>=&gt; CURRENT_EVENT_SEQUENCE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE) , <span class="number">147u32 </span>=&gt; BATTERY_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: BATTERY_STATUS) , <span class="number">231u32 </span>=&gt; WIND_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WIND_COV) , <span class="number">253u32 </span>=&gt; STATUSTEXT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: STATUSTEXT) , <span class="number">387u32 </span>=&gt; CANFD_FRAME_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CANFD_FRAME) , <span class="number">232u32 </span>=&gt; GPS_INPUT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_INPUT) , <span class="number">129u32 </span>=&gt; SCALED_IMU3_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_IMU3) , <span class="number">35u32 </span>=&gt; RC_CHANNELS_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS_RAW) , <span class="number">45u32 </span>=&gt; MISSION_CLEAR_ALL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_CLEAR_ALL) , <span class="number">287u32 </span>=&gt; GIMBAL_MANAGER_SET_PITCHYAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW) , <span class="number">288u32 </span>=&gt; GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL) , <span class="number">300u32 </span>=&gt; PROTOCOL_VERSION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PROTOCOL_VERSION) , <span class="number">323u32 </span>=&gt; PARAM_EXT_SET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_SET) , <span class="number">51u32 </span>=&gt; MISSION_REQUEST_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST_INT) , <span class="number">126u32 </span>=&gt; SERIAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SERIAL_CONTROL) , <span class="number">140u32 </span>=&gt; ACTUATOR_CONTROL_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET) , <span class="number">335u32 </span>=&gt; ISBD_LINK_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ISBD_LINK_STATUS) , <span class="number">267u32 </span>=&gt; LOGGING_DATA_ACKED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOGGING_DATA_ACKED) , <span class="number">92u32 </span>=&gt; HIL_RC_INPUTS_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_RC_INPUTS_RAW) , <span class="number">65u32 </span>=&gt; RC_CHANNELS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS) , <span class="number">251u32 </span>=&gt; NAMED_VALUE_FLOAT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: NAMED_VALUE_FLOAT) , <span class="number">388u32 </span>=&gt; CAN_FILTER_MODIFY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAN_FILTER_MODIFY) , <span class="number">290u32 </span>=&gt; ESC_INFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_INFO) , <span class="number">40u32 </span>=&gt; MISSION_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST) , <span class="number">114u32 </span>=&gt; HIL_OPTICAL_FLOW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_OPTICAL_FLOW) , <span class="number">235u32 </span>=&gt; HIGH_LATENCY2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIGH_LATENCY2) , <span class="number">26u32 </span>=&gt; SCALED_IMU_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_IMU) , <span class="number">121u32 </span>=&gt; LOG_ERASE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_ERASE) , <span class="number">123u32 </span>=&gt; GPS_INJECT_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_INJECT_DATA) , <span class="number">266u32 </span>=&gt; LOGGING_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOGGING_DATA) , <span class="number">234u32 </span>=&gt; HIGH_LATENCY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIGH_LATENCY) , <span class="number">141u32 </span>=&gt; ALTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ALTITUDE) , <span class="number">133u32 </span>=&gt; TERRAIN_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_REQUEST) , <span class="number">321u32 </span>=&gt; PARAM_EXT_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST) , <span class="number">119u32 </span>=&gt; LOG_REQUEST_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_REQUEST_DATA) , <span class="number">350u32 </span>=&gt; DEBUG_FLOAT_ARRAY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEBUG_FLOAT_ARRAY) , <span class="number">70u32 </span>=&gt; RC_CHANNELS_OVERRIDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS_OVERRIDE) , <span class="number">101u32 </span>=&gt; GLOBAL_VISION_POSITION_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE) , <span class="number">12915u32 </span>=&gt; OPEN_DRONE_ID_MESSAGE_PACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK) , <span class="number">110u32 </span>=&gt; FILE_TRANSFER_PROTOCOL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL) , <span class="number">263u32 </span>=&gt; CAMERA_IMAGE_CAPTURED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED) , <span class="number">334u32 </span>=&gt; CELLULAR_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CELLULAR_STATUS) , <span class="number">132u32 </span>=&gt; DISTANCE_SENSOR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DISTANCE_SENSOR) , <span class="number">104u32 </span>=&gt; VICON_POSITION_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VICON_POSITION_ESTIMATE) , <span class="number">280u32 </span>=&gt; GIMBAL_MANAGER_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION) , <span class="number">74u32 </span>=&gt; VFR_HUD_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VFR_HUD) , <span class="number">5u32 </span>=&gt; CHANGE_OPERATOR_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL) , <span class="number">242u32 </span>=&gt; HOME_POSITION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HOME_POSITION) , <span class="number">386u32 </span>=&gt; CAN_FRAME_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAN_FRAME) , <span class="number">83u32 </span>=&gt; ATTITUDE_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE_TARGET) , <span class="number">111u32 </span>=&gt; TIMESYNC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TIMESYNC) , <span class="number">400u32 </span>=&gt; PLAY_TUNE_V2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PLAY_TUNE_V2) , <span class="number">1u32 </span>=&gt; SYS_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SYS_STATUS) , <span class="number">260u32 </span>=&gt; CAMERA_SETTINGS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_SETTINGS) , <span class="number">264u32 </span>=&gt; FLIGHT_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FLIGHT_INFORMATION) , <span class="number">265u32 </span>=&gt; MOUNT_ORIENTATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MOUNT_ORIENTATION) , <span class="number">62u32 </span>=&gt; NAV_CONTROLLER_OUTPUT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT) , <span class="number">259u32 </span>=&gt; CAMERA_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_INFORMATION) , <span class="number">137u32 </span>=&gt; SCALED_PRESSURE2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_PRESSURE2) , <span class="number">299u32 </span>=&gt; WIFI_CONFIG_AP_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WIFI_CONFIG_AP) , <span class="number">390u32 </span>=&gt; ONBOARD_COMPUTER_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS) , <span class="number">136u32 </span>=&gt; TERRAIN_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_REPORT) , <span class="number">275u32 </span>=&gt; CAMERA_TRACKING_IMAGE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS) , <span class="number">146u32 </span>=&gt; CONTROL_SYSTEM_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CONTROL_SYSTEM_STATE) , <span class="number">120u32 </span>=&gt; LOG_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_DATA) , <span class="number">20u32 </span>=&gt; PARAM_REQUEST_READ_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_REQUEST_READ) , <span class="number">4u32 </span>=&gt; PING_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PING) , <span class="number">116u32 </span>=&gt; SCALED_IMU2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_IMU2) , <span class="number">7u32 </span>=&gt; AUTH_KEY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTH_KEY) , <span class="number">413u32 </span>=&gt; RESPONSE_EVENT_ERROR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RESPONSE_EVENT_ERROR) , <span class="number">162u32 </span>=&gt; FENCE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FENCE_STATUS) , <span class="number">124u32 </span>=&gt; GPS2_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS2_RAW) , <span class="number">22u32 </span>=&gt; PARAM_VALUE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_VALUE) , <span class="number">61u32 </span>=&gt; ATTITUDE_QUATERNION_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE_QUATERNION_COV) , <span class="number">12902u32 </span>=&gt; OPEN_DRONE_ID_AUTHENTICATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION) , <span class="number">225u32 </span>=&gt; EFI_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EFI_STATUS) , <span class="number">270u32 </span>=&gt; VIDEO_STREAM_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VIDEO_STREAM_STATUS) , <span class="kw">_ </span>=&gt; { <span class="prelude-val">Err </span>(ParserError :: UnknownMessage { id }) } , } } <span class="kw">fn </span>message_name (&amp; <span class="self">self</span>) -&gt; &amp; <span class="lifetime">&#39;static </span>str { <span class="kw">match </span><span class="self">self </span>{ <span class="self">Self </span>:: UTM_GLOBAL_POSITION (..) =&gt; <span class="string">&quot;UTM_GLOBAL_POSITION&quot; </span>, <span class="self">Self </span>:: VISION_POSITION_ESTIMATE (..) =&gt; <span class="string">&quot;VISION_POSITION_ESTIMATE&quot; </span>, <span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="string">&quot;SET_ACTUATOR_CONTROL_TARGET&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_VALUE (..) =&gt; <span class="string">&quot;PARAM_EXT_VALUE&quot; </span>, <span class="self">Self </span>:: GPS_STATUS (..) =&gt; <span class="string">&quot;GPS_STATUS&quot; </span>, <span class="self">Self </span>:: DEBUG (..) =&gt; <span class="string">&quot;DEBUG&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_SET_ATTITUDE&quot; </span>, <span class="self">Self </span>:: RESOURCE_REQUEST (..) =&gt; <span class="string">&quot;RESOURCE_REQUEST&quot; </span>, <span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (..) =&gt; <span class="string">&quot;ACTUATOR_OUTPUT_STATUS&quot; </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (..) =&gt; <span class="string">&quot;TRAJECTORY_REPRESENTATION_BEZIER&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_STATUS&quot; </span>, <span class="self">Self </span>:: REQUEST_EVENT (..) =&gt; <span class="string">&quot;REQUEST_EVENT&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_SYSTEM_UPDATE&quot; </span>, <span class="self">Self </span>:: POWER_STATUS (..) =&gt; <span class="string">&quot;POWER_STATUS&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS_SCALED (..) =&gt; <span class="string">&quot;RC_CHANNELS_SCALED&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST_LIST (..) =&gt; <span class="string">&quot;MISSION_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: ATT_POS_MOCAP (..) =&gt; <span class="string">&quot;ATT_POS_MOCAP&quot; </span>, <span class="self">Self </span>:: PARAM_MAP_RC (..) =&gt; <span class="string">&quot;PARAM_MAP_RC&quot; </span>, <span class="self">Self </span>:: LOG_REQUEST_LIST (..) =&gt; <span class="string">&quot;LOG_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: SERVO_OUTPUT_RAW (..) =&gt; <span class="string">&quot;SERVO_OUTPUT_RAW&quot; </span>, <span class="self">Self </span>:: CAMERA_FOV_STATUS (..) =&gt; <span class="string">&quot;CAMERA_FOV_STATUS&quot; </span>, <span class="self">Self </span>:: ODOMETRY (..) =&gt; <span class="string">&quot;ODOMETRY&quot; </span>, <span class="self">Self </span>:: WINCH_STATUS (..) =&gt; <span class="string">&quot;WINCH_STATUS&quot; </span>, <span class="self">Self </span>:: SAFETY_ALLOWED_AREA (..) =&gt; <span class="string">&quot;SAFETY_ALLOWED_AREA&quot; </span>, <span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (..) =&gt; <span class="string">&quot;DATA_TRANSMISSION_HANDSHAKE&quot; </span>, <span class="self">Self </span>:: SET_MODE (..) =&gt; <span class="string">&quot;SET_MODE&quot; </span>, <span class="self">Self </span>:: COMMAND_LONG (..) =&gt; <span class="string">&quot;COMMAND_LONG&quot; </span>, <span class="self">Self </span>:: SMART_BATTERY_INFO (..) =&gt; <span class="string">&quot;SMART_BATTERY_INFO&quot; </span>, <span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="string">&quot;POSITION_TARGET_LOCAL_NED&quot; </span>, <span class="self">Self </span>:: HIL_STATE (..) =&gt; <span class="string">&quot;HIL_STATE&quot; </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="string">&quot;SET_POSITION_TARGET_LOCAL_NED&quot; </span>, <span class="self">Self </span>:: UAVCAN_NODE_INFO (..) =&gt; <span class="string">&quot;UAVCAN_NODE_INFO&quot; </span>, <span class="self">Self </span>:: TERRAIN_DATA (..) =&gt; <span class="string">&quot;TERRAIN_DATA&quot; </span>, <span class="self">Self </span>:: ADSB_VEHICLE (..) =&gt; <span class="string">&quot;ADSB_VEHICLE&quot; </span>, <span class="self">Self </span>:: DEBUG_VECT (..) =&gt; <span class="string">&quot;DEBUG_VECT&quot; </span>, <span class="self">Self </span>:: ENCAPSULATED_DATA (..) =&gt; <span class="string">&quot;ENCAPSULATED_DATA&quot; </span>, <span class="self">Self </span>:: BUTTON_CHANGE (..) =&gt; <span class="string">&quot;BUTTON_CHANGE&quot; </span>, <span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (..) =&gt; <span class="string">&quot;SET_GPS_GLOBAL_ORIGIN&quot; </span>, <span class="self">Self </span>:: MANUAL_CONTROL (..) =&gt; <span class="string">&quot;MANUAL_CONTROL&quot; </span>, <span class="self">Self </span>:: RAW_PRESSURE (..) =&gt; <span class="string">&quot;RAW_PRESSURE&quot; </span>, <span class="self">Self </span>:: MISSION_ITEM (..) =&gt; <span class="string">&quot;MISSION_ITEM&quot; </span>, <span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (..) =&gt; <span class="string">&quot;ORBIT_EXECUTION_STATUS&quot; </span>, <span class="self">Self </span>:: MAG_CAL_REPORT (..) =&gt; <span class="string">&quot;MAG_CAL_REPORT&quot; </span>, <span class="self">Self </span>:: HEARTBEAT (..) =&gt; <span class="string">&quot;HEARTBEAT&quot; </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (..) =&gt; <span class="string">&quot;GIMBAL_DEVICE_ATTITUDE_STATUS&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_OPERATOR_ID&quot; </span>, <span class="self">Self </span>:: LINK_NODE_STATUS (..) =&gt; <span class="string">&quot;LINK_NODE_STATUS&quot; </span>, <span class="self">Self </span>:: MEMORY_VECT (..) =&gt; <span class="string">&quot;MEMORY_VECT&quot; </span>, <span class="self">Self </span>:: EXTENDED_SYS_STATE (..) =&gt; <span class="string">&quot;EXTENDED_SYS_STATE&quot; </span>, <span class="self">Self </span>:: NAMED_VALUE_INT (..) =&gt; <span class="string">&quot;NAMED_VALUE_INT&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_SYSTEM&quot; </span>, <span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (..) =&gt; <span class="string">&quot;AUTOPILOT_STATE_FOR_GIMBAL_DEVICE&quot; </span>, <span class="self">Self </span>:: HIL_SENSOR (..) =&gt; <span class="string">&quot;HIL_SENSOR&quot; </span>, <span class="self">Self </span>:: WHEEL_DISTANCE (..) =&gt; <span class="string">&quot;WHEEL_DISTANCE&quot; </span>, <span class="self">Self </span>:: OPTICAL_FLOW_RAD (..) =&gt; <span class="string">&quot;OPTICAL_FLOW_RAD&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_ACK (..) =&gt; <span class="string">&quot;PARAM_EXT_ACK&quot; </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION (..) =&gt; <span class="string">&quot;ATTITUDE_QUATERNION&quot; </span>, <span class="self">Self </span>:: HYGROMETER_SENSOR (..) =&gt; <span class="string">&quot;HYGROMETER_SENSOR&quot; </span>, <span class="self">Self </span>:: SCALED_PRESSURE (..) =&gt; <span class="string">&quot;SCALED_PRESSURE&quot; </span>, <span class="self">Self </span>:: TUNNEL (..) =&gt; <span class="string">&quot;TUNNEL&quot; </span>, <span class="self">Self </span>:: TERRAIN_CHECK (..) =&gt; <span class="string">&quot;TERRAIN_CHECK&quot; </span>, <span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (..) =&gt; <span class="string">&quot;CAMERA_CAPTURE_STATUS&quot; </span>, <span class="self">Self </span>:: SUPPORTED_TUNES (..) =&gt; <span class="string">&quot;SUPPORTED_TUNES&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (..) =&gt; <span class="string">&quot;PARAM_EXT_REQUEST_READ&quot; </span>, <span class="self">Self </span>:: COMMAND_INT (..) =&gt; <span class="string">&quot;COMMAND_INT&quot; </span>, <span class="self">Self </span>:: UAVCAN_NODE_STATUS (..) =&gt; <span class="string">&quot;UAVCAN_NODE_STATUS&quot; </span>, <span class="self">Self </span>:: AUTOPILOT_VERSION (..) =&gt; <span class="string">&quot;AUTOPILOT_VERSION&quot; </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED (..) =&gt; <span class="string">&quot;LOCAL_POSITION_NED&quot; </span>, <span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (..) =&gt; <span class="string">&quot;MISSION_WRITE_PARTIAL_LIST&quot; </span>, <span class="self">Self </span>:: LANDING_TARGET (..) =&gt; <span class="string">&quot;LANDING_TARGET&quot; </span>, <span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (..) =&gt; <span class="string">&quot;GPS_GLOBAL_ORIGIN&quot; </span>, <span class="self">Self </span>:: SET_ATTITUDE_TARGET (..) =&gt; <span class="string">&quot;SET_ATTITUDE_TARGET&quot; </span>, <span class="self">Self </span>:: ESC_STATUS (..) =&gt; <span class="string">&quot;ESC_STATUS&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_ARM_STATUS&quot; </span>, <span class="self">Self </span>:: HIL_STATE_QUATERNION (..) =&gt; <span class="string">&quot;HIL_STATE_QUATERNION&quot; </span>, <span class="self">Self </span>:: GPS2_RTK (..) =&gt; <span class="string">&quot;GPS2_RTK&quot; </span>, <span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="string">&quot;POSITION_TARGET_GLOBAL_INT&quot; </span>, <span class="self">Self </span>:: PARAM_SET (..) =&gt; <span class="string">&quot;PARAM_SET&quot; </span>, <span class="self">Self </span>:: SETUP_SIGNING (..) =&gt; <span class="string">&quot;SETUP_SIGNING&quot; </span>, <span class="self">Self </span>:: MISSION_CURRENT (..) =&gt; <span class="string">&quot;MISSION_CURRENT&quot; </span>, <span class="self">Self </span>:: MANUAL_SETPOINT (..) =&gt; <span class="string">&quot;MANUAL_SETPOINT&quot; </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (..) =&gt; <span class="string">&quot;GLOBAL_POSITION_INT_COV&quot; </span>, <span class="self">Self </span>:: V2_EXTENSION (..) =&gt; <span class="string">&quot;V2_EXTENSION&quot; </span>, <span class="self">Self </span>:: COLLISION (..) =&gt; <span class="string">&quot;COLLISION&quot; </span>, <span class="self">Self </span>:: FOLLOW_TARGET (..) =&gt; <span class="string">&quot;FOLLOW_TARGET&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_LOCATION&quot; </span>, <span class="self">Self </span>:: OPTICAL_FLOW (..) =&gt; <span class="string">&quot;OPTICAL_FLOW&quot; </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (..) =&gt; <span class="string">&quot;CHANGE_OPERATOR_CONTROL_ACK&quot; </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (..) =&gt; <span class="string">&quot;UAVIONIX_ADSB_OUT_DYNAMIC&quot; </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_COV (..) =&gt; <span class="string">&quot;LOCAL_POSITION_NED_COV&quot; </span>, <span class="self">Self </span>:: COMPONENT_METADATA (..) =&gt; <span class="string">&quot;COMPONENT_METADATA&quot; </span>, <span class="self">Self </span>:: LOGGING_ACK (..) =&gt; <span class="string">&quot;LOGGING_ACK&quot; </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (..) =&gt; <span class="string">&quot;LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_BASIC_ID&quot; </span>, <span class="self">Self </span>:: DATA_STREAM (..) =&gt; <span class="string">&quot;DATA_STREAM&quot; </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (..) =&gt; <span class="string">&quot;GIMBAL_DEVICE_SET_ATTITUDE&quot; </span>, <span class="self">Self </span>:: STORAGE_INFORMATION (..) =&gt; <span class="string">&quot;STORAGE_INFORMATION&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (..) =&gt; <span class="string">&quot;MISSION_REQUEST_PARTIAL_LIST&quot; </span>, <span class="self">Self </span>:: CAMERA_TRIGGER (..) =&gt; <span class="string">&quot;CAMERA_TRIGGER&quot; </span>, <span class="self">Self </span>:: RAW_RPM (..) =&gt; <span class="string">&quot;RAW_RPM&quot; </span>, <span class="self">Self </span>:: PLAY_TUNE (..) =&gt; <span class="string">&quot;PLAY_TUNE&quot; </span>, <span class="self">Self </span>:: HIL_CONTROLS (..) =&gt; <span class="string">&quot;HIL_CONTROLS&quot; </span>, <span class="self">Self </span>:: RADIO_STATUS (..) =&gt; <span class="string">&quot;RADIO_STATUS&quot; </span>, <span class="self">Self </span>:: LOG_ENTRY (..) =&gt; <span class="string">&quot;LOG_ENTRY&quot; </span>, <span class="self">Self </span>:: REQUEST_DATA_STREAM (..) =&gt; <span class="string">&quot;REQUEST_DATA_STREAM&quot; </span>, <span class="self">Self </span>:: VISION_SPEED_ESTIMATE (..) =&gt; <span class="string">&quot;VISION_SPEED_ESTIMATE&quot; </span>, <span class="self">Self </span>:: ATTITUDE (..) =&gt; <span class="string">&quot;ATTITUDE&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_SELF_ID&quot; </span>, <span class="self">Self </span>:: COMMAND_ACK (..) =&gt; <span class="string">&quot;COMMAND_ACK&quot; </span>, <span class="self">Self </span>:: VIBRATION (..) =&gt; <span class="string">&quot;VIBRATION&quot; </span>, <span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (..) =&gt; <span class="string">&quot;VIDEO_STREAM_INFORMATION&quot; </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (..) =&gt; <span class="string">&quot;TRAJECTORY_REPRESENTATION_WAYPOINTS&quot; </span>, <span class="self">Self </span>:: COMPONENT_INFORMATION (..) =&gt; <span class="string">&quot;COMPONENT_INFORMATION&quot; </span>, <span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (..) =&gt; <span class="string">&quot;TIME_ESTIMATE_TO_TARGET&quot; </span>, <span class="self">Self </span>:: MISSION_ITEM_INT (..) =&gt; <span class="string">&quot;MISSION_ITEM_INT&quot; </span>, <span class="self">Self </span>:: EVENT (..) =&gt; <span class="string">&quot;EVENT&quot; </span>, <span class="self">Self </span>:: LOG_REQUEST_END (..) =&gt; <span class="string">&quot;LOG_REQUEST_END&quot; </span>, <span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (..) =&gt; <span class="string">&quot;HIL_ACTUATOR_CONTROLS&quot; </span>, <span class="self">Self </span>:: PARAM_REQUEST_LIST (..) =&gt; <span class="string">&quot;PARAM_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: RAW_IMU (..) =&gt; <span class="string">&quot;RAW_IMU&quot; </span>, <span class="self">Self </span>:: MISSION_COUNT (..) =&gt; <span class="string">&quot;MISSION_COUNT&quot; </span>, <span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (..) =&gt; <span class="string">&quot;SAFETY_SET_ALLOWED_AREA&quot; </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (..) =&gt; <span class="string">&quot;UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT&quot; </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (..) =&gt; <span class="string">&quot;GIMBAL_DEVICE_INFORMATION&quot; </span>, <span class="self">Self </span>:: CELLULAR_CONFIG (..) =&gt; <span class="string">&quot;CELLULAR_CONFIG&quot; </span>, <span class="self">Self </span>:: AIS_VESSEL (..) =&gt; <span class="string">&quot;AIS_VESSEL&quot; </span>, <span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (..) =&gt; <span class="string">&quot;CAMERA_TRACKING_GEO_STATUS&quot; </span>, <span class="self">Self </span>:: HIGHRES_IMU (..) =&gt; <span class="string">&quot;HIGHRES_IMU&quot; </span>, <span class="self">Self </span>:: GPS_RAW_INT (..) =&gt; <span class="string">&quot;GPS_RAW_INT&quot; </span>, <span class="self">Self </span>:: MISSION_ITEM_REACHED (..) =&gt; <span class="string">&quot;MISSION_ITEM_REACHED&quot; </span>, <span class="self">Self </span>:: HIL_GPS (..) =&gt; <span class="string">&quot;HIL_GPS&quot; </span>, <span class="self">Self </span>:: GPS_RTK (..) =&gt; <span class="string">&quot;GPS_RTK&quot; </span>, <span class="self">Self </span>:: MISSION_ACK (..) =&gt; <span class="string">&quot;MISSION_ACK&quot; </span>, <span class="self">Self </span>:: SYSTEM_TIME (..) =&gt; <span class="string">&quot;SYSTEM_TIME&quot; </span>, <span class="self">Self </span>:: ESTIMATOR_STATUS (..) =&gt; <span class="string">&quot;ESTIMATOR_STATUS&quot; </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="string">&quot;SET_POSITION_TARGET_GLOBAL_INT&quot; </span>, <span class="self">Self </span>:: SET_HOME_POSITION (..) =&gt; <span class="string">&quot;SET_HOME_POSITION&quot; </span>, <span class="self">Self </span>:: GENERATOR_STATUS (..) =&gt; <span class="string">&quot;GENERATOR_STATUS&quot; </span>, <span class="self">Self </span>:: GPS_RTCM_DATA (..) =&gt; <span class="string">&quot;GPS_RTCM_DATA&quot; </span>, <span class="self">Self </span>:: OBSTACLE_DISTANCE (..) =&gt; <span class="string">&quot;OBSTACLE_DISTANCE&quot; </span>, <span class="self">Self </span>:: COMMAND_CANCEL (..) =&gt; <span class="string">&quot;COMMAND_CANCEL&quot; </span>, <span class="self">Self </span>:: MESSAGE_INTERVAL (..) =&gt; <span class="string">&quot;MESSAGE_INTERVAL&quot; </span>, <span class="self">Self </span>:: MISSION_SET_CURRENT (..) =&gt; <span class="string">&quot;MISSION_SET_CURRENT&quot; </span>, <span class="self">Self </span>:: SCALED_PRESSURE3 (..) =&gt; <span class="string">&quot;SCALED_PRESSURE3&quot; </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (..) =&gt; <span class="string">&quot;UAVIONIX_ADSB_OUT_CFG&quot; </span>, <span class="self">Self </span>:: SIM_STATE (..) =&gt; <span class="string">&quot;SIM_STATE&quot; </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT (..) =&gt; <span class="string">&quot;GLOBAL_POSITION_INT&quot; </span>, <span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (..) =&gt; <span class="string">&quot;CURRENT_EVENT_SEQUENCE&quot; </span>, <span class="self">Self </span>:: BATTERY_STATUS (..) =&gt; <span class="string">&quot;BATTERY_STATUS&quot; </span>, <span class="self">Self </span>:: WIND_COV (..) =&gt; <span class="string">&quot;WIND_COV&quot; </span>, <span class="self">Self </span>:: STATUSTEXT (..) =&gt; <span class="string">&quot;STATUSTEXT&quot; </span>, <span class="self">Self </span>:: CANFD_FRAME (..) =&gt; <span class="string">&quot;CANFD_FRAME&quot; </span>, <span class="self">Self </span>:: GPS_INPUT (..) =&gt; <span class="string">&quot;GPS_INPUT&quot; </span>, <span class="self">Self </span>:: SCALED_IMU3 (..) =&gt; <span class="string">&quot;SCALED_IMU3&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS_RAW (..) =&gt; <span class="string">&quot;RC_CHANNELS_RAW&quot; </span>, <span class="self">Self </span>:: MISSION_CLEAR_ALL (..) =&gt; <span class="string">&quot;MISSION_CLEAR_ALL&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_SET_PITCHYAW&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_SET_MANUAL_CONTROL&quot; </span>, <span class="self">Self </span>:: PROTOCOL_VERSION (..) =&gt; <span class="string">&quot;PROTOCOL_VERSION&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_SET (..) =&gt; <span class="string">&quot;PARAM_EXT_SET&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST_INT (..) =&gt; <span class="string">&quot;MISSION_REQUEST_INT&quot; </span>, <span class="self">Self </span>:: SERIAL_CONTROL (..) =&gt; <span class="string">&quot;SERIAL_CONTROL&quot; </span>, <span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="string">&quot;ACTUATOR_CONTROL_TARGET&quot; </span>, <span class="self">Self </span>:: ISBD_LINK_STATUS (..) =&gt; <span class="string">&quot;ISBD_LINK_STATUS&quot; </span>, <span class="self">Self </span>:: LOGGING_DATA_ACKED (..) =&gt; <span class="string">&quot;LOGGING_DATA_ACKED&quot; </span>, <span class="self">Self </span>:: HIL_RC_INPUTS_RAW (..) =&gt; <span class="string">&quot;HIL_RC_INPUTS_RAW&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS (..) =&gt; <span class="string">&quot;RC_CHANNELS&quot; </span>, <span class="self">Self </span>:: NAMED_VALUE_FLOAT (..) =&gt; <span class="string">&quot;NAMED_VALUE_FLOAT&quot; </span>, <span class="self">Self </span>:: CAN_FILTER_MODIFY (..) =&gt; <span class="string">&quot;CAN_FILTER_MODIFY&quot; </span>, <span class="self">Self </span>:: ESC_INFO (..) =&gt; <span class="string">&quot;ESC_INFO&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST (..) =&gt; <span class="string">&quot;MISSION_REQUEST&quot; </span>, <span class="self">Self </span>:: HIL_OPTICAL_FLOW (..) =&gt; <span class="string">&quot;HIL_OPTICAL_FLOW&quot; </span>, <span class="self">Self </span>:: HIGH_LATENCY2 (..) =&gt; <span class="string">&quot;HIGH_LATENCY2&quot; </span>, <span class="self">Self </span>:: SCALED_IMU (..) =&gt; <span class="string">&quot;SCALED_IMU&quot; </span>, <span class="self">Self </span>:: LOG_ERASE (..) =&gt; <span class="string">&quot;LOG_ERASE&quot; </span>, <span class="self">Self </span>:: GPS_INJECT_DATA (..) =&gt; <span class="string">&quot;GPS_INJECT_DATA&quot; </span>, <span class="self">Self </span>:: LOGGING_DATA (..) =&gt; <span class="string">&quot;LOGGING_DATA&quot; </span>, <span class="self">Self </span>:: HIGH_LATENCY (..) =&gt; <span class="string">&quot;HIGH_LATENCY&quot; </span>, <span class="self">Self </span>:: ALTITUDE (..) =&gt; <span class="string">&quot;ALTITUDE&quot; </span>, <span class="self">Self </span>:: TERRAIN_REQUEST (..) =&gt; <span class="string">&quot;TERRAIN_REQUEST&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (..) =&gt; <span class="string">&quot;PARAM_EXT_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: LOG_REQUEST_DATA (..) =&gt; <span class="string">&quot;LOG_REQUEST_DATA&quot; </span>, <span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (..) =&gt; <span class="string">&quot;DEBUG_FLOAT_ARRAY&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (..) =&gt; <span class="string">&quot;RC_CHANNELS_OVERRIDE&quot; </span>, <span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (..) =&gt; <span class="string">&quot;GLOBAL_VISION_POSITION_ESTIMATE&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_MESSAGE_PACK&quot; </span>, <span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (..) =&gt; <span class="string">&quot;FILE_TRANSFER_PROTOCOL&quot; </span>, <span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (..) =&gt; <span class="string">&quot;CAMERA_IMAGE_CAPTURED&quot; </span>, <span class="self">Self </span>:: CELLULAR_STATUS (..) =&gt; <span class="string">&quot;CELLULAR_STATUS&quot; </span>, <span class="self">Self </span>:: DISTANCE_SENSOR (..) =&gt; <span class="string">&quot;DISTANCE_SENSOR&quot; </span>, <span class="self">Self </span>:: VICON_POSITION_ESTIMATE (..) =&gt; <span class="string">&quot;VICON_POSITION_ESTIMATE&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_INFORMATION&quot; </span>, <span class="self">Self </span>:: VFR_HUD (..) =&gt; <span class="string">&quot;VFR_HUD&quot; </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (..) =&gt; <span class="string">&quot;CHANGE_OPERATOR_CONTROL&quot; </span>, <span class="self">Self </span>:: HOME_POSITION (..) =&gt; <span class="string">&quot;HOME_POSITION&quot; </span>, <span class="self">Self </span>:: CAN_FRAME (..) =&gt; <span class="string">&quot;CAN_FRAME&quot; </span>, <span class="self">Self </span>:: ATTITUDE_TARGET (..) =&gt; <span class="string">&quot;ATTITUDE_TARGET&quot; </span>, <span class="self">Self </span>:: TIMESYNC (..) =&gt; <span class="string">&quot;TIMESYNC&quot; </span>, <span class="self">Self </span>:: PLAY_TUNE_V2 (..) =&gt; <span class="string">&quot;PLAY_TUNE_V2&quot; </span>, <span class="self">Self </span>:: SYS_STATUS (..) =&gt; <span class="string">&quot;SYS_STATUS&quot; </span>, <span class="self">Self </span>:: CAMERA_SETTINGS (..) =&gt; <span class="string">&quot;CAMERA_SETTINGS&quot; </span>, <span class="self">Self </span>:: FLIGHT_INFORMATION (..) =&gt; <span class="string">&quot;FLIGHT_INFORMATION&quot; </span>, <span class="self">Self </span>:: MOUNT_ORIENTATION (..) =&gt; <span class="string">&quot;MOUNT_ORIENTATION&quot; </span>, <span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (..) =&gt; <span class="string">&quot;NAV_CONTROLLER_OUTPUT&quot; </span>, <span class="self">Self </span>:: CAMERA_INFORMATION (..) =&gt; <span class="string">&quot;CAMERA_INFORMATION&quot; </span>, <span class="self">Self </span>:: SCALED_PRESSURE2 (..) =&gt; <span class="string">&quot;SCALED_PRESSURE2&quot; </span>, <span class="self">Self </span>:: WIFI_CONFIG_AP (..) =&gt; <span class="string">&quot;WIFI_CONFIG_AP&quot; </span>, <span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (..) =&gt; <span class="string">&quot;ONBOARD_COMPUTER_STATUS&quot; </span>, <span class="self">Self </span>:: TERRAIN_REPORT (..) =&gt; <span class="string">&quot;TERRAIN_REPORT&quot; </span>, <span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (..) =&gt; <span class="string">&quot;CAMERA_TRACKING_IMAGE_STATUS&quot; </span>, <span class="self">Self </span>:: CONTROL_SYSTEM_STATE (..) =&gt; <span class="string">&quot;CONTROL_SYSTEM_STATE&quot; </span>, <span class="self">Self </span>:: LOG_DATA (..) =&gt; <span class="string">&quot;LOG_DATA&quot; </span>, <span class="self">Self </span>:: PARAM_REQUEST_READ (..) =&gt; <span class="string">&quot;PARAM_REQUEST_READ&quot; </span>, <span class="self">Self </span>:: PING (..) =&gt; <span class="string">&quot;PING&quot; </span>, <span class="self">Self </span>:: SCALED_IMU2 (..) =&gt; <span class="string">&quot;SCALED_IMU2&quot; </span>, <span class="self">Self </span>:: AUTH_KEY (..) =&gt; <span class="string">&quot;AUTH_KEY&quot; </span>, <span class="self">Self </span>:: RESPONSE_EVENT_ERROR (..) =&gt; <span class="string">&quot;RESPONSE_EVENT_ERROR&quot; </span>, <span class="self">Self </span>:: FENCE_STATUS (..) =&gt; <span class="string">&quot;FENCE_STATUS&quot; </span>, <span class="self">Self </span>:: GPS2_RAW (..) =&gt; <span class="string">&quot;GPS2_RAW&quot; </span>, <span class="self">Self </span>:: PARAM_VALUE (..) =&gt; <span class="string">&quot;PARAM_VALUE&quot; </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (..) =&gt; <span class="string">&quot;ATTITUDE_QUATERNION_COV&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_AUTHENTICATION&quot; </span>, <span class="self">Self </span>:: EFI_STATUS (..) =&gt; <span class="string">&quot;EFI_STATUS&quot; </span>, <span class="self">Self </span>:: VIDEO_STREAM_STATUS (..) =&gt; <span class="string">&quot;VIDEO_STREAM_STATUS&quot; </span>, } } <span class="kw">fn </span>message_id (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">match </span><span class="self">self </span>{ <span class="self">Self </span>:: UTM_GLOBAL_POSITION (..) =&gt; <span class="number">340u32 </span>, <span class="self">Self </span>:: VISION_POSITION_ESTIMATE (..) =&gt; <span class="number">102u32 </span>, <span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="number">139u32 </span>, <span class="self">Self </span>:: PARAM_EXT_VALUE (..) =&gt; <span class="number">322u32 </span>, <span class="self">Self </span>:: GPS_STATUS (..) =&gt; <span class="number">25u32 </span>, <span class="self">Self </span>:: DEBUG (..) =&gt; <span class="number">254u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (..) =&gt; <span class="number">282u32 </span>, <span class="self">Self </span>:: RESOURCE_REQUEST (..) =&gt; <span class="number">142u32 </span>, <span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (..) =&gt; <span class="number">375u32 </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (..) =&gt; <span class="number">333u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (..) =&gt; <span class="number">281u32 </span>, <span class="self">Self </span>:: REQUEST_EVENT (..) =&gt; <span class="number">412u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (..) =&gt; <span class="number">12919u32 </span>, <span class="self">Self </span>:: POWER_STATUS (..) =&gt; <span class="number">125u32 </span>, <span class="self">Self </span>:: RC_CHANNELS_SCALED (..) =&gt; <span class="number">34u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST_LIST (..) =&gt; <span class="number">43u32 </span>, <span class="self">Self </span>:: ATT_POS_MOCAP (..) =&gt; <span class="number">138u32 </span>, <span class="self">Self </span>:: PARAM_MAP_RC (..) =&gt; <span class="number">50u32 </span>, <span class="self">Self </span>:: LOG_REQUEST_LIST (..) =&gt; <span class="number">117u32 </span>, <span class="self">Self </span>:: SERVO_OUTPUT_RAW (..) =&gt; <span class="number">36u32 </span>, <span class="self">Self </span>:: CAMERA_FOV_STATUS (..) =&gt; <span class="number">271u32 </span>, <span class="self">Self </span>:: ODOMETRY (..) =&gt; <span class="number">331u32 </span>, <span class="self">Self </span>:: WINCH_STATUS (..) =&gt; <span class="number">9005u32 </span>, <span class="self">Self </span>:: SAFETY_ALLOWED_AREA (..) =&gt; <span class="number">55u32 </span>, <span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (..) =&gt; <span class="number">130u32 </span>, <span class="self">Self </span>:: SET_MODE (..) =&gt; <span class="number">11u32 </span>, <span class="self">Self </span>:: COMMAND_LONG (..) =&gt; <span class="number">76u32 </span>, <span class="self">Self </span>:: SMART_BATTERY_INFO (..) =&gt; <span class="number">370u32 </span>, <span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="number">85u32 </span>, <span class="self">Self </span>:: HIL_STATE (..) =&gt; <span class="number">90u32 </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="number">84u32 </span>, <span class="self">Self </span>:: UAVCAN_NODE_INFO (..) =&gt; <span class="number">311u32 </span>, <span class="self">Self </span>:: TERRAIN_DATA (..) =&gt; <span class="number">134u32 </span>, <span class="self">Self </span>:: ADSB_VEHICLE (..) =&gt; <span class="number">246u32 </span>, <span class="self">Self </span>:: DEBUG_VECT (..) =&gt; <span class="number">250u32 </span>, <span class="self">Self </span>:: ENCAPSULATED_DATA (..) =&gt; <span class="number">131u32 </span>, <span class="self">Self </span>:: BUTTON_CHANGE (..) =&gt; <span class="number">257u32 </span>, <span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (..) =&gt; <span class="number">48u32 </span>, <span class="self">Self </span>:: MANUAL_CONTROL (..) =&gt; <span class="number">69u32 </span>, <span class="self">Self </span>:: RAW_PRESSURE (..) =&gt; <span class="number">28u32 </span>, <span class="self">Self </span>:: MISSION_ITEM (..) =&gt; <span class="number">39u32 </span>, <span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (..) =&gt; <span class="number">360u32 </span>, <span class="self">Self </span>:: MAG_CAL_REPORT (..) =&gt; <span class="number">192u32 </span>, <span class="self">Self </span>:: HEARTBEAT (..) =&gt; <span class="number">0u32 </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (..) =&gt; <span class="number">285u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (..) =&gt; <span class="number">12905u32 </span>, <span class="self">Self </span>:: LINK_NODE_STATUS (..) =&gt; <span class="number">8u32 </span>, <span class="self">Self </span>:: MEMORY_VECT (..) =&gt; <span class="number">249u32 </span>, <span class="self">Self </span>:: EXTENDED_SYS_STATE (..) =&gt; <span class="number">245u32 </span>, <span class="self">Self </span>:: NAMED_VALUE_INT (..) =&gt; <span class="number">252u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (..) =&gt; <span class="number">12904u32 </span>, <span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (..) =&gt; <span class="number">286u32 </span>, <span class="self">Self </span>:: HIL_SENSOR (..) =&gt; <span class="number">107u32 </span>, <span class="self">Self </span>:: WHEEL_DISTANCE (..) =&gt; <span class="number">9000u32 </span>, <span class="self">Self </span>:: OPTICAL_FLOW_RAD (..) =&gt; <span class="number">106u32 </span>, <span class="self">Self </span>:: PARAM_EXT_ACK (..) =&gt; <span class="number">324u32 </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION (..) =&gt; <span class="number">31u32 </span>, <span class="self">Self </span>:: HYGROMETER_SENSOR (..) =&gt; <span class="number">12920u32 </span>, <span class="self">Self </span>:: SCALED_PRESSURE (..) =&gt; <span class="number">29u32 </span>, <span class="self">Self </span>:: TUNNEL (..) =&gt; <span class="number">385u32 </span>, <span class="self">Self </span>:: TERRAIN_CHECK (..) =&gt; <span class="number">135u32 </span>, <span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (..) =&gt; <span class="number">262u32 </span>, <span class="self">Self </span>:: SUPPORTED_TUNES (..) =&gt; <span class="number">401u32 </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (..) =&gt; <span class="number">320u32 </span>, <span class="self">Self </span>:: COMMAND_INT (..) =&gt; <span class="number">75u32 </span>, <span class="self">Self </span>:: UAVCAN_NODE_STATUS (..) =&gt; <span class="number">310u32 </span>, <span class="self">Self </span>:: AUTOPILOT_VERSION (..) =&gt; <span class="number">148u32 </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED (..) =&gt; <span class="number">32u32 </span>, <span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (..) =&gt; <span class="number">38u32 </span>, <span class="self">Self </span>:: LANDING_TARGET (..) =&gt; <span class="number">149u32 </span>, <span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (..) =&gt; <span class="number">49u32 </span>, <span class="self">Self </span>:: SET_ATTITUDE_TARGET (..) =&gt; <span class="number">82u32 </span>, <span class="self">Self </span>:: ESC_STATUS (..) =&gt; <span class="number">291u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (..) =&gt; <span class="number">12918u32 </span>, <span class="self">Self </span>:: HIL_STATE_QUATERNION (..) =&gt; <span class="number">115u32 </span>, <span class="self">Self </span>:: GPS2_RTK (..) =&gt; <span class="number">128u32 </span>, <span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="number">87u32 </span>, <span class="self">Self </span>:: PARAM_SET (..) =&gt; <span class="number">23u32 </span>, <span class="self">Self </span>:: SETUP_SIGNING (..) =&gt; <span class="number">256u32 </span>, <span class="self">Self </span>:: MISSION_CURRENT (..) =&gt; <span class="number">42u32 </span>, <span class="self">Self </span>:: MANUAL_SETPOINT (..) =&gt; <span class="number">81u32 </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (..) =&gt; <span class="number">63u32 </span>, <span class="self">Self </span>:: V2_EXTENSION (..) =&gt; <span class="number">248u32 </span>, <span class="self">Self </span>:: COLLISION (..) =&gt; <span class="number">247u32 </span>, <span class="self">Self </span>:: FOLLOW_TARGET (..) =&gt; <span class="number">144u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (..) =&gt; <span class="number">12901u32 </span>, <span class="self">Self </span>:: OPTICAL_FLOW (..) =&gt; <span class="number">100u32 </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (..) =&gt; <span class="number">6u32 </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (..) =&gt; <span class="number">10002u32 </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_COV (..) =&gt; <span class="number">64u32 </span>, <span class="self">Self </span>:: COMPONENT_METADATA (..) =&gt; <span class="number">397u32 </span>, <span class="self">Self </span>:: LOGGING_ACK (..) =&gt; <span class="number">268u32 </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (..) =&gt; <span class="number">89u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (..) =&gt; <span class="number">12900u32 </span>, <span class="self">Self </span>:: DATA_STREAM (..) =&gt; <span class="number">67u32 </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (..) =&gt; <span class="number">284u32 </span>, <span class="self">Self </span>:: STORAGE_INFORMATION (..) =&gt; <span class="number">261u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (..) =&gt; <span class="number">37u32 </span>, <span class="self">Self </span>:: CAMERA_TRIGGER (..) =&gt; <span class="number">112u32 </span>, <span class="self">Self </span>:: RAW_RPM (..) =&gt; <span class="number">339u32 </span>, <span class="self">Self </span>:: PLAY_TUNE (..) =&gt; <span class="number">258u32 </span>, <span class="self">Self </span>:: HIL_CONTROLS (..) =&gt; <span class="number">91u32 </span>, <span class="self">Self </span>:: RADIO_STATUS (..) =&gt; <span class="number">109u32 </span>, <span class="self">Self </span>:: LOG_ENTRY (..) =&gt; <span class="number">118u32 </span>, <span class="self">Self </span>:: REQUEST_DATA_STREAM (..) =&gt; <span class="number">66u32 </span>, <span class="self">Self </span>:: VISION_SPEED_ESTIMATE (..) =&gt; <span class="number">103u32 </span>, <span class="self">Self </span>:: ATTITUDE (..) =&gt; <span class="number">30u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (..) =&gt; <span class="number">12903u32 </span>, <span class="self">Self </span>:: COMMAND_ACK (..) =&gt; <span class="number">77u32 </span>, <span class="self">Self </span>:: VIBRATION (..) =&gt; <span class="number">241u32 </span>, <span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (..) =&gt; <span class="number">269u32 </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (..) =&gt; <span class="number">332u32 </span>, <span class="self">Self </span>:: COMPONENT_INFORMATION (..) =&gt; <span class="number">395u32 </span>, <span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (..) =&gt; <span class="number">380u32 </span>, <span class="self">Self </span>:: MISSION_ITEM_INT (..) =&gt; <span class="number">73u32 </span>, <span class="self">Self </span>:: EVENT (..) =&gt; <span class="number">410u32 </span>, <span class="self">Self </span>:: LOG_REQUEST_END (..) =&gt; <span class="number">122u32 </span>, <span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (..) =&gt; <span class="number">93u32 </span>, <span class="self">Self </span>:: PARAM_REQUEST_LIST (..) =&gt; <span class="number">21u32 </span>, <span class="self">Self </span>:: RAW_IMU (..) =&gt; <span class="number">27u32 </span>, <span class="self">Self </span>:: MISSION_COUNT (..) =&gt; <span class="number">44u32 </span>, <span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (..) =&gt; <span class="number">54u32 </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (..) =&gt; <span class="number">10003u32 </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (..) =&gt; <span class="number">283u32 </span>, <span class="self">Self </span>:: CELLULAR_CONFIG (..) =&gt; <span class="number">336u32 </span>, <span class="self">Self </span>:: AIS_VESSEL (..) =&gt; <span class="number">301u32 </span>, <span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (..) =&gt; <span class="number">276u32 </span>, <span class="self">Self </span>:: HIGHRES_IMU (..) =&gt; <span class="number">105u32 </span>, <span class="self">Self </span>:: GPS_RAW_INT (..) =&gt; <span class="number">24u32 </span>, <span class="self">Self </span>:: MISSION_ITEM_REACHED (..) =&gt; <span class="number">46u32 </span>, <span class="self">Self </span>:: HIL_GPS (..) =&gt; <span class="number">113u32 </span>, <span class="self">Self </span>:: GPS_RTK (..) =&gt; <span class="number">127u32 </span>, <span class="self">Self </span>:: MISSION_ACK (..) =&gt; <span class="number">47u32 </span>, <span class="self">Self </span>:: SYSTEM_TIME (..) =&gt; <span class="number">2u32 </span>, <span class="self">Self </span>:: ESTIMATOR_STATUS (..) =&gt; <span class="number">230u32 </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="number">86u32 </span>, <span class="self">Self </span>:: SET_HOME_POSITION (..) =&gt; <span class="number">243u32 </span>, <span class="self">Self </span>:: GENERATOR_STATUS (..) =&gt; <span class="number">373u32 </span>, <span class="self">Self </span>:: GPS_RTCM_DATA (..) =&gt; <span class="number">233u32 </span>, <span class="self">Self </span>:: OBSTACLE_DISTANCE (..) =&gt; <span class="number">330u32 </span>, <span class="self">Self </span>:: COMMAND_CANCEL (..) =&gt; <span class="number">80u32 </span>, <span class="self">Self </span>:: MESSAGE_INTERVAL (..) =&gt; <span class="number">244u32 </span>, <span class="self">Self </span>:: MISSION_SET_CURRENT (..) =&gt; <span class="number">41u32 </span>, <span class="self">Self </span>:: SCALED_PRESSURE3 (..) =&gt; <span class="number">143u32 </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (..) =&gt; <span class="number">10001u32 </span>, <span class="self">Self </span>:: SIM_STATE (..) =&gt; <span class="number">108u32 </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT (..) =&gt; <span class="number">33u32 </span>, <span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (..) =&gt; <span class="number">411u32 </span>, <span class="self">Self </span>:: BATTERY_STATUS (..) =&gt; <span class="number">147u32 </span>, <span class="self">Self </span>:: WIND_COV (..) =&gt; <span class="number">231u32 </span>, <span class="self">Self </span>:: STATUSTEXT (..) =&gt; <span class="number">253u32 </span>, <span class="self">Self </span>:: CANFD_FRAME (..) =&gt; <span class="number">387u32 </span>, <span class="self">Self </span>:: GPS_INPUT (..) =&gt; <span class="number">232u32 </span>, <span class="self">Self </span>:: SCALED_IMU3 (..) =&gt; <span class="number">129u32 </span>, <span class="self">Self </span>:: RC_CHANNELS_RAW (..) =&gt; <span class="number">35u32 </span>, <span class="self">Self </span>:: MISSION_CLEAR_ALL (..) =&gt; <span class="number">45u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (..) =&gt; <span class="number">287u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (..) =&gt; <span class="number">288u32 </span>, <span class="self">Self </span>:: PROTOCOL_VERSION (..) =&gt; <span class="number">300u32 </span>, <span class="self">Self </span>:: PARAM_EXT_SET (..) =&gt; <span class="number">323u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST_INT (..) =&gt; <span class="number">51u32 </span>, <span class="self">Self </span>:: SERIAL_CONTROL (..) =&gt; <span class="number">126u32 </span>, <span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="number">140u32 </span>, <span class="self">Self </span>:: ISBD_LINK_STATUS (..) =&gt; <span class="number">335u32 </span>, <span class="self">Self </span>:: LOGGING_DATA_ACKED (..) =&gt; <span class="number">267u32 </span>, <span class="self">Self </span>:: HIL_RC_INPUTS_RAW (..) =&gt; <span class="number">92u32 </span>, <span class="self">Self </span>:: RC_CHANNELS (..) =&gt; <span class="number">65u32 </span>, <span class="self">Self </span>:: NAMED_VALUE_FLOAT (..) =&gt; <span class="number">251u32 </span>, <span class="self">Self </span>:: CAN_FILTER_MODIFY (..) =&gt; <span class="number">388u32 </span>, <span class="self">Self </span>:: ESC_INFO (..) =&gt; <span class="number">290u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST (..) =&gt; <span class="number">40u32 </span>, <span class="self">Self </span>:: HIL_OPTICAL_FLOW (..) =&gt; <span class="number">114u32 </span>, <span class="self">Self </span>:: HIGH_LATENCY2 (..) =&gt; <span class="number">235u32 </span>, <span class="self">Self </span>:: SCALED_IMU (..) =&gt; <span class="number">26u32 </span>, <span class="self">Self </span>:: LOG_ERASE (..) =&gt; <span class="number">121u32 </span>, <span class="self">Self </span>:: GPS_INJECT_DATA (..) =&gt; <span class="number">123u32 </span>, <span class="self">Self </span>:: LOGGING_DATA (..) =&gt; <span class="number">266u32 </span>, <span class="self">Self </span>:: HIGH_LATENCY (..) =&gt; <span class="number">234u32 </span>, <span class="self">Self </span>:: ALTITUDE (..) =&gt; <span class="number">141u32 </span>, <span class="self">Self </span>:: TERRAIN_REQUEST (..) =&gt; <span class="number">133u32 </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (..) =&gt; <span class="number">321u32 </span>, <span class="self">Self </span>:: LOG_REQUEST_DATA (..) =&gt; <span class="number">119u32 </span>, <span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (..) =&gt; <span class="number">350u32 </span>, <span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (..) =&gt; <span class="number">70u32 </span>, <span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (..) =&gt; <span class="number">101u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (..) =&gt; <span class="number">12915u32 </span>, <span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (..) =&gt; <span class="number">110u32 </span>, <span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (..) =&gt; <span class="number">263u32 </span>, <span class="self">Self </span>:: CELLULAR_STATUS (..) =&gt; <span class="number">334u32 </span>, <span class="self">Self </span>:: DISTANCE_SENSOR (..) =&gt; <span class="number">132u32 </span>, <span class="self">Self </span>:: VICON_POSITION_ESTIMATE (..) =&gt; <span class="number">104u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (..) =&gt; <span class="number">280u32 </span>, <span class="self">Self </span>:: VFR_HUD (..) =&gt; <span class="number">74u32 </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (..) =&gt; <span class="number">5u32 </span>, <span class="self">Self </span>:: HOME_POSITION (..) =&gt; <span class="number">242u32 </span>, <span class="self">Self </span>:: CAN_FRAME (..) =&gt; <span class="number">386u32 </span>, <span class="self">Self </span>:: ATTITUDE_TARGET (..) =&gt; <span class="number">83u32 </span>, <span class="self">Self </span>:: TIMESYNC (..) =&gt; <span class="number">111u32 </span>, <span class="self">Self </span>:: PLAY_TUNE_V2 (..) =&gt; <span class="number">400u32 </span>, <span class="self">Self </span>:: SYS_STATUS (..) =&gt; <span class="number">1u32 </span>, <span class="self">Self </span>:: CAMERA_SETTINGS (..) =&gt; <span class="number">260u32 </span>, <span class="self">Self </span>:: FLIGHT_INFORMATION (..) =&gt; <span class="number">264u32 </span>, <span class="self">Self </span>:: MOUNT_ORIENTATION (..) =&gt; <span class="number">265u32 </span>, <span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (..) =&gt; <span class="number">62u32 </span>, <span class="self">Self </span>:: CAMERA_INFORMATION (..) =&gt; <span class="number">259u32 </span>, <span class="self">Self </span>:: SCALED_PRESSURE2 (..) =&gt; <span class="number">137u32 </span>, <span class="self">Self </span>:: WIFI_CONFIG_AP (..) =&gt; <span class="number">299u32 </span>, <span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (..) =&gt; <span class="number">390u32 </span>, <span class="self">Self </span>:: TERRAIN_REPORT (..) =&gt; <span class="number">136u32 </span>, <span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (..) =&gt; <span class="number">275u32 </span>, <span class="self">Self </span>:: CONTROL_SYSTEM_STATE (..) =&gt; <span class="number">146u32 </span>, <span class="self">Self </span>:: LOG_DATA (..) =&gt; <span class="number">120u32 </span>, <span class="self">Self </span>:: PARAM_REQUEST_READ (..) =&gt; <span class="number">20u32 </span>, <span class="self">Self </span>:: PING (..) =&gt; <span class="number">4u32 </span>, <span class="self">Self </span>:: SCALED_IMU2 (..) =&gt; <span class="number">116u32 </span>, <span class="self">Self </span>:: AUTH_KEY (..) =&gt; <span class="number">7u32 </span>, <span class="self">Self </span>:: RESPONSE_EVENT_ERROR (..) =&gt; <span class="number">413u32 </span>, <span class="self">Self </span>:: FENCE_STATUS (..) =&gt; <span class="number">162u32 </span>, <span class="self">Self </span>:: GPS2_RAW (..) =&gt; <span class="number">124u32 </span>, <span class="self">Self </span>:: PARAM_VALUE (..) =&gt; <span class="number">22u32 </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (..) =&gt; <span class="number">61u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (..) =&gt; <span class="number">12902u32 </span>, <span class="self">Self </span>:: EFI_STATUS (..) =&gt; <span class="number">225u32 </span>, <span class="self">Self </span>:: VIDEO_STREAM_STATUS (..) =&gt; <span class="number">270u32 </span>, } } <span class="kw">fn </span>message_id_from_name (name : &amp; str) -&gt; <span class="prelude-ty">Result </span>&lt; u32 , &amp; <span class="lifetime">&#39;static </span>str &gt; { <span class="kw">match </span>name { <span class="string">&quot;UTM_GLOBAL_POSITION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">340u32</span>) , <span class="string">&quot;VISION_POSITION_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">102u32</span>) , <span class="string">&quot;SET_ACTUATOR_CONTROL_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">139u32</span>) , <span class="string">&quot;PARAM_EXT_VALUE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">322u32</span>) , <span class="string">&quot;GPS_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">25u32</span>) , <span class="string">&quot;DEBUG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">254u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_SET_ATTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">282u32</span>) , <span class="string">&quot;RESOURCE_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">142u32</span>) , <span class="string">&quot;ACTUATOR_OUTPUT_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">375u32</span>) , <span class="string">&quot;TRAJECTORY_REPRESENTATION_BEZIER&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">333u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">281u32</span>) , <span class="string">&quot;REQUEST_EVENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">412u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_SYSTEM_UPDATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12919u32</span>) , <span class="string">&quot;POWER_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">125u32</span>) , <span class="string">&quot;RC_CHANNELS_SCALED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">34u32</span>) , <span class="string">&quot;MISSION_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">43u32</span>) , <span class="string">&quot;ATT_POS_MOCAP&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">138u32</span>) , <span class="string">&quot;PARAM_MAP_RC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50u32</span>) , <span class="string">&quot;LOG_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">117u32</span>) , <span class="string">&quot;SERVO_OUTPUT_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">36u32</span>) , <span class="string">&quot;CAMERA_FOV_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">271u32</span>) , <span class="string">&quot;ODOMETRY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">331u32</span>) , <span class="string">&quot;WINCH_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">9005u32</span>) , <span class="string">&quot;SAFETY_ALLOWED_AREA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">55u32</span>) , <span class="string">&quot;DATA_TRANSMISSION_HANDSHAKE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">130u32</span>) , <span class="string">&quot;SET_MODE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11u32</span>) , <span class="string">&quot;COMMAND_LONG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">76u32</span>) , <span class="string">&quot;SMART_BATTERY_INFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">370u32</span>) , <span class="string">&quot;POSITION_TARGET_LOCAL_NED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">85u32</span>) , <span class="string">&quot;HIL_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">90u32</span>) , <span class="string">&quot;SET_POSITION_TARGET_LOCAL_NED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">84u32</span>) , <span class="string">&quot;UAVCAN_NODE_INFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">311u32</span>) , <span class="string">&quot;TERRAIN_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">134u32</span>) , <span class="string">&quot;ADSB_VEHICLE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">246u32</span>) , <span class="string">&quot;DEBUG_VECT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">250u32</span>) , <span class="string">&quot;ENCAPSULATED_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">131u32</span>) , <span class="string">&quot;BUTTON_CHANGE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">257u32</span>) , <span class="string">&quot;SET_GPS_GLOBAL_ORIGIN&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">48u32</span>) , <span class="string">&quot;MANUAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">69u32</span>) , <span class="string">&quot;RAW_PRESSURE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">28u32</span>) , <span class="string">&quot;MISSION_ITEM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">39u32</span>) , <span class="string">&quot;ORBIT_EXECUTION_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">360u32</span>) , <span class="string">&quot;MAG_CAL_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">192u32</span>) , <span class="string">&quot;HEARTBEAT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">0u32</span>) , <span class="string">&quot;GIMBAL_DEVICE_ATTITUDE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">285u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_OPERATOR_ID&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12905u32</span>) , <span class="string">&quot;LINK_NODE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">8u32</span>) , <span class="string">&quot;MEMORY_VECT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">249u32</span>) , <span class="string">&quot;EXTENDED_SYS_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">245u32</span>) , <span class="string">&quot;NAMED_VALUE_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">252u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_SYSTEM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12904u32</span>) , <span class="string">&quot;AUTOPILOT_STATE_FOR_GIMBAL_DEVICE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">286u32</span>) , <span class="string">&quot;HIL_SENSOR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">107u32</span>) , <span class="string">&quot;WHEEL_DISTANCE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">9000u32</span>) , <span class="string">&quot;OPTICAL_FLOW_RAD&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">106u32</span>) , <span class="string">&quot;PARAM_EXT_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">324u32</span>) , <span class="string">&quot;ATTITUDE_QUATERNION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">31u32</span>) , <span class="string">&quot;HYGROMETER_SENSOR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12920u32</span>) , <span class="string">&quot;SCALED_PRESSURE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">29u32</span>) , <span class="string">&quot;TUNNEL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">385u32</span>) , <span class="string">&quot;TERRAIN_CHECK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">135u32</span>) , <span class="string">&quot;CAMERA_CAPTURE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">262u32</span>) , <span class="string">&quot;SUPPORTED_TUNES&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">401u32</span>) , <span class="string">&quot;PARAM_EXT_REQUEST_READ&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">320u32</span>) , <span class="string">&quot;COMMAND_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">75u32</span>) , <span class="string">&quot;UAVCAN_NODE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">310u32</span>) , <span class="string">&quot;AUTOPILOT_VERSION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">148u32</span>) , <span class="string">&quot;LOCAL_POSITION_NED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">32u32</span>) , <span class="string">&quot;MISSION_WRITE_PARTIAL_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">38u32</span>) , <span class="string">&quot;LANDING_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">149u32</span>) , <span class="string">&quot;GPS_GLOBAL_ORIGIN&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">49u32</span>) , <span class="string">&quot;SET_ATTITUDE_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">82u32</span>) , <span class="string">&quot;ESC_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">291u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_ARM_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12918u32</span>) , <span class="string">&quot;HIL_STATE_QUATERNION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">115u32</span>) , <span class="string">&quot;GPS2_RTK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">128u32</span>) , <span class="string">&quot;POSITION_TARGET_GLOBAL_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">87u32</span>) , <span class="string">&quot;PARAM_SET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">23u32</span>) , <span class="string">&quot;SETUP_SIGNING&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">256u32</span>) , <span class="string">&quot;MISSION_CURRENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">42u32</span>) , <span class="string">&quot;MANUAL_SETPOINT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">81u32</span>) , <span class="string">&quot;GLOBAL_POSITION_INT_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">63u32</span>) , <span class="string">&quot;V2_EXTENSION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">248u32</span>) , <span class="string">&quot;COLLISION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">247u32</span>) , <span class="string">&quot;FOLLOW_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">144u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_LOCATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12901u32</span>) , <span class="string">&quot;OPTICAL_FLOW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">100u32</span>) , <span class="string">&quot;CHANGE_OPERATOR_CONTROL_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">6u32</span>) , <span class="string">&quot;UAVIONIX_ADSB_OUT_DYNAMIC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">10002u32</span>) , <span class="string">&quot;LOCAL_POSITION_NED_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">64u32</span>) , <span class="string">&quot;COMPONENT_METADATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">397u32</span>) , <span class="string">&quot;LOGGING_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">268u32</span>) , <span class="string">&quot;LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">89u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_BASIC_ID&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12900u32</span>) , <span class="string">&quot;DATA_STREAM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">67u32</span>) , <span class="string">&quot;GIMBAL_DEVICE_SET_ATTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">284u32</span>) , <span class="string">&quot;STORAGE_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">261u32</span>) , <span class="string">&quot;MISSION_REQUEST_PARTIAL_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">37u32</span>) , <span class="string">&quot;CAMERA_TRIGGER&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">112u32</span>) , <span class="string">&quot;RAW_RPM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">339u32</span>) , <span class="string">&quot;PLAY_TUNE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">258u32</span>) , <span class="string">&quot;HIL_CONTROLS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">91u32</span>) , <span class="string">&quot;RADIO_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">109u32</span>) , <span class="string">&quot;LOG_ENTRY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">118u32</span>) , <span class="string">&quot;REQUEST_DATA_STREAM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">66u32</span>) , <span class="string">&quot;VISION_SPEED_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">103u32</span>) , <span class="string">&quot;ATTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">30u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_SELF_ID&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12903u32</span>) , <span class="string">&quot;COMMAND_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">77u32</span>) , <span class="string">&quot;VIBRATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">241u32</span>) , <span class="string">&quot;VIDEO_STREAM_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">269u32</span>) , <span class="string">&quot;TRAJECTORY_REPRESENTATION_WAYPOINTS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">332u32</span>) , <span class="string">&quot;COMPONENT_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">395u32</span>) , <span class="string">&quot;TIME_ESTIMATE_TO_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">380u32</span>) , <span class="string">&quot;MISSION_ITEM_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">73u32</span>) , <span class="string">&quot;EVENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">410u32</span>) , <span class="string">&quot;LOG_REQUEST_END&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">122u32</span>) , <span class="string">&quot;HIL_ACTUATOR_CONTROLS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">93u32</span>) , <span class="string">&quot;PARAM_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">21u32</span>) , <span class="string">&quot;RAW_IMU&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">27u32</span>) , <span class="string">&quot;MISSION_COUNT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">44u32</span>) , <span class="string">&quot;SAFETY_SET_ALLOWED_AREA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">54u32</span>) , <span class="string">&quot;UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">10003u32</span>) , <span class="string">&quot;GIMBAL_DEVICE_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">283u32</span>) , <span class="string">&quot;CELLULAR_CONFIG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">336u32</span>) , <span class="string">&quot;AIS_VESSEL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">301u32</span>) , <span class="string">&quot;CAMERA_TRACKING_GEO_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">276u32</span>) , <span class="string">&quot;HIGHRES_IMU&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">105u32</span>) , <span class="string">&quot;GPS_RAW_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">24u32</span>) , <span class="string">&quot;MISSION_ITEM_REACHED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">46u32</span>) , <span class="string">&quot;HIL_GPS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">113u32</span>) , <span class="string">&quot;GPS_RTK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">127u32</span>) , <span class="string">&quot;MISSION_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">47u32</span>) , <span class="string">&quot;SYSTEM_TIME&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">2u32</span>) , <span class="string">&quot;ESTIMATOR_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">230u32</span>) , <span class="string">&quot;SET_POSITION_TARGET_GLOBAL_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">86u32</span>) , <span class="string">&quot;SET_HOME_POSITION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">243u32</span>) , <span class="string">&quot;GENERATOR_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">373u32</span>) , <span class="string">&quot;GPS_RTCM_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">233u32</span>) , <span class="string">&quot;OBSTACLE_DISTANCE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">330u32</span>) , <span class="string">&quot;COMMAND_CANCEL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">80u32</span>) , <span class="string">&quot;MESSAGE_INTERVAL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">244u32</span>) , <span class="string">&quot;MISSION_SET_CURRENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">41u32</span>) , <span class="string">&quot;SCALED_PRESSURE3&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">143u32</span>) , <span class="string">&quot;UAVIONIX_ADSB_OUT_CFG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">10001u32</span>) , <span class="string">&quot;SIM_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">108u32</span>) , <span class="string">&quot;GLOBAL_POSITION_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">33u32</span>) , <span class="string">&quot;CURRENT_EVENT_SEQUENCE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">411u32</span>) , <span class="string">&quot;BATTERY_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">147u32</span>) , <span class="string">&quot;WIND_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">231u32</span>) , <span class="string">&quot;STATUSTEXT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">253u32</span>) , <span class="string">&quot;CANFD_FRAME&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">387u32</span>) , <span class="string">&quot;GPS_INPUT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">232u32</span>) , <span class="string">&quot;SCALED_IMU3&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">129u32</span>) , <span class="string">&quot;RC_CHANNELS_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">35u32</span>) , <span class="string">&quot;MISSION_CLEAR_ALL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">45u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_SET_PITCHYAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">287u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_SET_MANUAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">288u32</span>) , <span class="string">&quot;PROTOCOL_VERSION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">300u32</span>) , <span class="string">&quot;PARAM_EXT_SET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">323u32</span>) , <span class="string">&quot;MISSION_REQUEST_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">51u32</span>) , <span class="string">&quot;SERIAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">126u32</span>) , <span class="string">&quot;ACTUATOR_CONTROL_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">140u32</span>) , <span class="string">&quot;ISBD_LINK_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">335u32</span>) , <span class="string">&quot;LOGGING_DATA_ACKED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">267u32</span>) , <span class="string">&quot;HIL_RC_INPUTS_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">92u32</span>) , <span class="string">&quot;RC_CHANNELS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">65u32</span>) , <span class="string">&quot;NAMED_VALUE_FLOAT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">251u32</span>) , <span class="string">&quot;CAN_FILTER_MODIFY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">388u32</span>) , <span class="string">&quot;ESC_INFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">290u32</span>) , <span class="string">&quot;MISSION_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">40u32</span>) , <span class="string">&quot;HIL_OPTICAL_FLOW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">114u32</span>) , <span class="string">&quot;HIGH_LATENCY2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">235u32</span>) , <span class="string">&quot;SCALED_IMU&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">26u32</span>) , <span class="string">&quot;LOG_ERASE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">121u32</span>) , <span class="string">&quot;GPS_INJECT_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">123u32</span>) , <span class="string">&quot;LOGGING_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">266u32</span>) , <span class="string">&quot;HIGH_LATENCY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">234u32</span>) , <span class="string">&quot;ALTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">141u32</span>) , <span class="string">&quot;TERRAIN_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">133u32</span>) , <span class="string">&quot;PARAM_EXT_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">321u32</span>) , <span class="string">&quot;LOG_REQUEST_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">119u32</span>) , <span class="string">&quot;DEBUG_FLOAT_ARRAY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">350u32</span>) , <span class="string">&quot;RC_CHANNELS_OVERRIDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">70u32</span>) , <span class="string">&quot;GLOBAL_VISION_POSITION_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">101u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_MESSAGE_PACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12915u32</span>) , <span class="string">&quot;FILE_TRANSFER_PROTOCOL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">110u32</span>) , <span class="string">&quot;CAMERA_IMAGE_CAPTURED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">263u32</span>) , <span class="string">&quot;CELLULAR_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">334u32</span>) , <span class="string">&quot;DISTANCE_SENSOR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">132u32</span>) , <span class="string">&quot;VICON_POSITION_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">104u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">280u32</span>) , <span class="string">&quot;VFR_HUD&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">74u32</span>) , <span class="string">&quot;CHANGE_OPERATOR_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">5u32</span>) , <span class="string">&quot;HOME_POSITION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">242u32</span>) , <span class="string">&quot;CAN_FRAME&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">386u32</span>) , <span class="string">&quot;ATTITUDE_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">83u32</span>) , <span class="string">&quot;TIMESYNC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">111u32</span>) , <span class="string">&quot;PLAY_TUNE_V2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">400u32</span>) , <span class="string">&quot;SYS_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">1u32</span>) , <span class="string">&quot;CAMERA_SETTINGS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">260u32</span>) , <span class="string">&quot;FLIGHT_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">264u32</span>) , <span class="string">&quot;MOUNT_ORIENTATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">265u32</span>) , <span class="string">&quot;NAV_CONTROLLER_OUTPUT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">62u32</span>) , <span class="string">&quot;CAMERA_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">259u32</span>) , <span class="string">&quot;SCALED_PRESSURE2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">137u32</span>) , <span class="string">&quot;WIFI_CONFIG_AP&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">299u32</span>) , <span class="string">&quot;ONBOARD_COMPUTER_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">390u32</span>) , <span class="string">&quot;TERRAIN_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">136u32</span>) , <span class="string">&quot;CAMERA_TRACKING_IMAGE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">275u32</span>) , <span class="string">&quot;CONTROL_SYSTEM_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">146u32</span>) , <span class="string">&quot;LOG_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">120u32</span>) , <span class="string">&quot;PARAM_REQUEST_READ&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">20u32</span>) , <span class="string">&quot;PING&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">4u32</span>) , <span class="string">&quot;SCALED_IMU2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">116u32</span>) , <span class="string">&quot;AUTH_KEY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">7u32</span>) , <span class="string">&quot;RESPONSE_EVENT_ERROR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">413u32</span>) , <span class="string">&quot;FENCE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">162u32</span>) , <span class="string">&quot;GPS2_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">124u32</span>) , <span class="string">&quot;PARAM_VALUE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">22u32</span>) , <span class="string">&quot;ATTITUDE_QUATERNION_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">61u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_AUTHENTICATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12902u32</span>) , <span class="string">&quot;EFI_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">225u32</span>) , <span class="string">&quot;VIDEO_STREAM_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">270u32</span>) , <span class="kw">_ </span>=&gt; { <span class="prelude-val">Err </span>(<span class="string">&quot;Invalid message name.&quot;</span>) } } } <span class="kw">fn </span>default_message_from_id (id : u32) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, &amp; <span class="lifetime">&#39;static </span>str &gt; { <span class="kw">match </span>id { <span class="number">340u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UTM_GLOBAL_POSITION (UTM_GLOBAL_POSITION_DATA :: default ())) , <span class="number">102u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VISION_POSITION_ESTIMATE (VISION_POSITION_ESTIMATE_DATA :: default ())) , <span class="number">139u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (SET_ACTUATOR_CONTROL_TARGET_DATA :: default ())) , <span class="number">322u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_VALUE (PARAM_EXT_VALUE_DATA :: default ())) , <span class="number">25u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_STATUS (GPS_STATUS_DATA :: default ())) , <span class="number">254u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEBUG (DEBUG_DATA :: default ())) , <span class="number">282u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (GIMBAL_MANAGER_SET_ATTITUDE_DATA :: default ())) , <span class="number">142u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RESOURCE_REQUEST (RESOURCE_REQUEST_DATA :: default ())) , <span class="number">375u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (ACTUATOR_OUTPUT_STATUS_DATA :: default ())) , <span class="number">333u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (TRAJECTORY_REPRESENTATION_BEZIER_DATA :: default ())) , <span class="number">281u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (GIMBAL_MANAGER_STATUS_DATA :: default ())) , <span class="number">412u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: REQUEST_EVENT (REQUEST_EVENT_DATA :: default ())) , <span class="number">12919u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (OPEN_DRONE_ID_SYSTEM_UPDATE_DATA :: default ())) , <span class="number">125u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: POWER_STATUS (POWER_STATUS_DATA :: default ())) , <span class="number">34u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS_SCALED (RC_CHANNELS_SCALED_DATA :: default ())) , <span class="number">43u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST_LIST (MISSION_REQUEST_LIST_DATA :: default ())) , <span class="number">138u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATT_POS_MOCAP (ATT_POS_MOCAP_DATA :: default ())) , <span class="number">50u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_MAP_RC (PARAM_MAP_RC_DATA :: default ())) , <span class="number">117u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_REQUEST_LIST (LOG_REQUEST_LIST_DATA :: default ())) , <span class="number">36u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SERVO_OUTPUT_RAW (SERVO_OUTPUT_RAW_DATA :: default ())) , <span class="number">271u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_FOV_STATUS (CAMERA_FOV_STATUS_DATA :: default ())) , <span class="number">331u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ODOMETRY (ODOMETRY_DATA :: default ())) , <span class="number">9005u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WINCH_STATUS (WINCH_STATUS_DATA :: default ())) , <span class="number">55u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SAFETY_ALLOWED_AREA (SAFETY_ALLOWED_AREA_DATA :: default ())) , <span class="number">130u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (DATA_TRANSMISSION_HANDSHAKE_DATA :: default ())) , <span class="number">11u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_MODE (SET_MODE_DATA :: default ())) , <span class="number">76u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_LONG (COMMAND_LONG_DATA :: default ())) , <span class="number">370u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SMART_BATTERY_INFO (SMART_BATTERY_INFO_DATA :: default ())) , <span class="number">85u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (POSITION_TARGET_LOCAL_NED_DATA :: default ())) , <span class="number">90u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_STATE (HIL_STATE_DATA :: default ())) , <span class="number">84u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (SET_POSITION_TARGET_LOCAL_NED_DATA :: default ())) , <span class="number">311u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVCAN_NODE_INFO (UAVCAN_NODE_INFO_DATA :: default ())) , <span class="number">134u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_DATA (TERRAIN_DATA_DATA :: default ())) , <span class="number">246u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ADSB_VEHICLE (ADSB_VEHICLE_DATA :: default ())) , <span class="number">250u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEBUG_VECT (DEBUG_VECT_DATA :: default ())) , <span class="number">131u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ENCAPSULATED_DATA (ENCAPSULATED_DATA_DATA :: default ())) , <span class="number">257u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: BUTTON_CHANGE (BUTTON_CHANGE_DATA :: default ())) , <span class="number">48u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (SET_GPS_GLOBAL_ORIGIN_DATA :: default ())) , <span class="number">69u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MANUAL_CONTROL (MANUAL_CONTROL_DATA :: default ())) , <span class="number">28u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RAW_PRESSURE (RAW_PRESSURE_DATA :: default ())) , <span class="number">39u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ITEM (MISSION_ITEM_DATA :: default ())) , <span class="number">360u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (ORBIT_EXECUTION_STATUS_DATA :: default ())) , <span class="number">192u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MAG_CAL_REPORT (MAG_CAL_REPORT_DATA :: default ())) , <span class="number">0u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HEARTBEAT (HEARTBEAT_DATA :: default ())) , <span class="number">285u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (GIMBAL_DEVICE_ATTITUDE_STATUS_DATA :: default ())) , <span class="number">12905u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (OPEN_DRONE_ID_OPERATOR_ID_DATA :: default ())) , <span class="number">8u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LINK_NODE_STATUS (LINK_NODE_STATUS_DATA :: default ())) , <span class="number">249u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MEMORY_VECT (MEMORY_VECT_DATA :: default ())) , <span class="number">245u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EXTENDED_SYS_STATE (EXTENDED_SYS_STATE_DATA :: default ())) , <span class="number">252u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: NAMED_VALUE_INT (NAMED_VALUE_INT_DATA :: default ())) , <span class="number">12904u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (OPEN_DRONE_ID_SYSTEM_DATA :: default ())) , <span class="number">286u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA :: default ())) , <span class="number">107u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_SENSOR (HIL_SENSOR_DATA :: default ())) , <span class="number">9000u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WHEEL_DISTANCE (WHEEL_DISTANCE_DATA :: default ())) , <span class="number">106u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPTICAL_FLOW_RAD (OPTICAL_FLOW_RAD_DATA :: default ())) , <span class="number">324u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_ACK (PARAM_EXT_ACK_DATA :: default ())) , <span class="number">31u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE_QUATERNION (ATTITUDE_QUATERNION_DATA :: default ())) , <span class="number">12920u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HYGROMETER_SENSOR (HYGROMETER_SENSOR_DATA :: default ())) , <span class="number">29u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_PRESSURE (SCALED_PRESSURE_DATA :: default ())) , <span class="number">385u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TUNNEL (TUNNEL_DATA :: default ())) , <span class="number">135u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_CHECK (TERRAIN_CHECK_DATA :: default ())) , <span class="number">262u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (CAMERA_CAPTURE_STATUS_DATA :: default ())) , <span class="number">401u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SUPPORTED_TUNES (SUPPORTED_TUNES_DATA :: default ())) , <span class="number">320u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (PARAM_EXT_REQUEST_READ_DATA :: default ())) , <span class="number">75u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_INT (COMMAND_INT_DATA :: default ())) , <span class="number">310u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVCAN_NODE_STATUS (UAVCAN_NODE_STATUS_DATA :: default ())) , <span class="number">148u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTOPILOT_VERSION (AUTOPILOT_VERSION_DATA :: default ())) , <span class="number">32u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOCAL_POSITION_NED (LOCAL_POSITION_NED_DATA :: default ())) , <span class="number">38u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (MISSION_WRITE_PARTIAL_LIST_DATA :: default ())) , <span class="number">149u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LANDING_TARGET (LANDING_TARGET_DATA :: default ())) , <span class="number">49u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (GPS_GLOBAL_ORIGIN_DATA :: default ())) , <span class="number">82u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_ATTITUDE_TARGET (SET_ATTITUDE_TARGET_DATA :: default ())) , <span class="number">291u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_STATUS (ESC_STATUS_DATA :: default ())) , <span class="number">12918u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (OPEN_DRONE_ID_ARM_STATUS_DATA :: default ())) , <span class="number">115u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_STATE_QUATERNION (HIL_STATE_QUATERNION_DATA :: default ())) , <span class="number">128u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS2_RTK (GPS2_RTK_DATA :: default ())) , <span class="number">87u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (POSITION_TARGET_GLOBAL_INT_DATA :: default ())) , <span class="number">23u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_SET (PARAM_SET_DATA :: default ())) , <span class="number">256u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SETUP_SIGNING (SETUP_SIGNING_DATA :: default ())) , <span class="number">42u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_CURRENT (MISSION_CURRENT_DATA :: default ())) , <span class="number">81u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MANUAL_SETPOINT (MANUAL_SETPOINT_DATA :: default ())) , <span class="number">63u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (GLOBAL_POSITION_INT_COV_DATA :: default ())) , <span class="number">248u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: V2_EXTENSION (V2_EXTENSION_DATA :: default ())) , <span class="number">247u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COLLISION (COLLISION_DATA :: default ())) , <span class="number">144u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FOLLOW_TARGET (FOLLOW_TARGET_DATA :: default ())) , <span class="number">12901u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (OPEN_DRONE_ID_LOCATION_DATA :: default ())) , <span class="number">100u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPTICAL_FLOW (OPTICAL_FLOW_DATA :: default ())) , <span class="number">6u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (CHANGE_OPERATOR_CONTROL_ACK_DATA :: default ())) , <span class="number">10002u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (UAVIONIX_ADSB_OUT_DYNAMIC_DATA :: default ())) , <span class="number">64u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOCAL_POSITION_NED_COV (LOCAL_POSITION_NED_COV_DATA :: default ())) , <span class="number">397u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMPONENT_METADATA (COMPONENT_METADATA_DATA :: default ())) , <span class="number">268u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOGGING_ACK (LOGGING_ACK_DATA :: default ())) , <span class="number">89u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA :: default ())) , <span class="number">12900u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (OPEN_DRONE_ID_BASIC_ID_DATA :: default ())) , <span class="number">67u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA_STREAM (DATA_STREAM_DATA :: default ())) , <span class="number">284u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (GIMBAL_DEVICE_SET_ATTITUDE_DATA :: default ())) , <span class="number">261u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: STORAGE_INFORMATION (STORAGE_INFORMATION_DATA :: default ())) , <span class="number">37u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (MISSION_REQUEST_PARTIAL_LIST_DATA :: default ())) , <span class="number">112u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_TRIGGER (CAMERA_TRIGGER_DATA :: default ())) , <span class="number">339u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RAW_RPM (RAW_RPM_DATA :: default ())) , <span class="number">258u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PLAY_TUNE (PLAY_TUNE_DATA :: default ())) , <span class="number">91u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_CONTROLS (HIL_CONTROLS_DATA :: default ())) , <span class="number">109u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RADIO_STATUS (RADIO_STATUS_DATA :: default ())) , <span class="number">118u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_ENTRY (LOG_ENTRY_DATA :: default ())) , <span class="number">66u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: REQUEST_DATA_STREAM (REQUEST_DATA_STREAM_DATA :: default ())) , <span class="number">103u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VISION_SPEED_ESTIMATE (VISION_SPEED_ESTIMATE_DATA :: default ())) , <span class="number">30u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE (ATTITUDE_DATA :: default ())) , <span class="number">12903u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (OPEN_DRONE_ID_SELF_ID_DATA :: default ())) , <span class="number">77u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_ACK (COMMAND_ACK_DATA :: default ())) , <span class="number">241u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VIBRATION (VIBRATION_DATA :: default ())) , <span class="number">269u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (VIDEO_STREAM_INFORMATION_DATA :: default ())) , <span class="number">332u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA :: default ())) , <span class="number">395u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMPONENT_INFORMATION (COMPONENT_INFORMATION_DATA :: default ())) , <span class="number">380u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (TIME_ESTIMATE_TO_TARGET_DATA :: default ())) , <span class="number">73u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ITEM_INT (MISSION_ITEM_INT_DATA :: default ())) , <span class="number">410u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EVENT (EVENT_DATA :: default ())) , <span class="number">122u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_REQUEST_END (LOG_REQUEST_END_DATA :: default ())) , <span class="number">93u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (HIL_ACTUATOR_CONTROLS_DATA :: default ())) , <span class="number">21u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_REQUEST_LIST (PARAM_REQUEST_LIST_DATA :: default ())) , <span class="number">27u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RAW_IMU (RAW_IMU_DATA :: default ())) , <span class="number">44u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_COUNT (MISSION_COUNT_DATA :: default ())) , <span class="number">54u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (SAFETY_SET_ALLOWED_AREA_DATA :: default ())) , <span class="number">10003u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA :: default ())) , <span class="number">283u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (GIMBAL_DEVICE_INFORMATION_DATA :: default ())) , <span class="number">336u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CELLULAR_CONFIG (CELLULAR_CONFIG_DATA :: default ())) , <span class="number">301u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AIS_VESSEL (AIS_VESSEL_DATA :: default ())) , <span class="number">276u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (CAMERA_TRACKING_GEO_STATUS_DATA :: default ())) , <span class="number">105u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIGHRES_IMU (HIGHRES_IMU_DATA :: default ())) , <span class="number">24u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_RAW_INT (GPS_RAW_INT_DATA :: default ())) , <span class="number">46u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ITEM_REACHED (MISSION_ITEM_REACHED_DATA :: default ())) , <span class="number">113u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_GPS (HIL_GPS_DATA :: default ())) , <span class="number">127u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_RTK (GPS_RTK_DATA :: default ())) , <span class="number">47u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ACK (MISSION_ACK_DATA :: default ())) , <span class="number">2u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SYSTEM_TIME (SYSTEM_TIME_DATA :: default ())) , <span class="number">230u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESTIMATOR_STATUS (ESTIMATOR_STATUS_DATA :: default ())) , <span class="number">86u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (SET_POSITION_TARGET_GLOBAL_INT_DATA :: default ())) , <span class="number">243u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_HOME_POSITION (SET_HOME_POSITION_DATA :: default ())) , <span class="number">373u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GENERATOR_STATUS (GENERATOR_STATUS_DATA :: default ())) , <span class="number">233u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_RTCM_DATA (GPS_RTCM_DATA_DATA :: default ())) , <span class="number">330u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OBSTACLE_DISTANCE (OBSTACLE_DISTANCE_DATA :: default ())) , <span class="number">80u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_CANCEL (COMMAND_CANCEL_DATA :: default ())) , <span class="number">244u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MESSAGE_INTERVAL (MESSAGE_INTERVAL_DATA :: default ())) , <span class="number">41u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_SET_CURRENT (MISSION_SET_CURRENT_DATA :: default ())) , <span class="number">143u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_PRESSURE3 (SCALED_PRESSURE3_DATA :: default ())) , <span class="number">10001u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (UAVIONIX_ADSB_OUT_CFG_DATA :: default ())) , <span class="number">108u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SIM_STATE (SIM_STATE_DATA :: default ())) , <span class="number">33u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GLOBAL_POSITION_INT (GLOBAL_POSITION_INT_DATA :: default ())) , <span class="number">411u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (CURRENT_EVENT_SEQUENCE_DATA :: default ())) , <span class="number">147u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: BATTERY_STATUS (BATTERY_STATUS_DATA :: default ())) , <span class="number">231u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WIND_COV (WIND_COV_DATA :: default ())) , <span class="number">253u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: STATUSTEXT (STATUSTEXT_DATA :: default ())) , <span class="number">387u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CANFD_FRAME (CANFD_FRAME_DATA :: default ())) , <span class="number">232u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_INPUT (GPS_INPUT_DATA :: default ())) , <span class="number">129u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_IMU3 (SCALED_IMU3_DATA :: default ())) , <span class="number">35u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS_RAW (RC_CHANNELS_RAW_DATA :: default ())) , <span class="number">45u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_CLEAR_ALL (MISSION_CLEAR_ALL_DATA :: default ())) , <span class="number">287u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (GIMBAL_MANAGER_SET_PITCHYAW_DATA :: default ())) , <span class="number">288u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA :: default ())) , <span class="number">300u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PROTOCOL_VERSION (PROTOCOL_VERSION_DATA :: default ())) , <span class="number">323u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_SET (PARAM_EXT_SET_DATA :: default ())) , <span class="number">51u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST_INT (MISSION_REQUEST_INT_DATA :: default ())) , <span class="number">126u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SERIAL_CONTROL (SERIAL_CONTROL_DATA :: default ())) , <span class="number">140u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (ACTUATOR_CONTROL_TARGET_DATA :: default ())) , <span class="number">335u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ISBD_LINK_STATUS (ISBD_LINK_STATUS_DATA :: default ())) , <span class="number">267u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOGGING_DATA_ACKED (LOGGING_DATA_ACKED_DATA :: default ())) , <span class="number">92u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_RC_INPUTS_RAW (HIL_RC_INPUTS_RAW_DATA :: default ())) , <span class="number">65u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS (RC_CHANNELS_DATA :: default ())) , <span class="number">251u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: NAMED_VALUE_FLOAT (NAMED_VALUE_FLOAT_DATA :: default ())) , <span class="number">388u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAN_FILTER_MODIFY (CAN_FILTER_MODIFY_DATA :: default ())) , <span class="number">290u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_INFO (ESC_INFO_DATA :: default ())) , <span class="number">40u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST (MISSION_REQUEST_DATA :: default ())) , <span class="number">114u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_OPTICAL_FLOW (HIL_OPTICAL_FLOW_DATA :: default ())) , <span class="number">235u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIGH_LATENCY2 (HIGH_LATENCY2_DATA :: default ())) , <span class="number">26u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_IMU (SCALED_IMU_DATA :: default ())) , <span class="number">121u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_ERASE (LOG_ERASE_DATA :: default ())) , <span class="number">123u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_INJECT_DATA (GPS_INJECT_DATA_DATA :: default ())) , <span class="number">266u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOGGING_DATA (LOGGING_DATA_DATA :: default ())) , <span class="number">234u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIGH_LATENCY (HIGH_LATENCY_DATA :: default ())) , <span class="number">141u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ALTITUDE (ALTITUDE_DATA :: default ())) , <span class="number">133u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_REQUEST (TERRAIN_REQUEST_DATA :: default ())) , <span class="number">321u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (PARAM_EXT_REQUEST_LIST_DATA :: default ())) , <span class="number">119u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_REQUEST_DATA (LOG_REQUEST_DATA_DATA :: default ())) , <span class="number">350u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (DEBUG_FLOAT_ARRAY_DATA :: default ())) , <span class="number">70u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (RC_CHANNELS_OVERRIDE_DATA :: default ())) , <span class="number">101u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (GLOBAL_VISION_POSITION_ESTIMATE_DATA :: default ())) , <span class="number">12915u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (OPEN_DRONE_ID_MESSAGE_PACK_DATA :: default ())) , <span class="number">110u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (FILE_TRANSFER_PROTOCOL_DATA :: default ())) , <span class="number">263u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (CAMERA_IMAGE_CAPTURED_DATA :: default ())) , <span class="number">334u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CELLULAR_STATUS (CELLULAR_STATUS_DATA :: default ())) , <span class="number">132u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DISTANCE_SENSOR (DISTANCE_SENSOR_DATA :: default ())) , <span class="number">104u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VICON_POSITION_ESTIMATE (VICON_POSITION_ESTIMATE_DATA :: default ())) , <span class="number">280u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (GIMBAL_MANAGER_INFORMATION_DATA :: default ())) , <span class="number">74u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VFR_HUD (VFR_HUD_DATA :: default ())) , <span class="number">5u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (CHANGE_OPERATOR_CONTROL_DATA :: default ())) , <span class="number">242u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HOME_POSITION (HOME_POSITION_DATA :: default ())) , <span class="number">386u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAN_FRAME (CAN_FRAME_DATA :: default ())) , <span class="number">83u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE_TARGET (ATTITUDE_TARGET_DATA :: default ())) , <span class="number">111u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TIMESYNC (TIMESYNC_DATA :: default ())) , <span class="number">400u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PLAY_TUNE_V2 (PLAY_TUNE_V2_DATA :: default ())) , <span class="number">1u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SYS_STATUS (SYS_STATUS_DATA :: default ())) , <span class="number">260u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_SETTINGS (CAMERA_SETTINGS_DATA :: default ())) , <span class="number">264u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FLIGHT_INFORMATION (FLIGHT_INFORMATION_DATA :: default ())) , <span class="number">265u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MOUNT_ORIENTATION (MOUNT_ORIENTATION_DATA :: default ())) , <span class="number">62u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (NAV_CONTROLLER_OUTPUT_DATA :: default ())) , <span class="number">259u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_INFORMATION (CAMERA_INFORMATION_DATA :: default ())) , <span class="number">137u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_PRESSURE2 (SCALED_PRESSURE2_DATA :: default ())) , <span class="number">299u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WIFI_CONFIG_AP (WIFI_CONFIG_AP_DATA :: default ())) , <span class="number">390u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (ONBOARD_COMPUTER_STATUS_DATA :: default ())) , <span class="number">136u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_REPORT (TERRAIN_REPORT_DATA :: default ())) , <span class="number">275u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (CAMERA_TRACKING_IMAGE_STATUS_DATA :: default ())) , <span class="number">146u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CONTROL_SYSTEM_STATE (CONTROL_SYSTEM_STATE_DATA :: default ())) , <span class="number">120u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_DATA (LOG_DATA_DATA :: default ())) , <span class="number">20u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_REQUEST_READ (PARAM_REQUEST_READ_DATA :: default ())) , <span class="number">4u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PING (PING_DATA :: default ())) , <span class="number">116u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_IMU2 (SCALED_IMU2_DATA :: default ())) , <span class="number">7u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTH_KEY (AUTH_KEY_DATA :: default ())) , <span class="number">413u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RESPONSE_EVENT_ERROR (RESPONSE_EVENT_ERROR_DATA :: default ())) , <span class="number">162u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FENCE_STATUS (FENCE_STATUS_DATA :: default ())) , <span class="number">124u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS2_RAW (GPS2_RAW_DATA :: default ())) , <span class="number">22u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_VALUE (PARAM_VALUE_DATA :: default ())) , <span class="number">61u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (ATTITUDE_QUATERNION_COV_DATA :: default ())) , <span class="number">12902u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (OPEN_DRONE_ID_AUTHENTICATION_DATA :: default ())) , <span class="number">225u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EFI_STATUS (EFI_STATUS_DATA :: default ())) , <span class="number">270u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VIDEO_STREAM_STATUS (VIDEO_STREAM_STATUS_DATA :: default ())) , <span class="kw">_ </span>=&gt; { <span class="prelude-val">Err </span>(<span class="string">&quot;Invalid message id.&quot;</span>) } } } <span class="kw">fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">match </span><span class="self">self </span>{ <span class="self">Self </span>:: UTM_GLOBAL_POSITION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VISION_POSITION_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_VALUE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEBUG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RESOURCE_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: REQUEST_EVENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: POWER_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS_SCALED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATT_POS_MOCAP (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_MAP_RC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SERVO_OUTPUT_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_FOV_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ODOMETRY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WINCH_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SAFETY_ALLOWED_AREA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_MODE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_LONG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SMART_BATTERY_INFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVCAN_NODE_INFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ADSB_VEHICLE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEBUG_VECT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ENCAPSULATED_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: BUTTON_CHANGE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MANUAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RAW_PRESSURE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ITEM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MAG_CAL_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HEARTBEAT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LINK_NODE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MEMORY_VECT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EXTENDED_SYS_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: NAMED_VALUE_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_SENSOR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WHEEL_DISTANCE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPTICAL_FLOW_RAD (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE_QUATERNION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HYGROMETER_SENSOR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_PRESSURE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TUNNEL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_CHECK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SUPPORTED_TUNES (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVCAN_NODE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTOPILOT_VERSION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOCAL_POSITION_NED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LANDING_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_ATTITUDE_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_STATE_QUATERNION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS2_RTK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_SET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SETUP_SIGNING (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_CURRENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MANUAL_SETPOINT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: V2_EXTENSION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COLLISION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FOLLOW_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPTICAL_FLOW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOCAL_POSITION_NED_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMPONENT_METADATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOGGING_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA_STREAM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: STORAGE_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_TRIGGER (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RAW_RPM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PLAY_TUNE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_CONTROLS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RADIO_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_ENTRY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: REQUEST_DATA_STREAM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VISION_SPEED_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VIBRATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMPONENT_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ITEM_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EVENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_REQUEST_END (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RAW_IMU (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_COUNT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CELLULAR_CONFIG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AIS_VESSEL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIGHRES_IMU (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_RAW_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ITEM_REACHED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_GPS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_RTK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SYSTEM_TIME (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESTIMATOR_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_HOME_POSITION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GENERATOR_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_RTCM_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OBSTACLE_DISTANCE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_CANCEL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MESSAGE_INTERVAL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_SET_CURRENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_PRESSURE3 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SIM_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GLOBAL_POSITION_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: BATTERY_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WIND_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: STATUSTEXT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CANFD_FRAME (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_INPUT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_IMU3 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_CLEAR_ALL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PROTOCOL_VERSION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_SET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SERIAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ISBD_LINK_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOGGING_DATA_ACKED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_RC_INPUTS_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: NAMED_VALUE_FLOAT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAN_FILTER_MODIFY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_INFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_OPTICAL_FLOW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIGH_LATENCY2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_IMU (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_ERASE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_INJECT_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOGGING_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIGH_LATENCY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ALTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_REQUEST_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CELLULAR_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DISTANCE_SENSOR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VICON_POSITION_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VFR_HUD (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HOME_POSITION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAN_FRAME (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TIMESYNC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PLAY_TUNE_V2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SYS_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_SETTINGS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FLIGHT_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MOUNT_ORIENTATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_PRESSURE2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WIFI_CONFIG_AP (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CONTROL_SYSTEM_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_REQUEST_READ (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PING (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_IMU2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTH_KEY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RESPONSE_EVENT_ERROR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FENCE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS2_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_VALUE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EFI_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VIDEO_STREAM_STATUS (body) =&gt; body . ser (version , bytes) , } } <span class="kw">fn </span>extra_crc (id : u32) -&gt; u8 { <span class="kw">match </span>id { <span class="number">340u32 </span>=&gt; <span class="number">99u8 </span>, <span class="number">102u32 </span>=&gt; <span class="number">158u8 </span>, <span class="number">139u32 </span>=&gt; <span class="number">168u8 </span>, <span class="number">322u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">25u32 </span>=&gt; <span class="number">23u8 </span>, <span class="number">254u32 </span>=&gt; <span class="number">46u8 </span>, <span class="number">282u32 </span>=&gt; <span class="number">123u8 </span>, <span class="number">142u32 </span>=&gt; <span class="number">72u8 </span>, <span class="number">375u32 </span>=&gt; <span class="number">251u8 </span>, <span class="number">333u32 </span>=&gt; <span class="number">231u8 </span>, <span class="number">281u32 </span>=&gt; <span class="number">48u8 </span>, <span class="number">412u32 </span>=&gt; <span class="number">33u8 </span>, <span class="number">12919u32 </span>=&gt; <span class="number">7u8 </span>, <span class="number">125u32 </span>=&gt; <span class="number">203u8 </span>, <span class="number">34u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">43u32 </span>=&gt; <span class="number">132u8 </span>, <span class="number">138u32 </span>=&gt; <span class="number">109u8 </span>, <span class="number">50u32 </span>=&gt; <span class="number">78u8 </span>, <span class="number">117u32 </span>=&gt; <span class="number">128u8 </span>, <span class="number">36u32 </span>=&gt; <span class="number">222u8 </span>, <span class="number">271u32 </span>=&gt; <span class="number">22u8 </span>, <span class="number">331u32 </span>=&gt; <span class="number">91u8 </span>, <span class="number">9005u32 </span>=&gt; <span class="number">117u8 </span>, <span class="number">55u32 </span>=&gt; <span class="number">3u8 </span>, <span class="number">130u32 </span>=&gt; <span class="number">29u8 </span>, <span class="number">11u32 </span>=&gt; <span class="number">89u8 </span>, <span class="number">76u32 </span>=&gt; <span class="number">152u8 </span>, <span class="number">370u32 </span>=&gt; <span class="number">75u8 </span>, <span class="number">85u32 </span>=&gt; <span class="number">140u8 </span>, <span class="number">90u32 </span>=&gt; <span class="number">183u8 </span>, <span class="number">84u32 </span>=&gt; <span class="number">143u8 </span>, <span class="number">311u32 </span>=&gt; <span class="number">95u8 </span>, <span class="number">134u32 </span>=&gt; <span class="number">229u8 </span>, <span class="number">246u32 </span>=&gt; <span class="number">184u8 </span>, <span class="number">250u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">131u32 </span>=&gt; <span class="number">223u8 </span>, <span class="number">257u32 </span>=&gt; <span class="number">131u8 </span>, <span class="number">48u32 </span>=&gt; <span class="number">41u8 </span>, <span class="number">69u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">28u32 </span>=&gt; <span class="number">67u8 </span>, <span class="number">39u32 </span>=&gt; <span class="number">254u8 </span>, <span class="number">360u32 </span>=&gt; <span class="number">11u8 </span>, <span class="number">192u32 </span>=&gt; <span class="number">36u8 </span>, <span class="number">0u32 </span>=&gt; <span class="number">50u8 </span>, <span class="number">285u32 </span>=&gt; <span class="number">137u8 </span>, <span class="number">12905u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">8u32 </span>=&gt; <span class="number">117u8 </span>, <span class="number">249u32 </span>=&gt; <span class="number">204u8 </span>, <span class="number">245u32 </span>=&gt; <span class="number">130u8 </span>, <span class="number">252u32 </span>=&gt; <span class="number">44u8 </span>, <span class="number">12904u32 </span>=&gt; <span class="number">77u8 </span>, <span class="number">286u32 </span>=&gt; <span class="number">210u8 </span>, <span class="number">107u32 </span>=&gt; <span class="number">108u8 </span>, <span class="number">9000u32 </span>=&gt; <span class="number">113u8 </span>, <span class="number">106u32 </span>=&gt; <span class="number">138u8 </span>, <span class="number">324u32 </span>=&gt; <span class="number">132u8 </span>, <span class="number">31u32 </span>=&gt; <span class="number">246u8 </span>, <span class="number">12920u32 </span>=&gt; <span class="number">20u8 </span>, <span class="number">29u32 </span>=&gt; <span class="number">115u8 </span>, <span class="number">385u32 </span>=&gt; <span class="number">147u8 </span>, <span class="number">135u32 </span>=&gt; <span class="number">203u8 </span>, <span class="number">262u32 </span>=&gt; <span class="number">12u8 </span>, <span class="number">401u32 </span>=&gt; <span class="number">183u8 </span>, <span class="number">320u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">75u32 </span>=&gt; <span class="number">158u8 </span>, <span class="number">310u32 </span>=&gt; <span class="number">28u8 </span>, <span class="number">148u32 </span>=&gt; <span class="number">178u8 </span>, <span class="number">32u32 </span>=&gt; <span class="number">185u8 </span>, <span class="number">38u32 </span>=&gt; <span class="number">9u8 </span>, <span class="number">149u32 </span>=&gt; <span class="number">200u8 </span>, <span class="number">49u32 </span>=&gt; <span class="number">39u8 </span>, <span class="number">82u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">291u32 </span>=&gt; <span class="number">10u8 </span>, <span class="number">12918u32 </span>=&gt; <span class="number">139u8 </span>, <span class="number">115u32 </span>=&gt; <span class="number">4u8 </span>, <span class="number">128u32 </span>=&gt; <span class="number">226u8 </span>, <span class="number">87u32 </span>=&gt; <span class="number">150u8 </span>, <span class="number">23u32 </span>=&gt; <span class="number">168u8 </span>, <span class="number">256u32 </span>=&gt; <span class="number">71u8 </span>, <span class="number">42u32 </span>=&gt; <span class="number">28u8 </span>, <span class="number">81u32 </span>=&gt; <span class="number">106u8 </span>, <span class="number">63u32 </span>=&gt; <span class="number">119u8 </span>, <span class="number">248u32 </span>=&gt; <span class="number">8u8 </span>, <span class="number">247u32 </span>=&gt; <span class="number">81u8 </span>, <span class="number">144u32 </span>=&gt; <span class="number">127u8 </span>, <span class="number">12901u32 </span>=&gt; <span class="number">254u8 </span>, <span class="number">100u32 </span>=&gt; <span class="number">175u8 </span>, <span class="number">6u32 </span>=&gt; <span class="number">104u8 </span>, <span class="number">10002u32 </span>=&gt; <span class="number">186u8 </span>, <span class="number">64u32 </span>=&gt; <span class="number">191u8 </span>, <span class="number">397u32 </span>=&gt; <span class="number">182u8 </span>, <span class="number">268u32 </span>=&gt; <span class="number">14u8 </span>, <span class="number">89u32 </span>=&gt; <span class="number">231u8 </span>, <span class="number">12900u32 </span>=&gt; <span class="number">114u8 </span>, <span class="number">67u32 </span>=&gt; <span class="number">21u8 </span>, <span class="number">284u32 </span>=&gt; <span class="number">99u8 </span>, <span class="number">261u32 </span>=&gt; <span class="number">179u8 </span>, <span class="number">37u32 </span>=&gt; <span class="number">212u8 </span>, <span class="number">112u32 </span>=&gt; <span class="number">174u8 </span>, <span class="number">339u32 </span>=&gt; <span class="number">199u8 </span>, <span class="number">258u32 </span>=&gt; <span class="number">187u8 </span>, <span class="number">91u32 </span>=&gt; <span class="number">63u8 </span>, <span class="number">109u32 </span>=&gt; <span class="number">185u8 </span>, <span class="number">118u32 </span>=&gt; <span class="number">56u8 </span>, <span class="number">66u32 </span>=&gt; <span class="number">148u8 </span>, <span class="number">103u32 </span>=&gt; <span class="number">208u8 </span>, <span class="number">30u32 </span>=&gt; <span class="number">39u8 </span>, <span class="number">12903u32 </span>=&gt; <span class="number">249u8 </span>, <span class="number">77u32 </span>=&gt; <span class="number">143u8 </span>, <span class="number">241u32 </span>=&gt; <span class="number">90u8 </span>, <span class="number">269u32 </span>=&gt; <span class="number">109u8 </span>, <span class="number">332u32 </span>=&gt; <span class="number">236u8 </span>, <span class="number">395u32 </span>=&gt; <span class="number">0u8 </span>, <span class="number">380u32 </span>=&gt; <span class="number">232u8 </span>, <span class="number">73u32 </span>=&gt; <span class="number">38u8 </span>, <span class="number">410u32 </span>=&gt; <span class="number">160u8 </span>, <span class="number">122u32 </span>=&gt; <span class="number">203u8 </span>, <span class="number">93u32 </span>=&gt; <span class="number">47u8 </span>, <span class="number">21u32 </span>=&gt; <span class="number">159u8 </span>, <span class="number">27u32 </span>=&gt; <span class="number">144u8 </span>, <span class="number">44u32 </span>=&gt; <span class="number">221u8 </span>, <span class="number">54u32 </span>=&gt; <span class="number">15u8 </span>, <span class="number">10003u32 </span>=&gt; <span class="number">4u8 </span>, <span class="number">283u32 </span>=&gt; <span class="number">74u8 </span>, <span class="number">336u32 </span>=&gt; <span class="number">245u8 </span>, <span class="number">301u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">276u32 </span>=&gt; <span class="number">18u8 </span>, <span class="number">105u32 </span>=&gt; <span class="number">93u8 </span>, <span class="number">24u32 </span>=&gt; <span class="number">24u8 </span>, <span class="number">46u32 </span>=&gt; <span class="number">11u8 </span>, <span class="number">113u32 </span>=&gt; <span class="number">124u8 </span>, <span class="number">127u32 </span>=&gt; <span class="number">25u8 </span>, <span class="number">47u32 </span>=&gt; <span class="number">153u8 </span>, <span class="number">2u32 </span>=&gt; <span class="number">137u8 </span>, <span class="number">230u32 </span>=&gt; <span class="number">163u8 </span>, <span class="number">86u32 </span>=&gt; <span class="number">5u8 </span>, <span class="number">243u32 </span>=&gt; <span class="number">85u8 </span>, <span class="number">373u32 </span>=&gt; <span class="number">117u8 </span>, <span class="number">233u32 </span>=&gt; <span class="number">35u8 </span>, <span class="number">330u32 </span>=&gt; <span class="number">23u8 </span>, <span class="number">80u32 </span>=&gt; <span class="number">14u8 </span>, <span class="number">244u32 </span>=&gt; <span class="number">95u8 </span>, <span class="number">41u32 </span>=&gt; <span class="number">28u8 </span>, <span class="number">143u32 </span>=&gt; <span class="number">131u8 </span>, <span class="number">10001u32 </span>=&gt; <span class="number">209u8 </span>, <span class="number">108u32 </span>=&gt; <span class="number">32u8 </span>, <span class="number">33u32 </span>=&gt; <span class="number">104u8 </span>, <span class="number">411u32 </span>=&gt; <span class="number">106u8 </span>, <span class="number">147u32 </span>=&gt; <span class="number">154u8 </span>, <span class="number">231u32 </span>=&gt; <span class="number">105u8 </span>, <span class="number">253u32 </span>=&gt; <span class="number">83u8 </span>, <span class="number">387u32 </span>=&gt; <span class="number">4u8 </span>, <span class="number">232u32 </span>=&gt; <span class="number">151u8 </span>, <span class="number">129u32 </span>=&gt; <span class="number">46u8 </span>, <span class="number">35u32 </span>=&gt; <span class="number">244u8 </span>, <span class="number">45u32 </span>=&gt; <span class="number">232u8 </span>, <span class="number">287u32 </span>=&gt; <span class="number">1u8 </span>, <span class="number">288u32 </span>=&gt; <span class="number">20u8 </span>, <span class="number">300u32 </span>=&gt; <span class="number">217u8 </span>, <span class="number">323u32 </span>=&gt; <span class="number">78u8 </span>, <span class="number">51u32 </span>=&gt; <span class="number">196u8 </span>, <span class="number">126u32 </span>=&gt; <span class="number">220u8 </span>, <span class="number">140u32 </span>=&gt; <span class="number">181u8 </span>, <span class="number">335u32 </span>=&gt; <span class="number">225u8 </span>, <span class="number">267u32 </span>=&gt; <span class="number">35u8 </span>, <span class="number">92u32 </span>=&gt; <span class="number">54u8 </span>, <span class="number">65u32 </span>=&gt; <span class="number">118u8 </span>, <span class="number">251u32 </span>=&gt; <span class="number">170u8 </span>, <span class="number">388u32 </span>=&gt; <span class="number">8u8 </span>, <span class="number">290u32 </span>=&gt; <span class="number">251u8 </span>, <span class="number">40u32 </span>=&gt; <span class="number">230u8 </span>, <span class="number">114u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">235u32 </span>=&gt; <span class="number">179u8 </span>, <span class="number">26u32 </span>=&gt; <span class="number">170u8 </span>, <span class="number">121u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">123u32 </span>=&gt; <span class="number">250u8 </span>, <span class="number">266u32 </span>=&gt; <span class="number">193u8 </span>, <span class="number">234u32 </span>=&gt; <span class="number">150u8 </span>, <span class="number">141u32 </span>=&gt; <span class="number">47u8 </span>, <span class="number">133u32 </span>=&gt; <span class="number">6u8 </span>, <span class="number">321u32 </span>=&gt; <span class="number">88u8 </span>, <span class="number">119u32 </span>=&gt; <span class="number">116u8 </span>, <span class="number">350u32 </span>=&gt; <span class="number">232u8 </span>, <span class="number">70u32 </span>=&gt; <span class="number">124u8 </span>, <span class="number">101u32 </span>=&gt; <span class="number">102u8 </span>, <span class="number">12915u32 </span>=&gt; <span class="number">94u8 </span>, <span class="number">110u32 </span>=&gt; <span class="number">84u8 </span>, <span class="number">263u32 </span>=&gt; <span class="number">133u8 </span>, <span class="number">334u32 </span>=&gt; <span class="number">72u8 </span>, <span class="number">132u32 </span>=&gt; <span class="number">85u8 </span>, <span class="number">104u32 </span>=&gt; <span class="number">56u8 </span>, <span class="number">280u32 </span>=&gt; <span class="number">70u8 </span>, <span class="number">74u32 </span>=&gt; <span class="number">20u8 </span>, <span class="number">5u32 </span>=&gt; <span class="number">217u8 </span>, <span class="number">242u32 </span>=&gt; <span class="number">104u8 </span>, <span class="number">386u32 </span>=&gt; <span class="number">132u8 </span>, <span class="number">83u32 </span>=&gt; <span class="number">22u8 </span>, <span class="number">111u32 </span>=&gt; <span class="number">34u8 </span>, <span class="number">400u32 </span>=&gt; <span class="number">110u8 </span>, <span class="number">1u32 </span>=&gt; <span class="number">124u8 </span>, <span class="number">260u32 </span>=&gt; <span class="number">146u8 </span>, <span class="number">264u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">265u32 </span>=&gt; <span class="number">26u8 </span>, <span class="number">62u32 </span>=&gt; <span class="number">183u8 </span>, <span class="number">259u32 </span>=&gt; <span class="number">92u8 </span>, <span class="number">137u32 </span>=&gt; <span class="number">195u8 </span>, <span class="number">299u32 </span>=&gt; <span class="number">19u8 </span>, <span class="number">390u32 </span>=&gt; <span class="number">156u8 </span>, <span class="number">136u32 </span>=&gt; <span class="number">1u8 </span>, <span class="number">275u32 </span>=&gt; <span class="number">126u8 </span>, <span class="number">146u32 </span>=&gt; <span class="number">103u8 </span>, <span class="number">120u32 </span>=&gt; <span class="number">134u8 </span>, <span class="number">20u32 </span>=&gt; <span class="number">214u8 </span>, <span class="number">4u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">116u32 </span>=&gt; <span class="number">76u8 </span>, <span class="number">7u32 </span>=&gt; <span class="number">119u8 </span>, <span class="number">413u32 </span>=&gt; <span class="number">77u8 </span>, <span class="number">162u32 </span>=&gt; <span class="number">189u8 </span>, <span class="number">124u32 </span>=&gt; <span class="number">87u8 </span>, <span class="number">22u32 </span>=&gt; <span class="number">220u8 </span>, <span class="number">61u32 </span>=&gt; <span class="number">167u8 </span>, <span class="number">12902u32 </span>=&gt; <span class="number">140u8 </span>, <span class="number">225u32 </span>=&gt; <span class="number">208u8 </span>, <span class="number">270u32 </span>=&gt; <span class="number">59u8 </span>, <span class="kw">_ </span>=&gt; { <span class="number">0 </span>} , } } }
</code></pre></div>
</section></main><div id="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="mavlink" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>